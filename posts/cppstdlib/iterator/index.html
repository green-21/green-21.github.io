<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>6. Iterators - 접근 인터페이스 | gReen</title>
<meta name=keywords content="cpp"><meta name=description content="자료구조와 알고리즘의 의존 관계를 해결한 이터레이터 패턴에 대한 정리"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/iterator/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/iterator/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="6. Iterators - 접근 인터페이스"><meta property="og:description" content="자료구조와 알고리즘의 의존 관계를 해결한 이터레이터 패턴에 대한 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/iterator/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-21T19:33:36+09:00"><meta property="article:modified_time" content="2023-08-21T19:33:36+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="6. Iterators - 접근 인터페이스"><meta name=twitter:description content="자료구조와 알고리즘의 의존 관계를 해결한 이터레이터 패턴에 대한 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"6. Iterators - 접근 인터페이스","item":"https://green-21.github.io/posts/cppstdlib/iterator/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"6. Iterators - 접근 인터페이스","name":"6. Iterators - 접근 인터페이스","description":"자료구조와 알고리즘의 의존 관계를 해결한 이터레이터 패턴에 대한 정리","keywords":["cpp"],"articleBody":" Iterator는 다양한 자료구조를 일관된 하나의 방법으로 접근할 수 있도록 만든 포인터와 유사한 인터페이스이다. 다양한 std의 함수들은 자료구조의 종류에 상관 없이 이터레이터를 통해서 요소에 접근할 수 있다. 포인터와 거의 유사한 연산을 수행한다.\n// iter는 어떤 이터레이터이다. // 이터레이터가 가리키는 요소의 값을 읽는다. cout \u003c\u003c *iter \u003c\u003c endl; // 이터레이터가 가리키는 요소의의 값을 수정한다. *iter = 10; // 다음 위치의 이터레이터가 된다. iter++; // 어떤 컨테이너의 시작 이터레이터와 끝의 다음 이터레이터를 반환하는 메서드 // 알고리즘은 내부적으로 이터레이터의 연산을 이용해 자신의 역할 수행한다. sort(con.begin(), con.end()); 이터레이터 자체는 타입이 아니다. 이터레이터는 concept이라는 키워드를 이용해 정의하는데, 정의되는 내용은 이터레이터로써 갖추어야할 연산이나, 요구 사항 등이다. concept은 템플릿의 인수로 올바른 타입이 올 수 있도록 요구 사항을 지정한다. 만약 어떤 타입 T가 이러한 요구사항을 충족한다면, 타입 T를 이터레이터라고 부를 수 있고, 이터레이터가 필요한 자리에 사용할 사용할 수 있다. (개인적으로는 덕타이핑이랑 굉장히 유사하다고 느꼈다.)\n각 컨테이너는 이터레이터 개념(concept)을 충족하는 이터레이터 실체 클래스를 각각 구현한다. 예를 들어 vector 컨테이너는 내부적으로 vector::iterator 라는 별도의 이터레이터를 갖는 식이다. 직접 이터레이터 클래스를 만들 수 있다. 또, 포인터 타입은 이터레이터의 요구사항을 충족할 수 있는 연산을 모두 가졌기 때문에 이를 이터레이터로 사용할 수도 있다.\n이터레이터는 요구하는 연산에 따라서 input_iterator, random_access_iterator 등 다양한 이터레이터 개념이 있다. 그러나, 사용하는 입장에서 이러한 종류를 아는 것은 그다지 중요하다고 생각되지 않아 생략한다. ms 공식문서에서 자세한 정보를 얻을 수 있다.\n이터레이터는 증감을 통해 각 요소들의 순서 관계를 갖는다. 따라서 어떤 이터레이터 i가 허용된 연산을 통해서 이터레이터 j에 도달할 수 있다면, 두 이터레이터는 같은 sequence를 참조한다고 한다. 이터레이터간의 연산은 같은 sequence를 참조할 때만 유효하다. 아무 연관관계가 없는 이터레이터에서의 연산은 정의되지 않는다.\niter1와 iter3는 같은 sequence를 참조한다. iter2과 iter3는 다른 sequence를 참조한다. iter4는 아무 연관관계를 갖지 않는다. 만약 이터레이터의 범위를 요구하는 함수에 iter1과 함께 iter2나 iter4를 넘겨준다면 문제가 생길 것이다.\n1. 컨테이너에서 이터레이터 얻기 중요한 것은 일단 컨테이너에서 내부 요소에 대한 이터레이터를 제공한다는 것이다. 컨테이너는 이터레이터를 이용해 내부 원소들에 접근할 수 있도록 자신의 요소들의 시작과 끝을 가리키는 이터레이터를 제공한다. begin()을 통해서 컨테이너의 시작점을, end()를 통해서 끝의 다음 위치를 얻을 수 있다. end()는 끝 요소가 아니라 끝의 다음을 가리킨다는 것에 주의해야 한다. 이를 past-the-end라고 하는데, 어떤 요소도 가리키지 않고 단순히 해당 sequence가 끝났음을 의미한다. 항상 정의되지 않은 값을 가지고 있다. int arr[10]에서 arr[10]은 out of range라는 것과 비슷하다고 생각하면 된다.\n// vector container의 이터레이터 std::vector\u003cint\u003e v{1,2,3}; auto b1 = v.begin();\t// 1을 가리키는 이터레이터 auto e1 = v.end();\t// 끝인 3의 다음을 가리키는 이터레이터 auto b2 = std::begin(v);\t// 메서드가 아닌 함수로도 존재한다. auto e2 = std::end(v); // e1++;\t// error!! past-the-end의 다음은 없다. // *e2;\t// error!! past-the-end는 아무것도 가리키지 않는다. end()는 반복에서 끝을 찾을 때나, set과 같은 자료구조에서 특정 값을 찾을 때, 컨테이너 안에 해당 값이 존재하지 않음을 표현할 때 사용하기도 한다.\n#include #include #include using namespace std; int main() { vector\u003cint\u003e v{ 1,2,3,4,5 }; auto iter = v.begin(); while (iter != v.end()) { cout \u003c\u003c *iter++ \u003c\u003c ' '; } cout \u003c\u003c endl; set\u003cint\u003e s{ 1,2,3,4,5 }; if (s.find(10) == s.end()) { cout \u003c\u003c \"10은 s안에 존재하지 않음\" \u003c\u003c endl; } else { cout \u003c\u003c \"10이 s안에 존재함\" \u003c\u003c endl; } } 1 2 3 4 5 10은 set 안에 존재하지 않음 begin()/end()에서 파생된 두가지 기능이 더 있다. 첫 번째는 cbegin()과 cend()인데, 여기서 접두사 c는 const를 뜻하는 것으로 간접 참조해서 데이터를 읽을 수는 있지만, 수정할 수는 없도록 제한해서 사용하고자 할 때 사용한다. 두 번째는 rbegin()과 rend()이다. 접두사 r은 reverse를 뜻한다. 여기서 rbegin()은 마지막 원소를 가리키고, rend()는 첫번째 이전 원소를 가리킨다. r과 c를 동시해 사용한 crbegin()과 crend()도 있다.\nvector\u003cint\u003e v{1,2,3,4,5}; for(auto i=v.begin(); i!=v.end(); i++) { *i -= 1;\t// 0,1,2,3,4 } // cbegin을 사용했으면 cend를 사용해야함에 주의할 것 for(auto i=v.cbegin(); i!=v.cend(); i++) { *i += 1; // ERROR!!!!! const는 수정할 수 없음. } for(auto i=v.rbegin(); i!=v.rend(); i++) { cout \u003c\u003c *i \u003c\u003c ' '; // 4 3 2 1 0 } 이터레이터를 제공하는 모든 타입은 범위 기반 반복문에서 사용할 수 있다.\nvector\u003cint\u003e v{1,2,3,4,5}; for(auto\u0026 i : v) { cout \u003c\u003c i \u003c\u003c ' '; // 1 2 3 4 5 } 2. 연산 이터레이터의 모든 연산은 포인터의 연산과 대부분 유사하다.\n#include #include #include using namespace std; int main() { vector\u003cint\u003e v1{ 1,2,3,4 }; vector\u003cint\u003e::iterator iter; // 1. 대입 연산 iter = v1.begin(); // v1.begin()값을 읽어 iter에 쓴다. // 2. 역참조 읽기, 쓰기 // 이터레이터가 가리키는 요소의 값에 접근한다. // 일부 이터레이터는 쓰기가 허용되지 않는다. *iter;\t// vector의 첫 번째 요소인 1을 가리킨다. *iter = 10;\t// vector의 첫 번째 요소인 1을 10으로 덮어 쓴다. // 3. 증감\u0026감소 // 일부 이터레이터는 감소를 지원하지 않는다. ++iter;\t// vector의 두 번쨰 요소를 가리킨다. iter++;\t// vector의 세 번쨰 요소를 가리킨다. --iter;\t// *iter == 2 iter--;\t// *iter == 10 // random access 및 정수와의 연산 iter = v1.begin(); *(iter + 2);\t// 3 iter[2];\t// 3 iter = v1.end(); *(iter - 1);\t// 4 auto iter2 = v1.begin() + 2; // 동등성 비교 iter == iter2;\t// false iter != iter2;\t// true // 대소 비교 iter \u003e= iter2;\t// true iter \u003c= iter2;\t// false iter \u003c iter2;\t// true iter \u003e iter2;\t// false // 이터리이터간 덧셈 뺄셈 iter - iter2;\t// 2 iter + iter;\t// error!!!! 덧셈은 불가능. } 포인터 타입에 const를 적용해서 연산을 제한하는 것처럼, 이터레이터도 종류에 따라서 지원하는 연산이 다르다. 컨테이너에서 제공하는 모든 이터레이터는 요소의 값을 읽을 수 있으며 ++로 다음 이터레이터를 가리키게 할 수 있다. 그러나, 감소하거나, 가리키는 값을 수정하거나, random access는 지원하지 않을 수도 있다. 이는 컨테이너의 내부 자료구조에 따른다.\n3. 알고리즘에 이터레이터 전달 std에서 제공하는 대부분의 알고리즘 함수들은 sequence의 시작점과 끝점을 입력을 받는다. 해당 구간을 입력받은 함수들은 해당 구간과 그 구간의 이터레이터간 관계에 따라서 알고리즘을 수행한다.\n#include #include #include using namespace std; int main() { // sort는 오름차순으로 정렬한다. // 일반적인 사용법 vector\u003cint\u003e v1{ 3,1,4,5,2 }; sort(v1.begin(), v1.end());\t// 1 2 3 4 5 // vector의 부분적인 범위만 사용 vector\u003cint\u003e v2{ 5,4,3,1,2 }; sort(v2.begin(), v2.begin() + 2);\t// 4 5 3 1 2 // 정렬은 이터레이터간의 순서에 따라서 수행됨. // 역순인 이터레이터를 사용해 역순으로 오름차순 정렬이 된다. (내림차순) vector\u003cint\u003e v3{ 1,2,3,4,5 }; sort(v3.rbegin(), v3.rend());\t// 5 4 3 2 1 // 포인터를 이터레이터로 사용. int arr[] = { 8,1,5,4,2 }; sort(arr, arr + 5);\t// 1 2 4 5 8 } 4. 이터레이터 무효화 만약 정렬과 같은 방법으로 기존의 순서가 바꼈다면, 정렬 이전의 관계를 가지고 있는 최신화 되지 않은 이터레이터의 관계는 문제가 될 수 있다. 그래서, 이 때, 최신화 되지 않은 이터레이터는 어떠한 연관도 갖지 않도록 무효화(invalidation) 된다. 재할당이 일어날 때, 삽입 혹은 삭제로 여러 요소들의 관계가 변할 때 등과 같이 다양한 이유로 이터레이터가 무효화 될 수 있으며, 이를 신경쓰지 않는 가장 좋은 방법은 연산 후 매번 새로운 이터레이터를 사용하는 것이다.\n5. 직접 구현하기 새로운 자료구조를 만들면서 이터레이터를 제공하고 싶을 때, 이터레이터를 직접 만들 수 있다. 다음은 단일 연결리스트와 이를 위한 이터레이터를 구현 예제이다.\nLinkedList.h #pragma once // 단일 연결 리스트의 노드 template\u003cclass T\u003e struct Node { T data; Node* next = nullptr; Node(T data) : data(data) {}; }; template\u003cclass T\u003e class LinkedList { private: Node\u003cT\u003e* head = nullptr; int size = 0; public: // LinkedList 내부에 정의된 이터레이터 class iterator { private: Node\u003cT\u003e* ptr; public: iterator(Node\u003cT\u003e* ptr) : ptr(ptr) {}; // 역참조 연산 정의 T\u0026 operator*() { return this-\u003eptr-\u003edata; } // 전위 증감 연산자 정의 iterator\u0026 operator++() { if (ptr) ptr = ptr-\u003enext; return *this; } // 비교 연산 정의 bool operator!= (const iterator \u0026 other) const { return ptr != other.ptr; } bool operator== (const iterator\u0026 other) const { return ptr == other.ptr; } }; public: ~LinkedList() { while (head) { Node\u003cT\u003e* temp = head; head = head-\u003enext; delete temp; } } T\u0026 get(int index) { if (index \u003e= size) throw \"out of range\"; auto iter = this-\u003ebegin(); for (int i = 0; i \u003c index; i++) { ++iter; }; return *iter; } Node\u003cT\u003e* append_front(T val) { auto node = new Node(val); if (this-\u003ehead) { node-\u003enext = head; } this-\u003ehead = node; this-\u003esize++; return node; } // 이터레이터를 반환하는 메서드 iterator begin() { return iterator(this-\u003ehead); } iterator end() { return iterator(nullptr); } }; main.cpp #include #include #include\"LinkedList.h\" using namespace std; int main() { LinkedList\u003cint\u003e list; list.append_front(1); list.append_front(2); list.append_front(3); list.append_front(4); list.append_front(5); for (auto iter = list.begin(); iter != list.end(); ++iter) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 5 4 3 2 1 } cout \u003c\u003c endl; cout \u003c\u003c list.get(2) \u003c\u003c endl;\t// 2 // error : 비교 및 대입 관련된 연산 요구사항이 충족되지 않음. // sort(list.begin(), list.end());\t// 데이터를 채우는 함수 fill(list.begin(), list.end(), 1); for (auto i : list) { cout \u003c\u003c i \u003c\u003c ' ';\t// 1 1 1 1 1 } } 5 4 3 2 1 3 1 1 1 1 1 LinkedList의 이터레이터는 역참조와 증감 연산자만 정의되어 있다. 따라서 해당 연산자만으로 요구사항을 충족하는 fill 함수나 범위 기반 for에서는 이터레이터로 사용할 수 있지만, 비교 연산이 필요한 sort에서는 요구사항을 충족하지 못했기 때문에 사용할 수 없다.\n","wordCount":"1445","inLanguage":"ko","datePublished":"2023-08-21T19:33:36+09:00","dateModified":"2023-08-21T19:33:36+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/iterator/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>6. Iterators - 접근 인터페이스</h1><div class=post-meta>&lt;span title='2023-08-21 19:33:36 +0900 +0900'>8월 21, 2023&lt;/span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90%ec%84%9c-%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0-%ec%96%bb%ea%b8%b0 aria-label="1. 컨테이너에서 이터레이터 얻기">1. 컨테이너에서 이터레이터 얻기</a></li><li><a href=#2-%ec%97%b0%ec%82%b0 aria-label="2. 연산">2. 연산</a></li><li><a href=#3-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%97%90-%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0-%ec%a0%84%eb%8b%ac aria-label="3. 알고리즘에 이터레이터 전달">3. 알고리즘에 이터레이터 전달</a></li><li><a href=#4-%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0-%eb%ac%b4%ed%9a%a8%ed%99%94 aria-label="4. 이터레이터 무효화">4. 이터레이터 무효화</a></li><li><a href=#5-%ec%a7%81%ec%a0%91-%ea%b5%ac%ed%98%84%ed%95%98%ea%b8%b0 aria-label="5. 직접 구현하기">5. 직접 구현하기</a></li></ul></div></details></div><div class=post-content><p>&nbsp;&nbsp;
<code>Iterator</code>는 다양한 자료구조를 일관된 하나의 방법으로 접근할 수 있도록 만든 포인터와 유사한 인터페이스이다. <strong>다양한 std의 함수들은 자료구조의 종류에 상관 없이 이터레이터를 통해서 요소에 접근할 수 있다.</strong> 포인터와 거의 유사한 연산을 수행한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// iter는 어떤 이터레이터이다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 이터레이터가 가리키는 요소의 값을 읽는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 이터레이터가 가리키는 요소의의 값을 수정한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>*</span>iter <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 다음 위치의 이터레이터가 된다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>iter<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 어떤 컨테이너의 시작 이터레이터와 끝의 다음 이터레이터를 반환하는 메서드
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 알고리즘은 내부적으로 이터레이터의 연산을 이용해 자신의 역할 수행한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sort(con.begin(), con.end());
</span></span></code></pre></div><br><p>&nbsp;&nbsp;
<strong>이터레이터 자체는 타입이 아니다.</strong> 이터레이터는 <code>concept</code>이라는 키워드를 이용해 정의하는데, 정의되는 내용은 이터레이터로써 갖추어야할 연산이나, 요구 사항 등이다. concept은 템플릿의 인수로 올바른 타입이 올 수 있도록 요구 사항을 지정한다. <strong>만약 어떤 타입 T가 이러한 요구사항을 충족한다면, 타입 T를 이터레이터라고 부를 수 있고, 이터레이터가 필요한 자리에 사용할 사용할 수 있다.</strong> (개인적으로는 덕타이핑이랑 굉장히 유사하다고 느꼈다.)</p><p>&nbsp;&nbsp;
각 컨테이너는 이터레이터 개념(concept)을 충족하는 이터레이터 실체 클래스를 각각 구현한다. 예를 들어 <code>vector</code> 컨테이너는 내부적으로 <code>vector&lt;T>::iterator</code> 라는 별도의 이터레이터를 갖는 식이다. 직접 이터레이터 클래스를 만들 수 있다. 또, 포인터 타입은 이터레이터의 요구사항을 충족할 수 있는 연산을 모두 가졌기 때문에 이를 이터레이터로 사용할 수도 있다.</p><p>&nbsp;&nbsp;
이터레이터는 요구하는 연산에 따라서 <code>input_iterator</code>, <code>random_access_iterator</code> 등 다양한 이터레이터 개념이 있다. 그러나, 사용하는 입장에서 이러한 종류를 아는 것은 그다지 중요하다고 생각되지 않아 생략한다. <a href="https://learn.microsoft.com/en-us/cpp/standard-library/iterator-concepts?view=msvc-170#output_iterator">ms 공식문서</a>에서 자세한 정보를 얻을 수 있다.</p><p>&nbsp;&nbsp;
이터레이터는 증감을 통해 각 요소들의 순서 관계를 갖는다. 따라서 어떤 이터레이터 i가 허용된 연산을 통해서 이터레이터 j에 도달할 수 있다면, 두 이터레이터는 같은 sequence를 참조한다고 한다. 이터레이터간의 연산은 같은 sequence를 참조할 때만 유효하다. 아무 연관관계가 없는 이터레이터에서의 연산은 정의되지 않는다.</p><p><figure><img loading=lazy src=2.png#center width=500></figure>&nbsp;&nbsp;
iter1와 iter3는 같은 sequence를 참조한다. iter2과 iter3는 다른 sequence를 참조한다. iter4는 아무 연관관계를 갖지 않는다. 만약 이터레이터의 범위를 요구하는 함수에 iter1과 함께 iter2나 iter4를 넘겨준다면 문제가 생길 것이다.</p><p><br>&nbsp;</p><h2 id=1-컨테이너에서-이터레이터-얻기>1. 컨테이너에서 이터레이터 얻기<a hidden class=anchor aria-hidden=true href=#1-컨테이너에서-이터레이터-얻기>#</a></h2><p><figure><img loading=lazy src=1.png#center width=450></figure>&nbsp;&nbsp;
중요한 것은 일단 컨테이너에서 내부 요소에 대한 이터레이터를 제공한다는 것이다. 컨테이너는 이터레이터를 이용해 내부 원소들에 접근할 수 있도록 자신의 요소들의 시작과 끝을 가리키는 이터레이터를 제공한다. <code>begin()</code>을 통해서 컨테이너의 시작점을, <code>end()</code>를 통해서 끝의 다음 위치를 얻을 수 있다. <strong><code>end()</code>는 끝 요소가 아니라 끝의 다음을 가리킨다는 것에 주의해야 한다.</strong> 이를 <code>past-the-end</code>라고 하는데, 어떤 요소도 가리키지 않고 단순히 해당 sequence가 끝났음을 의미한다. 항상 정의되지 않은 값을 가지고 있다. <code>int arr[10]</code>에서 <code>arr[10]</code>은 out of range라는 것과 비슷하다고 생각하면 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// vector container의 이터레이터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> b1 <span style=color:#f92672>=</span> v.begin();		<span style=color:#75715e>// 1을 가리키는 이터레이터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> e1 <span style=color:#f92672>=</span> v.end();			<span style=color:#75715e>// 끝인 3의 다음을 가리키는 이터레이터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> b2 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>begin(v);	<span style=color:#75715e>// 메서드가 아닌 함수로도 존재한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> e2 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>end(v);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// e1++;		// error!!  past-the-end의 다음은 없다.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// *e2;			// error!! past-the-end는 아무것도 가리키지 않는다.
</span></span></span></code></pre></div><br><p>&nbsp;&nbsp;
<code>end()</code>는 반복에서 끝을 찾을 때나, set과 같은 자료구조에서 특정 값을 찾을 때, 컨테이너 안에 해당 값이 존재하지 않음을 표현할 때 사용하기도 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;vector&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;set&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> v.begin();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (iter <span style=color:#f92672>!=</span> v.end()) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter<span style=color:#f92672>++</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (s.find(<span style=color:#ae81ff>10</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;10은 s안에 존재하지 않음&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;10이 s안에 존재함&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>1 2 3 4 5
10은 set 안에 존재하지 않음
</code></pre><p><br>&nbsp;&nbsp;
<code>begin()</code>/<code>end()</code>에서 파생된 두가지 기능이 더 있다. 첫 번째는 <code>cbegin()</code>과 <code>cend()</code>인데, 여기서 접두사 c는 const를 뜻하는 것으로 간접 참조해서 데이터를 읽을 수는 있지만, 수정할 수는 없도록 제한해서 사용하고자 할 때 사용한다.<br>&nbsp;&nbsp;
두 번째는 <code>rbegin()</code>과 <code>rend()</code>이다. 접두사 r은 reverse를 뜻한다. 여기서 <code>rbegin()</code>은 마지막 원소를 가리키고, <code>rend()</code>는 첫번째 이전 원소를 가리킨다. r과 c를 동시해 사용한 <code>crbegin()</code>과 <code>crend()</code>도 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> i<span style=color:#f92672>=</span>v.begin(); i<span style=color:#f92672>!=</span>v.end(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>i <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;				<span style=color:#75715e>// 0,1,2,3,4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// cbegin을 사용했으면 cend를 사용해야함에 주의할 것
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> i<span style=color:#f92672>=</span>v.cbegin(); i<span style=color:#f92672>!=</span>v.cend(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>; 				<span style=color:#75715e>// ERROR!!!!! const는 수정할 수 없음.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> i<span style=color:#f92672>=</span>v.rbegin(); i<span style=color:#f92672>!=</span>v.rend(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>; 		<span style=color:#75715e>// 4 3 2 1 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><br><strong>이터레이터를 제공하는 모든 타입은 범위 기반 반복문에서 사용할 수 있다.</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> i : v) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;  <span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><br>&nbsp;</p><h2 id=2-연산>2. 연산<a hidden class=anchor aria-hidden=true href=#2-연산>#</a></h2><p>이터레이터의 모든 연산은 포인터의 연산과 대부분 유사하다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;vector&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;algorithm&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span> };
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator iter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 1. 대입 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>=</span> v1.begin(); <span style=color:#75715e>// v1.begin()값을 읽어 iter에 쓴다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 2. 역참조 읽기, 쓰기
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 이터레이터가 가리키는 요소의 값에 접근한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 일부 이터레이터는 쓰기가 허용되지 않는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>*</span>iter;			<span style=color:#75715e>// vector의 첫 번째 요소인 1을 가리킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>*</span>iter <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;		<span style=color:#75715e>// vector의 첫 번째 요소인 1을 10으로 덮어 쓴다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 3. 증감&amp;감소
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 일부 이터레이터는 감소를 지원하지 않는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>++</span>iter;			<span style=color:#75715e>// vector의 두 번쨰 요소를 가리킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter<span style=color:#f92672>++</span>;			<span style=color:#75715e>// vector의 세 번쨰 요소를 가리킨다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>--</span>iter;			<span style=color:#75715e>// *iter == 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter<span style=color:#f92672>--</span>;			<span style=color:#75715e>// *iter == 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// random access 및 정수와의 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>=</span> v1.begin();
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>(iter <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);	<span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter[<span style=color:#ae81ff>2</span>];		<span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	iter <span style=color:#f92672>=</span> v1.end();
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span>(iter <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);	<span style=color:#75715e>// 4 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> iter2 <span style=color:#f92672>=</span> v1.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 동등성 비교
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>==</span> iter2;	<span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>!=</span> iter2;	<span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 대소 비교
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>&gt;=</span> iter2;	<span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>&lt;=</span> iter2;	<span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>&lt;</span> iter2;	<span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>&gt;</span> iter2;	<span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 이터리이터간 덧셈 뺄셈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>-</span> iter2;	<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iter <span style=color:#f92672>+</span> iter;	<span style=color:#75715e>// error!!!! 덧셈은 불가능.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><br>&nbsp;&nbsp;
포인터 타입에 const를 적용해서 연산을 제한하는 것처럼, 이터레이터도 종류에 따라서 지원하는 연산이 다르다. 컨테이너에서 제공하는 모든 이터레이터는 <strong>요소의 값을 읽을 수 있으며 ++로 다음 이터레이터를 가리키게 할 수 있다.</strong> 그러나, 감소하거나, 가리키는 값을 수정하거나, random access는 지원하지 않을 수도 있다. 이는 컨테이너의 내부 자료구조에 따른다.</p><figure><img loading=lazy src=3.png#center></figure><p><br>&nbsp;</p><h2 id=3-알고리즘에-이터레이터-전달>3. 알고리즘에 이터레이터 전달<a hidden class=anchor aria-hidden=true href=#3-알고리즘에-이터레이터-전달>#</a></h2><p>&nbsp;&nbsp;
std에서 제공하는 대부분의 알고리즘 함수들은 sequence의 시작점과 끝점을 입력을 받는다. 해당 구간을 입력받은 함수들은 해당 구간과 그 구간의 이터레이터간 관계에 따라서 알고리즘을 수행한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;vector&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;algorithm&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sort는 오름차순으로 정렬한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 일반적인 사용법
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1{ <span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>	sort(v1.begin(), v1.end());			<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// vector의 부분적인 범위만 사용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v2{ <span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>	sort(v2.begin(), v2.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);	<span style=color:#75715e>// 4 5 3 1 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 정렬은 이터레이터간의 순서에 따라서 수행됨.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 역순인 이터레이터를 사용해 역순으로 오름차순 정렬이 된다. (내림차순)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v3{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>	sort(v3.rbegin(), v3.rend());	<span style=color:#75715e>// 5 4 3 2 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 포인터를 이터레이터로 사용.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>	sort(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>);					<span style=color:#75715e>// 1 2 4 5 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><br>&nbsp;</p><h2 id=4-이터레이터-무효화>4. 이터레이터 무효화<a hidden class=anchor aria-hidden=true href=#4-이터레이터-무효화>#</a></h2><p>&nbsp;&nbsp;
만약 정렬과 같은 방법으로 기존의 순서가 바꼈다면, 정렬 이전의 관계를 가지고 있는 최신화 되지 않은 이터레이터의 관계는 문제가 될 수 있다. 그래서, 이 때, 최신화 되지 않은 이터레이터는 어떠한 연관도 갖지 않도록 무효화(invalidation) 된다. 재할당이 일어날 때, 삽입 혹은 삭제로 여러 요소들의 관계가 변할 때 등과 같이 다양한 이유로 이터레이터가 무효화 될 수 있으며, 이를 신경쓰지 않는 가장 좋은 방법은 연산 후 매번 새로운 이터레이터를 사용하는 것이다.</p><p><br>&nbsp;</p><h2 id=5-직접-구현하기>5. 직접 구현하기<a hidden class=anchor aria-hidden=true href=#5-직접-구현하기>#</a></h2><p>&nbsp;&nbsp;
새로운 자료구조를 만들면서 이터레이터를 제공하고 싶을 때, 이터레이터를 직접 만들 수 있다. 다음은 단일 연결리스트와 이를 위한 이터레이터를 구현 예제이다.</p><ul><li>LinkedList.h</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 단일 연결 리스트의 노드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> {
</span></span><span style=display:flex><span>	T data;
</span></span><span style=display:flex><span>	Node<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>	Node(T data) <span style=color:#f92672>:</span> data(data) {};
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedList</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> head <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// LinkedList 내부에 정의된 이터레이터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>iterator</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> ptr;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>		iterator(Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> ptr) <span style=color:#f92672>:</span> ptr(ptr) {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 역참조 연산 정의
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>ptr<span style=color:#f92672>-&gt;</span>data; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 전위 증감 연산자 정의
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		iterator<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>++</span>() {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (ptr) ptr <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 비교 연산 정의
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>!=</span> (<span style=color:#66d9ef>const</span> iterator <span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> ptr <span style=color:#f92672>!=</span> other.ptr;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>==</span> (<span style=color:#66d9ef>const</span> iterator<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> ptr <span style=color:#f92672>==</span> other.ptr;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>~</span>LinkedList() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>			Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> temp <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>			head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>delete</span> temp;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	T<span style=color:#f92672>&amp;</span> get(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (index <span style=color:#f92672>&gt;=</span> size) <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;out of range&#34;</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>begin();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> index; i<span style=color:#f92672>++</span>) { <span style=color:#f92672>++</span>iter; };
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>iter;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	Node<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> append_front(T val) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>auto</span> node <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(val);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>head) {
</span></span><span style=display:flex><span>			node<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>head <span style=color:#f92672>=</span> node;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> node;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 이터레이터를 반환하는 메서드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	iterator <span style=color:#a6e22e>begin</span>() { <span style=color:#66d9ef>return</span> iterator(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>head); }
</span></span><span style=display:flex><span>	iterator <span style=color:#a6e22e>end</span>() { <span style=color:#66d9ef>return</span> iterator(<span style=color:#66d9ef>nullptr</span>); }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li>main.cpp</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;algorithm&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include&#34;LinkedList.h&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	LinkedList<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> list;
</span></span><span style=display:flex><span>	list.append_front(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	list.append_front(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	list.append_front(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>	list.append_front(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>	list.append_front(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> list.begin(); iter <span style=color:#f92672>!=</span> list.end(); <span style=color:#f92672>++</span>iter) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;			<span style=color:#75715e>// 5 4 3 2 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> list.get(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// error : 비교 및 대입 관련된 연산 요구사항이 충족되지 않음.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// sort(list.begin(), list.end());	
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 데이터를 채우는 함수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fill(list.begin(), list.end(), <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> i : list) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;				<span style=color:#75715e>// 1 1 1 1 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>5 4 3 2 1
3
1 1 1 1 1
</code></pre><p>&nbsp;&nbsp;
LinkedList의 이터레이터는 역참조와 증감 연산자만 정의되어 있다. 따라서 해당 연산자만으로 요구사항을 충족하는 fill 함수나 범위 기반 for에서는 이터레이터로 사용할 수 있지만, 비교 연산이 필요한 sort에서는 요구사항을 충족하지 못했기 때문에 사용할 수 없다.</p><br></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/array/><span class=title>« 이전 페이지</span><br><span>7. array: 정적 배열 컨테이너</span>
</a><a class=next href=https://green-21.github.io/posts/cppstdlib/allocator/><span class=title>다음 페이지 »</span><br><span>5. Allocators - 컨테이너의 동적 할당과 해제</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>