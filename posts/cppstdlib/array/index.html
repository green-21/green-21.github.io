<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>7. array: 정적 배열 컨테이너 | gReen</title>
<meta name=keywords content="cpp"><meta name=description content="정적 배열 컨테이너 array에 대한 소개"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/array/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/array/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="7. array: 정적 배열 컨테이너"><meta property="og:description" content="정적 배열 컨테이너 array에 대한 소개"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/array/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-23T00:47:13+09:00"><meta property="article:modified_time" content="2023-08-23T00:47:13+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="7. array: 정적 배열 컨테이너"><meta name=twitter:description content="정적 배열 컨테이너 array에 대한 소개"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"7. array: 정적 배열 컨테이너","item":"https://green-21.github.io/posts/cppstdlib/array/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"7. array: 정적 배열 컨테이너","name":"7. array: 정적 배열 컨테이너","description":"정적 배열 컨테이너 array에 대한 소개","keywords":["cpp"],"articleBody":"template \u003cclass Ty, std::size_t N\u003e class array; array는 기존 정적 배열을 구현한 컨테이너이다. 헤더에서 정의된다. Ty에는 배열의 타입이, N에는 정의할 크기가 들어간다. msvc++ 기준으로는 array 컨테이너 안에 실제로 값이 저장되는 정적 배열 Ty _Elems[N]가 public으로 선언 되어 있다. (왜 public으로 드러나 있는지는 잘 모르겠다.)\n단순히 생각하면 기존 정적 배열 대신 array를 사용할만한 경우는 없어보인다. 헤더도 추가로 써야하고, 타이핑 길이도 더 길게해야하고 귀찮다. 그러나 몇 가지 이점이 있다.\n함수를 통해 배열을 주고 받을 때, 배열의 크기를 유지할 수 있음.\n(크기를 따로 전달할 필요 없음.) 경계 인덱스(배열의 끝)에서 안전한 연산 가능 일부 연산(함수)이 미리 구현되어 있음 자세한 설명와 예시 코드는 기본적인 사용법을 확인한 다음인 2. 이점에서 계속하겠다.\n1. 사용 array는 타입 정의를 제외하고는 배열과 완전히 똑같이 사용할 수 있다. 두드러지는 차이점은 템플릿을 이용한다는 것과 사이즈를 기억하고 있다는 것이다. 템플릿 문법을 사용해서 타입과 생성할 크기를 명시해야 한다. 이 때 명시한 크기를 size() 함수에서 다시 얻을 수 있다.\n#include #include using namespace std; int main() { array\u003cint, 10\u003e arr; for (int i = 0; i \u003c arr.size(); i++) { arr[i] = i+1;\t// 0 1 2 3 4 5 6 7 8 9 } arr[4] = 55; for (auto\u0026 v : arr) { cout \u003c\u003c v \u003c\u003c ' '; } cout \u003c\u003c endl; } 1 2 3 4 55 6 7 8 9 10 생성 List-initialization으로 원소들을 초기화 할 수 있다. 배열의 크기는 생략할 수 없다. 별도로 작성된 생성자가 없다. 기본 생성자와 = 연산자를 사용하는 것으로 보인다.\narray\u003cint, 5\u003e arr1;\t// 쓰레기 값 array\u003cint, 5\u003e arr2 = { 0 };\t// 0 0 0 0 0 array\u003cint, 5\u003e arr3 = { 1,2,3,4,5 };\t// 1 2 3 4 5 array\u003cint, 5\u003e arr4 = { 1,2 };\t// 1 2 0 0 0 array\u003cint, 5\u003e arr5{ 1 };\t// 1 0 0 0 0 array\u003cint, 5\u003e arr6{ 1,2,3,4,5 };\t// 1 2 3 4 5 array\u003cint, 5\u003e arr7({ 1,2,3,4,5 });\t// 1 2 3 4 5 array\u003cint, 5\u003e arr8(arr7);\t// 1 2 3 4 5 // array arr9={ 1,2,3 };\t//Error 이터레이터 begin(), end()로 얻을 수 있는 array iterator는 이터레이터의 모든 연산을 지원한다. 접근 배열처럼 []연산자를 이용해 원하는 인덱스에 직접 접근할 수 있다. 동일한 함수로 .at()을 사용할 수 있다. 만약 지정해줬던 밖의 인덱스를 접근하고자 했을 때에는 예외를 발생시켜 프로그램을 중단한다.\narray\u003cint, 5\u003e arr{ 1,2,3,4,5 }; cout \u003c\u003c arr[1] \u003c\u003c endl;\t// 2 arr[3] = 7;\t// 4 -\u003e 7 cout \u003c\u003c arr.at(3) \u003c\u003c endl;\t// 7 arr.at(0) = 99;\t// 1 -\u003e 99 // ERROR!! // cout \u003c\u003c arr.at(10) \u003c\u003c endl; // cout \u003c\u003c arr[10] \u003c\u003c endl; front()와 back()을 이용해 첫 번쨰 원소와 마지막 원소의 레퍼런스를 얻을 수도 있다. (이터레이터 begin/end와 헷갈리지 말자) data()를 이용해서 _Elems의 포인터를 직접 얻을 수도 있지만, 이 방법을 추천하지는 않는다.\n// .front() == arr[0] // .back() == arr[arr.size()-1] cout \u003c\u003c arr.front() \u003c\u003c \", \" \u003c\u003c arr.back() \u003c\u003c endl;\t// 99, 5 // data() int* p = arr.data(); for (int i = 0; i \u003c arr.size(); i++) cout \u003c\u003c p[i] \u003c\u003c ' ';\t// 99 2 3 7 5 용량 size() 이용해 배열의 크기를 확인할 수 있다. size 값은 template의 상수를 이용한다. 컨테이너의 인터페이스 일관성을 위해 max_size()도 구현이 되어있는 것 같은데 이는 size()와 같다.\narray\u003cint, 5\u003e arr{ 1,2,3,4,5 }; cout \u003c\u003c arr.size() \u003c\u003c endl;\t// 5 cout \u003c\u003c arr.max_size() \u003c\u003c endl;\t// 5 array는 size를 저장하는 변수를 따로 만들지 않는데, 그래서 일반적인 배열을 만들 때와 같은 크기만큼만 사용한다.\n// size 내부 구현 예시 template\u003cclass Ty, size_t N\u003e class array { ... size_t size() { return N; } }; empty() 함수를 이용해 크기가 0인 배열인지 확인할 수 있지만, 정적 배열에서 크기가 0인 배열을 생성할 일은 잘 없다.\narray\u003cint, 5\u003e arr{ 1,2,3,4,5 }; array\u003cint, 0\u003e zero; cout \u003c\u003c arr.empty() \u003c\u003c endl;\t// false cout \u003c\u003c zero.empty() \u003c\u003c endl;\t// true 수정 수정 연산은 컨테이너에 추가적인 원소를 삽입하거나 삭제하는 연산인데, array는 정적 메모리이기 때문에 이러한 연산을 지원하지 않는다. 기타 array는 원소들을 단일한 값으로 채울 수 있도록 fill() 함수를 제공한다. 내부적으로는 C언어 라이브러리의 memset()을 호출하는 것으로 보인다.\narray\u003cint, 3\u003e arr2;\t// 쓰레기 값이 들어가 있다. arr2.fill(100);\t// 100 100 100 2. 이점 1. 함수를 통해 배열을 주고 받을 때, 배열의 크기를 유지 함수에 배열을 넘겨주고자 할 때, 기존 배열을 이용하면 배열이 포인터로 붕괴되기 떄문에 배열의 원소의 개수를 반드시 같이 넘겨줘야 했다. 이는 해당 함수를 사용하기 번거롭게 만들고, 실수를 유발할 가능성이 존재한다. 그에 반에 array 컨테이너의 레퍼런스를 넘겨주면, size()를 사용할 수 있기 때문에 이러한 문제를 해결할 수 있다. 단, 해당 함수를 템플릿 함수로 작성해야 한다는 번거로움이 있다.\n#include #include using namespace std; // 기존 기본 배열을 이용하는 sum int sum(int* arr, size_t size) { int result = 0; for (int i = 0; i \u003c size; i++) { result += arr[i]; } return result; } // array 컨테이너를 이용하는 sum template\u003ctypename Ty, size_t N\u003e int sum(array\u003cTy, N\u003e\u0026 arr) { int result = 0; for (auto\u0026 v : arr) { result += v; } return result; } int main() { constexpr int SIZE = 5; int arr1[SIZE] = { 1,2,3,4,5 }; array\u003cint, SIZE\u003e arr2 = { 1,2,3,4,5 }; // 배열에서 정상적인 사용 cout \u003c\u003c sum(arr1, sizeof(arr1) / sizeof(int)) \u003c\u003c endl; cout \u003c\u003c sum(arr1, SIZE) \u003c\u003c endl; cout \u003c\u003c sum(arr1, 5) \u003c\u003c endl; cout \u003c\u003c sum(arr1, 6) \u003c\u003c endl;\t// 실수하는 경우 // array 컨테이너 이용 cout \u003c\u003c sum(arr2) \u003c\u003c endl; } 15 15 15 -858993445 (알 수 없음) 15 2. 경계 인덱스(배열의 끝)에서 안전한 연산 가능 기존 배열/포인터를 사용하는 경우, 배열의 범위를 넘어가는 포인터 연산에 대해서도 상관없이 작동했다. 이를 의도한 것이 아니라면 예상하지 못한 결과가 나오거나, 프로그램 자체가 잘못될 수도 있는데, array는 범위를 넘어가는 연산에 대해서 debug Assertion을 수행한다. 따라서, 디버깅 모드에서 인덱스에 대한 실수를 바로잡을 수 있다.\nint arr1[] = { 1,2,3,4,5 }; array\u003cint, 5\u003e arr2{ 1,2,3,4,5 }; arr1[6];\t// 실행됨 // 중단됨. //cout \u003c\u003c arr2[6] \u003c\u003c endl; //auto iter = arr2.begin() + 7; 3. 일부 연산(함수)이 미리 구현되어 있음 fill()이나, 배열 자체끼리의 비교, 배열 전체 복사 등에서 컨테이너에서 미리 구현된 연산이 존재하기 떄문에 이런 연산을 직접 구현해야 하는 배열에 비해 array를 쓰는 것이 좋을 수 있다. 비어있는 배열 msvc++의 std는 array과 array를 따로 정의 한다. 즉, 크기가 0인 array는 다른 타입으로 새로 만들었다. 따라서, 빈 배열에 대한 오류처리를 함수를 오버로드해서 따로 처리할 수 있다. 이 경우 메인과 오류 처리에 대해서 분리되어 있기 때문에 가독성이 오를 여지가 있다. (계속 말하지만, 크기가 0인 배열을 쓸 일이 있을지는 모르겠다.)\n일반적인 경우 template\u003ctypename Ty, size_t N\u003e void func(array\u003cTy, N\u003e arr) { // ... if (arr.empty()) { // 비어있는 경우이 대한 액션을 취한다. } // main code } 오버로딩을 활용한 경우 template\u003ctypename Ty, size_t N\u003e void func(array\u003cTy, N\u003e arr) { // main code } template\u003ctypename Ty\u003e void func(array\u003cTy, 0\u003e arr) { // 비어있는 경우이 대한 액션을 취한다. } ","wordCount":"1095","inLanguage":"ko","datePublished":"2023-08-23T00:47:13+09:00","dateModified":"2023-08-23T00:47:13+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/array/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>7. array: 정적 배열 컨테이너</h1><div class=post-meta>&lt;span title='2023-08-23 00:47:13 +0900 +0900'>8월 23, 2023&lt;/span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ec%82%ac%ec%9a%a9 aria-label="1. 사용">1. 사용</a><ul><li><a href=#%ec%83%9d%ec%84%b1 aria-label=생성>생성</a></li><li><a href=#%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0 aria-label=이터레이터>이터레이터</a></li><li><a href=#%ec%a0%91%ea%b7%bc aria-label=접근>접근</a></li><li><a href=#%ec%9a%a9%eb%9f%89 aria-label=용량>용량</a></li><li><a href=#%ec%88%98%ec%a0%95 aria-label=수정>수정</a></li><li><a href=#%ea%b8%b0%ed%83%80 aria-label=기타>기타</a></li></ul></li><li><a href=#2-%ec%9d%b4%ec%a0%90 aria-label="2. 이점">2. 이점</a><ul><li><a href=#1-%ed%95%a8%ec%88%98%eb%a5%bc-%ed%86%b5%ed%95%b4-%eb%b0%b0%ec%97%b4%ec%9d%84-%ec%a3%bc%ea%b3%a0-%eb%b0%9b%ec%9d%84-%eb%95%8c-%eb%b0%b0%ec%97%b4%ec%9d%98-%ed%81%ac%ea%b8%b0%eb%a5%bc-%ec%9c%a0%ec%a7%80 aria-label="1. 함수를 통해 배열을 주고 받을 때, 배열의 크기를 유지">1. 함수를 통해 배열을 주고 받을 때, 배열의 크기를 유지</a></li><li><a href=#2-%ea%b2%bd%ea%b3%84-%ec%9d%b8%eb%8d%b1%ec%8a%a4%eb%b0%b0%ec%97%b4%ec%9d%98-%eb%81%9d%ec%97%90%ec%84%9c-%ec%95%88%ec%a0%84%ed%95%9c-%ec%97%b0%ec%82%b0-%ea%b0%80%eb%8a%a5 aria-label="2. 경계 인덱스(배열의 끝)에서 안전한 연산 가능">2. 경계 인덱스(배열의 끝)에서 안전한 연산 가능</a></li><li><a href=#3-%ec%9d%bc%eb%b6%80-%ec%97%b0%ec%82%b0%ed%95%a8%ec%88%98%ec%9d%b4-%eb%af%b8%eb%a6%ac-%ea%b5%ac%ed%98%84%eb%90%98%ec%96%b4-%ec%9e%88%ec%9d%8c aria-label="3. 일부 연산(함수)이 미리 구현되어 있음">3. 일부 연산(함수)이 미리 구현되어 있음</a></li></ul></li><li><a href=#%eb%b9%84%ec%96%b4%ec%9e%88%eb%8a%94-%eb%b0%b0%ec%97%b4 aria-label="비어있는 배열">비어있는 배열</a></li></ul></div></details></div><div class=post-content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ty</span>, std<span style=color:#f92672>::</span>size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>array</span>;
</span></span></code></pre></div><p>&nbsp;&nbsp;
<code>array</code>는 기존 정적 배열을 구현한 컨테이너이다. <code>&lt;array></code> 헤더에서 정의된다. <code>Ty</code>에는 배열의 타입이, <code>N</code>에는 정의할 크기가 들어간다. msvc++ 기준으로는 <strong><code>array</code> 컨테이너 안에 실제로 값이 저장되는 정적 배열 <code>Ty _Elems[N]</code>가 public으로 선언 되어 있다.</strong> (왜 public으로 드러나 있는지는 잘 모르겠다.)</p><p>&nbsp;&nbsp;
단순히 생각하면 기존 정적 배열 대신 <code>array</code>를 사용할만한 경우는 없어보인다. 헤더도 추가로 써야하고, 타이핑 길이도 더 길게해야하고 귀찮다. 그러나 몇 가지 이점이 있다.</p><ol><li><strong>함수를 통해 배열을 주고 받을 때, 배열의 크기를 유지할 수 있음.</strong><br>(크기를 따로 전달할 필요 없음.)</li><li><strong>경계 인덱스(배열의 끝)에서 안전한 연산 가능</strong></li><li><strong>일부 연산(함수)이 미리 구현되어 있음</strong></li></ol><p>자세한 설명와 예시 코드는 기본적인 사용법을 확인한 다음인 <a href=#2-%EC%9D%B4%EC%A0%90>2. 이점</a>에서 계속하겠다.</p><h2 id=1-사용>1. 사용<a hidden class=anchor aria-hidden=true href=#1-사용>#</a></h2><p><code>array</code>는 타입 정의를 제외하고는 배열과 완전히 똑같이 사용할 수 있다. 두드러지는 차이점은 템플릿을 이용한다는 것과 사이즈를 기억하고 있다는 것이다. 템플릿 문법을 사용해서 타입과 생성할 크기를 명시해야 한다. 이 때 명시한 크기를 <code>size()</code> 함수에서 다시 얻을 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;array&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>10</span><span style=color:#f92672>&gt;</span> arr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> arr.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		arr[i] <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;		<span style=color:#75715e>// 0 1 2 3 4 5 6 7 8 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	arr[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>55</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : arr) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> v <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>1 2 3 4 55 6 7 8 9 10
</code></pre><br><h3 id=생성>생성<a hidden class=anchor aria-hidden=true href=#생성>#</a></h3><p>List-initialization으로 원소들을 초기화 할 수 있다. <strong>배열의 크기는 생략할 수 없다.</strong> 별도로 작성된 생성자가 없다. 기본 생성자와 = 연산자를 사용하는 것으로 보인다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr1;						<span style=color:#75715e>// 쓰레기 값
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr2 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span> };				<span style=color:#75715e>// 0 0 0 0 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr3 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };		<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr4 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span> };			<span style=color:#75715e>// 1 2 0 0 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr5{ <span style=color:#ae81ff>1</span> };				<span style=color:#75715e>// 1 0 0 0 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr6{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };		<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr7({ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> });		<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr8(arr7);				<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// array&lt;int, &gt; arr9={ 1,2,3 };			//Error
</span></span></span></code></pre></div><br><h3 id=이터레이터>이터레이터<a hidden class=anchor aria-hidden=true href=#이터레이터>#</a></h3><p><code>begin()</code>, <code>end()</code>로 얻을 수 있는 array iterator는 이터레이터의 모든 연산을 지원한다.<br>&nbsp;</p><h3 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h3><p>&nbsp;&nbsp;
배열처럼 <code>[]</code>연산자를 이용해 원하는 인덱스에 직접 접근할 수 있다. 동일한 함수로 <code>.at()</code>을 사용할 수 있다. 만약 지정해줬던 밖의 인덱스를 접근하고자 했을 때에는 예외를 발생시켜 프로그램을 중단한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> arr[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>arr[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;					<span style=color:#75715e>// 4 -&gt; 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> arr.at(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>arr.at(<span style=color:#ae81ff>0</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>99</span>;				<span style=color:#75715e>// 1 -&gt; 99
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ERROR!!
</span></span></span><span style=display:flex><span><span style=color:#75715e>// cout &lt;&lt; arr.at(10) &lt;&lt; endl;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// cout &lt;&lt; arr[10] &lt;&lt; endl;
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
<code>front()</code>와 <code>back()</code>을 이용해 첫 번쨰 원소와 마지막 원소의 <strong>레퍼런스</strong>를 얻을 수도 있다. (이터레이터 begin/end와 헷갈리지 말자) <code>data()</code>를 이용해서 _Elems의 포인터를 직접 얻을 수도 있지만, 이 방법을 추천하지는 않는다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// .front() == arr[0]
</span></span></span><span style=display:flex><span><span style=color:#75715e>// .back()  == arr[arr.size()-1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> arr.front() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arr.back() <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// 99, 5 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// data()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> arr.data();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> arr.size(); i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p[i] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;	<span style=color:#75715e>// 99 2 3 7 5
</span></span></span></code></pre></div><br><h3 id=용량>용량<a hidden class=anchor aria-hidden=true href=#용량>#</a></h3><p>&nbsp;&nbsp;
<code>size()</code> 이용해 배열의 크기를 확인할 수 있다. size 값은 template의 상수를 이용한다. 컨테이너의 인터페이스 일관성을 위해 <code>max_size()</code>도 구현이 되어있는 것 같은데 이는 <code>size()</code>와 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> arr.size() <span style=color:#f92672>&lt;&lt;</span> endl;			<span style=color:#75715e>// 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> arr.max_size() <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 5
</span></span></span></code></pre></div><p><code>array</code>는 size를 저장하는 변수를 따로 만들지 않는데, 그래서 일반적인 배열을 만들 때와 같은 크기만큼만 사용한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// size 내부 구현 예시
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ty</span>, size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>array</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    size_t size() { <span style=color:#66d9ef>return</span> N; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><code>empty()</code> 함수를 이용해 크기가 0인 배열인지 확인할 수 있지만, 정적 배열에서 크기가 0인 배열을 생성할 일은 잘 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span> zero;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> arr.empty() <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> zero.empty() <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// true
</span></span></span></code></pre></div><br><h3 id=수정>수정<a hidden class=anchor aria-hidden=true href=#수정>#</a></h3><p>&nbsp;&nbsp;
수정 연산은 컨테이너에 추가적인 원소를 삽입하거나 삭제하는 연산인데, <code>array</code>는 정적 메모리이기 때문에 이러한 연산을 지원하지 않는다.<br>&nbsp;</p><h3 id=기타>기타<a hidden class=anchor aria-hidden=true href=#기타>#</a></h3><p><code>array</code>는 원소들을 단일한 값으로 채울 수 있도록 <code>fill()</code> 함수를 제공한다. 내부적으로는 C언어 라이브러리의 <code>memset()</code>을 호출하는 것으로 보인다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>3</span><span style=color:#f92672>&gt;</span> arr2;	<span style=color:#75715e>// 쓰레기 값이 들어가 있다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>arr2.fill(<span style=color:#ae81ff>100</span>);		<span style=color:#75715e>// 100 100 100 
</span></span></span></code></pre></div><p><br>&nbsp;</p><h2 id=2-이점>2. 이점<a hidden class=anchor aria-hidden=true href=#2-이점>#</a></h2><h3 id=1-함수를-통해-배열을-주고-받을-때-배열의-크기를-유지>1. 함수를 통해 배열을 주고 받을 때, 배열의 크기를 유지<a hidden class=anchor aria-hidden=true href=#1-함수를-통해-배열을-주고-받을-때-배열의-크기를-유지>#</a></h3><p>&nbsp;&nbsp;
함수에 배열을 넘겨주고자 할 때, 기존 배열을 이용하면 배열이 포인터로 붕괴되기 떄문에 배열의 원소의 개수를 반드시 같이 넘겨줘야 했다. 이는 해당 함수를 사용하기 번거롭게 만들고, 실수를 유발할 가능성이 존재한다. 그에 반에 <code>array</code> 컨테이너의 레퍼런스를 넘겨주면, size()를 사용할 수 있기 때문에 이러한 문제를 해결할 수 있다. 단, 해당 함수를 템플릿 함수로 작성해야 한다는 번거로움이 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;array&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 기존 기본 배열을 이용하는 sum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> arr, size_t size) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		result <span style=color:#f92672>+=</span> arr[i];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// array 컨테이너를 이용하는 sum
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Ty, size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> sum(array<span style=color:#f92672>&lt;</span>Ty, N<span style=color:#f92672>&gt;&amp;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : arr) {
</span></span><span style=display:flex><span>		result <span style=color:#f92672>+=</span> v;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> arr1[SIZE] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>	array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, SIZE<span style=color:#f92672>&gt;</span> arr2 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 배열에서 정상적인 사용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> sum(arr1, <span style=color:#66d9ef>sizeof</span>(arr1) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>)) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> sum(arr1, SIZE) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> sum(arr1, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> sum(arr1, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 실수하는 경우
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// array 컨테이너 이용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	cout <span style=color:#f92672>&lt;&lt;</span> sum(arr2) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>15
15
15
-858993445 (알 수 없음)
15
</code></pre><br><h3 id=2-경계-인덱스배열의-끝에서-안전한-연산-가능>2. 경계 인덱스(배열의 끝)에서 안전한 연산 가능<a hidden class=anchor aria-hidden=true href=#2-경계-인덱스배열의-끝에서-안전한-연산-가능>#</a></h3><p>&nbsp;&nbsp;
기존 배열/포인터를 사용하는 경우, 배열의 범위를 넘어가는 포인터 연산에 대해서도 상관없이 작동했다. 이를 의도한 것이 아니라면 예상하지 못한 결과가 나오거나, 프로그램 자체가 잘못될 수도 있는데, <code>array</code>는 범위를 넘어가는 연산에 대해서 debug Assertion을 수행한다. 따라서, 디버깅 모드에서 인덱스에 대한 실수를 바로잡을 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>int</span> arr1[] <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span><span style=color:#f92672>&gt;</span> arr2{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>arr1[<span style=color:#ae81ff>6</span>];	<span style=color:#75715e>// 실행됨
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 중단됨.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//cout &lt;&lt; arr2[6] &lt;&lt; endl;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//auto iter = arr2.begin() + 7;
</span></span></span></code></pre></div><br><h3 id=3-일부-연산함수이-미리-구현되어-있음>3. 일부 연산(함수)이 미리 구현되어 있음<a hidden class=anchor aria-hidden=true href=#3-일부-연산함수이-미리-구현되어-있음>#</a></h3><p>&nbsp;&nbsp;
<code>fill()</code>이나, 배열 자체끼리의 비교, 배열 전체 복사 등에서 컨테이너에서 미리 구현된 연산이 존재하기 떄문에 이런 연산을 직접 구현해야 하는 배열에 비해 <code>array</code>를 쓰는 것이 좋을 수 있다.<br>&nbsp;</p><h2 id=비어있는-배열>비어있는 배열<a hidden class=anchor aria-hidden=true href=#비어있는-배열>#</a></h2><p>&nbsp;&nbsp;
msvc++의 std는 <code>array&lt;Ty,N></code>과 <code>array&lt;Ty, 0></code>를 따로 정의 한다. 즉, 크기가 0인 <code>array</code>는 다른 타입으로 새로 만들었다. 따라서, 빈 배열에 대한 오류처리를 함수를 오버로드해서 따로 처리할 수 있다. 이 경우 메인과 오류 처리에 대해서 분리되어 있기 때문에 가독성이 오를 여지가 있다. (계속 말하지만, 크기가 0인 배열을 쓸 일이 있을지는 모르겠다.)</p><ul><li>일반적인 경우</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Ty, size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func(array<span style=color:#f92672>&lt;</span>Ty, N<span style=color:#f92672>&gt;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (arr.empty()) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 비어있는 경우이 대한 액션을 취한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// main code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li>오버로딩을 활용한 경우</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Ty, size_t N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func(array<span style=color:#f92672>&lt;</span>Ty, N<span style=color:#f92672>&gt;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// main code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Ty<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func(array<span style=color:#f92672>&lt;</span>Ty, <span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span> arr) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 비어있는 경우이 대한 액션을 취한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/vector/><span class=title>« 이전 페이지</span><br><span>8. vector: 가변 길이 배열 컨테이너</span>
</a><a class=next href=https://green-21.github.io/posts/cppstdlib/iterator/><span class=title>다음 페이지 »</span><br><span>6. Iterators - 접근 인터페이스</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>