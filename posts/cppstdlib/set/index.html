<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>14. 집합 컨테이너 - set, multiset | gReen</title><meta name=keywords content="cpp"><meta name=description content="집합을 위한 컨테이너 set과 중복을 포함하는 multiset에 대한 정리"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/set/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/set/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="14. 집합 컨테이너 - set, multiset"><meta property="og:description" content="집합을 위한 컨테이너 set과 중복을 포함하는 multiset에 대한 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/set/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-29T13:51:37+09:00"><meta property="article:modified_time" content="2023-08-29T13:51:37+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="14. 집합 컨테이너 - set, multiset"><meta name=twitter:description content="집합을 위한 컨테이너 set과 중복을 포함하는 multiset에 대한 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"14. 집합 컨테이너 - set, multiset","item":"https://green-21.github.io/posts/cppstdlib/set/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"14. 집합 컨테이너 - set, multiset","name":"14. 집합 컨테이너 - set, multiset","description":"집합을 위한 컨테이너 set과 중복을 포함하는 multiset에 대한 정리","keywords":["cpp"],"articleBody":"template\u003c class Key, class Compare = std::less\u003cKey\u003e, class Allocator = std::allocator\u003cKey\u003e \u003e class set; set은 집합을 구현한 컨테이너이다. 헤더에서 구현한다. 내부적으로 이진 탐색 트리를 이용해 대부분의 연산은 O(lgN)이다.\n1. 사용 set은 중복값 제거, 두 데이터간 일치하는 데이터 찾기, 특정 요소 탐색 등에 주로 사용된다. 탐색 트리로 정렬된 순서를 보장하기 때문에 관련 연산에서도 사용할 수 있다. 또, 균형 트리를 사용하기 때문에 이진 트리와 관련된 연산을 사용하고자 할 때 사용하기도 한다.\n생성 다양한 방법을 이용해 생성 가능하다. 빈 컨테이너를 생성하거나, 미리 요소가 추가된 컨테이너를 생성할 수 있다. 각 생성자들은 Allocator를 추가적으로 받을 수 있다. 모든 삽입 연산은 O(lgN)이기 때문에 N개의 요소를 동시에 생성하는 생성자는 O(NlgN)의 실행시간을 갖는다.\n기본 생성자 initializer_list를 전달하는 생성자 시작과 끝의 이터레이터를 전달하는 생성자 복사 생성자 이동 생성자 // 1.\t기본 생성자 //\t아무것도 할당되지 않은 상태로 초기화. set\u003cint\u003e s1; // 2.\tinitializer_list set\u003cint\u003e s2 = { 1,2,3,4,5 };\t// 1 2 3 4 5 set\u003cint\u003e s2_2{ 1,2,3,4,5 }; set\u003cint\u003e s2_3({ 1,2,3,4,5 }); // 3.\titerator set\u003cint\u003e s3(s2.begin(), s2.end());\t// 1 2 3 4 5; // 4.\tcopy set\u003cint\u003e s4(s3);\t// 1 2 3 4 5 // 5. move set\u003cint\u003e s5(move(s4));\t// 1 2 3 4 5 추가적으로 compare 함수를 전달할 수 있다. compare는 컨테이너가 내부에서 요소간 비교를 수행할 때, 그 연산을 수행하는 함수이다. 이는 삽입, 검색 등 다양한 곳에 이용된다. comp를 전달하지 않은 set은 기본적으로 오름차순 관계를 갖는다. std에서는 기본적인 compare 함수를 제공하는데, 오름차순으로 정렬되는 std::less()와 내림차순으로 정렬되는 std::greater()가 있다. compare를 전달하지 않으면 기본적으로 std::less\u003c\u003e가 전달된다.\n// 6.\tcomp 전달 //\t내림차순으로 정렬됨. set\u003cint\u003e s6(greater\u003cint\u003e()); set\u003cint, greater\u003cint\u003e\u003e s6_2; // 7.\tcomp with initializer_list set\u003cint, greater\u003cint\u003e\u003e s7({ 1,2,3,4,5 });\t// 5 4 3 2 1 // 8.\titerator set\u003cint, greater\u003cint\u003e\u003e s8(s7.begin(), s7.end());\t// 5 4 3 2 1 // 9.\tcopy set\u003cint, greater\u003cint\u003e\u003e s9(s7);\t// 5 4 3 2 1 // 10. move set\u003cint, greater\u003cint\u003e\u003e s10(move(s9));\t// 5 4 3 2 1 greater와 less는 괄호 연산자가 로버로딩된 구조체이다. 필요에 따라서 직접 정의할 수도 있다.\ntemplate \u003cclass _Ty = void\u003e struct Greater { bool operator()(_Ty\u0026 _Left, _Ty\u0026 _Right) { return _Left \u003e _Right; } }; template \u003cclass _Ty = void\u003e struct Less { bool operator()(_Ty\u0026 _Left, _Ty\u0026 _Right) { return _Left \u003c _Right; } }; 이를 구조체가 아닌 일반 함수로 만들어 사용할 수도 있다.\ntemplate\u003ctypename Ty\u003e bool greaterFunc(Ty\u0026 left, Ty\u0026 right) { return left \u003e right; } // 템플릿을 사용하지 않는 경우 bool lessIntFunc(int\u0026 left, int\u0026 right) { return left \u003c right; } 접근 집합 요소에 접근하겠다는 소리는 트리에서 특정한 값을 검색하겠다는 소리이다. 따라서, O(1)으로 요소에 접근할 수 있는 직접적인 연산은 지원하지 않는다. 요소에 직접 접근하기 위해서는 이터레이터를 이용하거나, 조회 연산을 이용해야 한다.\n이터레이터 역참조로 얻을 수 있는 참조값 (*iter)를 읽을 수는 있지만, 수정할 수는 없다. 그 외에 ++, – 정도의 연산을 지원한다. 이터레이터는 트리를 inorder로 순회하는 관계를 갖기 때문에 이터레이터를 순회하면 정렬된 순서가 보장된다.\n용량 size - 현재 보관 중인 요소의 개수 max_size - 저장 가능한 최대 요소의 개수 (컴퓨터의 전체 가용 메모리) empty - 요소가 비어있는지 확인한다. set\u003cint\u003e s{ 1,2,3,4,5 }; s.size();\t// 5 s.empty();\t// false s.max_size();\t// 메모리의 총량 수정 insert()와 emplace()로 요소를 삽입하고, erase()로 요소를 삭제한다. comp와 트리의 구조에 따라 요소의 위치가 결정되기 때문에 삽입 위치를 직접 설정할 수 없다. 모든 삽입과 삭제는 O(lgN)으로 일어난다.\nset\u003cint\u003e s{ 3,8,11 }; s.insert(5);\t// 3 5 8 11 s.emplace(6);\t// 3 5 6 8 11 s.emplace(3);\t// 이미 존재하기 때문에 아무 일도 일어나지 않는다. s.erase(3);\t// 5 6 8 11 s.erase(3);\t// 3은 존재하지 않기 때문에 아무 일도 일어나지 않는다. merge()를 이용해서 두 set을 하나로 합칠 수 있다. 매개변수로 들어오는 set은 복사가 아니라 이동된다. clear()함수로 컨테이너를 비울 수 있다.\nset\u003cint\u003e s1{ 1,3,5,7 }; set\u003cint\u003e s2{ 2,4,6,8 }; s1.merge(s2);\t// 1 2 3 4 5 6 7 8 s1.clear();\t// empty extract는 set에서 요소를 제거하면서 제거된 요소의 tree_node를 반환한다. 반환된 node에는 요소의 값은 물론 기존 연결되어 있었던 부모, 자식에게도 접근할 수 있다.\n// 4 // 2 5 // 1 3 set\u003cint\u003e s{ 1,2,3,4,5 }; auto v1 = s.extract(1);\t// node_handle auto v2 = v1._Getptr()-\u003e_Parent;\t// value_type cout \u003c\u003c v1.value() \u003c\u003c endl;\t// 1 cout \u003c\u003c v2-\u003e_Left-\u003e_Myval \u003c\u003c endl;\t// 1이 tree에서 삭제되어 쓰레기 값 출력 cout \u003c\u003c v2-\u003e_Right-\u003e_Myval \u003c\u003c endl;\t// 3 조회 set의 핵심 기능은 값의 존재 여부를 검색하고, 중복을 제거하는 것이다. 이러한 연산을 조회(Lookup)이라고 한다. 이중 equal_range는 set보다는 multiset을 위한 연산이라고 생각하는게 좋다.\ncount(v) - 보관된 v의 개수를 반환한다. find(v) - v가 존재하면 v의 이터레이터를, 아니면 past-the-end 이터레이터를 반환한다. contains(v) - v가 존재하면 true를 반환한다. equal_range(v) - v값이 존재하는 범위를 이터레이터 2개로 반환한다. lower_bound(v) - v 값이나 없다면 v에 가장 가까운 오른쪽 값을 반환한다. upper_bound(v) - v과 가장 가까운 오른쪽 값을 반환한다. lower_bound()와 upper_bound()는 past-the-end를 반환할 수 있다는 점에서 항상 주의해야 한다. 오름차순을 기준으로 lower_bound는 v가 존재하면 v를 아니면 v보다 큰 수 중 가장 작은 수를 반환한다. upper_bound는 항상 v보다 크면서 가장 작은 수를 반환한다.\nset\u003cint\u003e s{ 1,2,3, 3,7,9 }; cout \u003c\u003c s.count(3) \u003c\u003c endl;\t// 1 auto iter = s.find(3); for (auto iter = s.find(3); iter != s.end(); iter++) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 3 7 9 } cout \u003c\u003c endl; if (s.find(5) == s.end()) { cout \u003c\u003c \"5은 존재하지 않음.\" \u003c\u003c endl; } cout \u003c\u003c (s.contains(1)) \u003c\u003c endl;\t// 1 cout \u003c\u003c (s.contains(5)) \u003c\u003c endl;\t// 0 auto [begin, end] = s.equal_range(3);\t// 3~7 for (auto iter = begin; iter != end; iter++) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 3 } cout \u003c\u003c endl \u003c\u003c endl; cout \u003c\u003c \"i\\tlower\\tupper\" \u003c\u003c endl; for (int i = 0; i \u003c= 10; i++) { cout \u003c\u003c i \u003c\u003c '\\t'; auto lower = s.lower_bound(i); if (lower == s.end()) { cout \u003c\u003c \"end\\t\"; } else { cout \u003c\u003c *lower \u003c\u003c '\\t'; } auto upper = s.upper_bound(i); if (upper == s.end()) { cout \u003c\u003c \"end\" \u003c\u003c endl; } else { cout \u003c\u003c *upper \u003c\u003c endl; } } 1 3 7 9 5은 존재하지 않음. 1 0 3 i lower upper 0 1 1 1 1 2 2 2 3 3 3 7 4 7 7 5 7 7 6 7 7 7 7 9 8 9 9 9 9 end 10 end end 2. multiset multiset은 중복을 포함한다는 점을 제외 하고는 set과 동일하다. 그러나, 그 차이 하나로 여러 연산에서 다른 결과를 볼 수 있다. multiset은 헤더에 구현되어 있다.\n우선 count()를 더 의미있게 사용할 수 있다. set에서는 0아니면 1이었기 때문에 find나 contains를 사용하는 것과 다를게 없었지만, multiset에서는 같은 요소가 여러 번 저장될 수 있기 때문에 보관된 요소의 수를 출력한다. equal_range()역시 set에 비해서 의미있게 사용할 수 있다. 해당 메서드를 사용해서 중복되는 모든 요소의 이터레이터를 얻을 수 있다.\nmultiset\u003cint\u003e ms{ 1,2,2,2,3,3 };\t// 1 2 2 2 3 3 ms.count(1);\t// 2 auto [begin, end] = ms.equal_range(2);\t// 1번 iter ~ 4번 iter for (auto iter = begin; iter != end; iter++) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 2 2 2 } find()의 경우에는 가장 왼쪽에 있는 요소의 이터레이터를 반환한다. lower_bound와 upper_bound 역시 연산을 만족하는 가장 왼편의 값을 반환한다.\nfor (auto iter = ms.find(2); iter != ms.end(); iter++) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 2 2 2 3 3 } cout \u003c\u003c endl; // 가장 왼편의 2를 선택함 for (auto iter = ms.lower_bound(2); iter != ms.end(); iter++) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 2 2 2 3 3 } cout \u003c\u003c endl; // 가장 왼편의 3을 선택함. for (auto iter = ms.upper_bound(2); iter != ms.end(); iter++) { cout \u003c\u003c *iter \u003c\u003c ' ';\t// 3 3 } cout \u003c\u003c endl; 2 2 2 3 3 2 2 2 3 3 3 3 ","wordCount":"1235","inLanguage":"ko","datePublished":"2023-08-29T13:51:37+09:00","dateModified":"2023-08-29T13:51:37+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/set/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>14. 집합 컨테이너 - set, multiset</h1><div class=post-meta><span title='2023-08-29 13:51:37 +0900 +0900'>8월 29, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ec%82%ac%ec%9a%a9 aria-label="1. 사용">1. 사용</a><ul><li><a href=#%ec%83%9d%ec%84%b1 aria-label=생성>생성</a></li><li><a href=#%ec%a0%91%ea%b7%bc aria-label=접근>접근</a></li><li><a href=#%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0 aria-label=이터레이터>이터레이터</a></li><li><a href=#%ec%9a%a9%eb%9f%89 aria-label=용량>용량</a></li><li><a href=#%ec%88%98%ec%a0%95 aria-label=수정>수정</a></li><li><a href=#%ec%a1%b0%ed%9a%8c aria-label=조회>조회</a></li></ul></li><li><a href=#2-multiset aria-label="2. multiset">2. multiset</a></li></ul></div></details></div><div class=post-content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Key</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Compare</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>less<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Allocator</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>set</span>;
</span></span></code></pre></div><p>&nbsp;&nbsp;
<code>set</code>은 집합을 구현한 컨테이너이다. <code>&lt;set></code> 헤더에서 구현한다. 내부적으로 이진 탐색 트리를 이용해 대부분의 연산은 O(lgN)이다.</p><h2 id=1-사용>1. 사용<a hidden class=anchor aria-hidden=true href=#1-사용>#</a></h2><p><code>set</code>은 중복값 제거, 두 데이터간 일치하는 데이터 찾기, 특정 요소 탐색 등에 주로 사용된다. 탐색 트리로 정렬된 순서를 보장하기 때문에 관련 연산에서도 사용할 수 있다. 또, 균형 트리를 사용하기 때문에 이진 트리와 관련된 연산을 사용하고자 할 때 사용하기도 한다.</p><br><h3 id=생성>생성<a hidden class=anchor aria-hidden=true href=#생성>#</a></h3><p>&nbsp;&nbsp;
다양한 방법을 이용해 생성 가능하다. 빈 컨테이너를 생성하거나, 미리 요소가 추가된 컨테이너를 생성할 수 있다. 각 생성자들은 Allocator를 추가적으로 받을 수 있다. 모든 삽입 연산은 O(lgN)이기 때문에 N개의 요소를 동시에 생성하는 생성자는 O(NlgN)의 실행시간을 갖는다.</p><ol><li>기본 생성자</li><li>initializer_list를 전달하는 생성자</li><li>시작과 끝의 이터레이터를 전달하는 생성자</li><li>복사 생성자</li><li>이동 생성자</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 1.	기본 생성자
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		아무것도 할당되지 않은 상태로 초기화.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.	initializer_list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s2 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };		<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s2_2{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s2_3({ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3.	iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s3(s2.begin(), s2.end());	<span style=color:#75715e>// 1 2 3 4 5;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4.	copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s4(s3);					<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 5. move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s5(move(s4));			<span style=color:#75715e>// 1 2 3 4 5
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
추가적으로 compare 함수를 전달할 수 있다. compare는 컨테이너가 내부에서 요소간 비교를 수행할 때, 그 연산을 수행하는 함수이다. 이는 삽입, 검색 등 다양한 곳에 이용된다. comp를 전달하지 않은 <code>set</code>은 기본적으로 오름차순 관계를 갖는다. std에서는 기본적인 compare 함수를 제공하는데, 오름차순으로 정렬되는 <code>std::less&lt;Ty>()</code>와 내림차순으로 정렬되는 <code>std::greater&lt;Ty>()</code>가 있다. compare를 전달하지 않으면 기본적으로 <code>std::less&lt;></code>가 전달된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 6.	comp 전달
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		내림차순으로 정렬됨.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s6(greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s6_2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 7.	comp with initializer_list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s7({ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> });	        <span style=color:#75715e>// 5 4 3 2 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 8.	iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s8(s7.begin(), s7.end());	<span style=color:#75715e>// 5 4 3 2 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 9.	copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s9(s7);					    <span style=color:#75715e>// 5 4 3 2 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 10. move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> s10(move(s9));			    <span style=color:#75715e>// 5 4 3 2 1
</span></span></span></code></pre></div><p><code>greater</code>와 <code>less</code>는 괄호 연산자가 로버로딩된 구조체이다. 필요에 따라서 직접 정의할 수도 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Ty</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Greater</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(_Ty<span style=color:#f92672>&amp;</span> _Left, _Ty<span style=color:#f92672>&amp;</span> _Right) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _Left <span style=color:#f92672>&gt;</span> _Right;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Ty</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Less</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(_Ty<span style=color:#f92672>&amp;</span> _Left, _Ty<span style=color:#f92672>&amp;</span> _Right) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _Left <span style=color:#f92672>&lt;</span> _Right;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>이를 구조체가 아닌 일반 함수로 만들어 사용할 수도 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Ty<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> greaterFunc(Ty<span style=color:#f92672>&amp;</span> left, Ty<span style=color:#f92672>&amp;</span> right) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> left <span style=color:#f92672>&gt;</span> right;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 템플릿을 사용하지 않는 경우
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>lessIntFunc</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> left, <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> right) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> left <span style=color:#f92672>&lt;</span> right;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><h3 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h3><p>&nbsp;&nbsp;
집합 요소에 접근하겠다는 소리는 트리에서 특정한 값을 검색하겠다는 소리이다. 따라서, O(1)으로 요소에 접근할 수 있는 직접적인 연산은 지원하지 않는다. 요소에 직접 접근하기 위해서는 이터레이터를 이용하거나, 조회 연산을 이용해야 한다.</p><br><h3 id=이터레이터>이터레이터<a hidden class=anchor aria-hidden=true href=#이터레이터>#</a></h3><p>&nbsp;&nbsp;
역참조로 얻을 수 있는 참조값 (*iter)를 읽을 수는 있지만, <strong>수정할 수는 없다.</strong> 그 외에 ++, &ndash; 정도의 연산을 지원한다. 이터레이터는 트리를 inorder로 순회하는 관계를 갖기 때문에 이터레이터를 순회하면 정렬된 순서가 보장된다.</p><br><h3 id=용량>용량<a hidden class=anchor aria-hidden=true href=#용량>#</a></h3><ul><li><code>size</code> - 현재 보관 중인 요소의 개수</li><li><code>max_size</code> - 저장 가능한 최대 요소의 개수 (컴퓨터의 전체 가용 메모리)</li><li><code>empty</code> - 요소가 비어있는지 확인한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>s.size();			<span style=color:#75715e>// 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>s.empty();			<span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>s.max_size();		<span style=color:#75715e>// 메모리의 총량
</span></span></span></code></pre></div><br><h3 id=수정>수정<a hidden class=anchor aria-hidden=true href=#수정>#</a></h3><p><code>insert()</code>와 <code>emplace()</code>로 요소를 삽입하고, <code>erase()</code>로 요소를 삭제한다. comp와 트리의 구조에 따라 요소의 위치가 결정되기 때문에 삽입 위치를 직접 설정할 수 없다. 모든 삽입과 삭제는 O(lgN)으로 일어난다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s{ <span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>8</span>,<span style=color:#ae81ff>11</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s.insert(<span style=color:#ae81ff>5</span>);	<span style=color:#75715e>// 3 5 8 11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>s.emplace(<span style=color:#ae81ff>6</span>);	<span style=color:#75715e>// 3 5 6 8 11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>s.emplace(<span style=color:#ae81ff>3</span>);	<span style=color:#75715e>// 이미 존재하기 때문에 아무 일도 일어나지 않는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>s.erase(<span style=color:#ae81ff>3</span>);		<span style=color:#75715e>// 5 6 8 11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>s.erase(<span style=color:#ae81ff>3</span>);		<span style=color:#75715e>// 3은 존재하지 않기 때문에 아무 일도 일어나지 않는다.
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
<code>merge()</code>를 이용해서 두 set을 하나로 합칠 수 있다. 매개변수로 들어오는 set은 복사가 아니라 이동된다. <code>clear()</code>함수로 컨테이너를 비울 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s1{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>7</span> };
</span></span><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s2{ <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>8</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s1.merge(s2);	<span style=color:#75715e>// 1 2 3 4 5 6 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>s1.clear();		<span style=color:#75715e>// empty
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
<code>extract</code>는 set에서 요소를 제거하면서 제거된 요소의 tree_node를 반환한다. 반환된 node에는 요소의 값은 물론 기존 연결되어 있었던 부모, 자식에게도 접근할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>//        4
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     2     5
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   1  3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> v1 <span style=color:#f92672>=</span> s.extract(<span style=color:#ae81ff>1</span>);					<span style=color:#75715e>// node_handle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> v2 <span style=color:#f92672>=</span> v1._Getptr()<span style=color:#f92672>-&gt;</span>_Parent;		<span style=color:#75715e>// value_type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> v1.value() <span style=color:#f92672>&lt;&lt;</span> endl;				<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> v2<span style=color:#f92672>-&gt;</span>_Left<span style=color:#f92672>-&gt;</span>_Myval <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 1이 tree에서 삭제되어 쓰레기 값 출력
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> v2<span style=color:#f92672>-&gt;</span>_Right<span style=color:#f92672>-&gt;</span>_Myval <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 3
</span></span></span></code></pre></div><br><h3 id=조회>조회<a hidden class=anchor aria-hidden=true href=#조회>#</a></h3><p>&nbsp;&nbsp;
set의 핵심 기능은 값의 존재 여부를 검색하고, 중복을 제거하는 것이다. 이러한 연산을 조회(Lookup)이라고 한다. 이중 <code>equal_range</code>는 <code>set</code>보다는 <code>multiset</code>을 위한 연산이라고 생각하는게 좋다.</p><ul><li><code>count(v)</code> - 보관된 v의 개수를 반환한다.</li><li><code>find(v)</code> - v가 존재하면 v의 이터레이터를, 아니면 past-the-end 이터레이터를 반환한다.</li><li><code>contains(v)</code> - v가 존재하면 true를 반환한다.</li><li><code>equal_range(v)</code> - v값이 존재하는 범위를 이터레이터 2개로 반환한다.</li><li><code>lower_bound(v)</code> - v 값이나 없다면 v에 가장 가까운 오른쪽 값을 반환한다.</li><li><code>upper_bound(v)</code> - v과 가장 가까운 오른쪽 값을 반환한다.</li></ul><p>&nbsp;&nbsp;
<code>lower_bound()</code>와 <code>upper_bound()</code>는 past-the-end를 반환할 수 있다는 점에서 항상 주의해야 한다. 오름차순을 기준으로 lower_bound는 v가 존재하면 v를 아니면 v보다 큰 수 중 가장 작은 수를 반환한다. upper_bound는 항상 v보다 크면서 가장 작은 수를 반환한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>9</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> s.count(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> s.find(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> s.find(<span style=color:#ae81ff>3</span>); iter <span style=color:#f92672>!=</span> s.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;		<span style=color:#75715e>// 3 7 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (s.find(<span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;5은 존재하지 않음.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> (s.contains(<span style=color:#ae81ff>1</span>)) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> (s.contains(<span style=color:#ae81ff>5</span>)) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> [begin, end] <span style=color:#f92672>=</span> s.equal_range(<span style=color:#ae81ff>3</span>);			<span style=color:#75715e>// 3~7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> begin; iter <span style=color:#f92672>!=</span> end; iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;		<span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>lower</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>upper&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\t&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> lower <span style=color:#f92672>=</span> s.lower_bound(i);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (lower <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;end</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>lower <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\t&#39;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> upper <span style=color:#f92672>=</span> s.upper_bound(i);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (upper <span style=color:#f92672>==</span> s.end()) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;end&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>upper <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>1
3 7 9
5은 존재하지 않음.
1
0
3

i       lower   upper
0       1       1
1       1       2
2       2       3
3       3       7
4       7       7
5       7       7
6       7       7
7       7       9
8       9       9
9       9       end
10      end     end
</code></pre><p><br>&nbsp;</p><h2 id=2-multiset>2. multiset<a hidden class=anchor aria-hidden=true href=#2-multiset>#</a></h2><p>&nbsp;&nbsp;
<code>multiset</code>은 중복을 포함한다는 점을 제외 하고는 <code>set</code>과 동일하다. 그러나, 그 차이 하나로 여러 연산에서 다른 결과를 볼 수 있다. multiset은 <code>&lt;set></code> 헤더에 구현되어 있다.</p><p>&nbsp;&nbsp;
우선 <code>count()</code>를 더 의미있게 사용할 수 있다. set에서는 0아니면 1이었기 때문에 find나 contains를 사용하는 것과 다를게 없었지만, multiset에서는 같은 요소가 여러 번 저장될 수 있기 때문에 보관된 요소의 수를 출력한다.<br>&nbsp;
<code>equal_range()</code>역시 set에 비해서 의미있게 사용할 수 있다. 해당 메서드를 사용해서 중복되는 모든 요소의 이터레이터를 얻을 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>multiset<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ms{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span> };	<span style=color:#75715e>// 1 2 2 2 3 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>ms.count(<span style=color:#ae81ff>1</span>);	<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> [begin, end] <span style=color:#f92672>=</span> ms.equal_range(<span style=color:#ae81ff>2</span>);	<span style=color:#75715e>// 1번 iter ~ 4번 iter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> begin; iter <span style=color:#f92672>!=</span> end; iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;			<span style=color:#75715e>// 2 2 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>&nbsp;&nbsp;
<code>find()</code>의 경우에는 가장 왼쪽에 있는 요소의 이터레이터를 반환한다. lower_bound와 upper_bound 역시 연산을 만족하는 가장 왼편의 값을 반환한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> ms.find(<span style=color:#ae81ff>2</span>); iter <span style=color:#f92672>!=</span> ms.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;			<span style=color:#75715e>// 2 2 2 3 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 가장 왼편의 2를 선택함
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> ms.lower_bound(<span style=color:#ae81ff>2</span>); iter <span style=color:#f92672>!=</span> ms.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;			<span style=color:#75715e>// 2 2 2 3 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 가장 왼편의 3을 선택함.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> ms.upper_bound(<span style=color:#ae81ff>2</span>); iter <span style=color:#f92672>!=</span> ms.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>iter <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;			<span style=color:#75715e>// 3 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span></code></pre></div><pre tabindex=0><code>2 2 2 3 3
2 2 2 3 3
3 3
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/map/><span class=title>« 이전 페이지</span><br><span>15. 사전형 컨테이너 - map, multimap</span></a>
<a class=next href=https://green-21.github.io/posts/cppstdlib/deque/><span class=title>다음 페이지 »</span><br><span>12. deque: 끝단에서 빠른 자료구조</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>