<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>5. Allocators - 컨테이너의 동적 할당과 해제 | gReen</title>
<meta name=keywords content="cpp"><meta name=description content="컨테이너의 메모리 할당과 해제"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/allocator/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/allocator/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="5. Allocators - 컨테이너의 동적 할당과 해제"><meta property="og:description" content="컨테이너의 메모리 할당과 해제"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/allocator/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-21T16:40:03+09:00"><meta property="article:modified_time" content="2023-08-21T16:40:03+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="5. Allocators - 컨테이너의 동적 할당과 해제"><meta name=twitter:description content="컨테이너의 메모리 할당과 해제"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"5. Allocators - 컨테이너의 동적 할당과 해제","item":"https://green-21.github.io/posts/cppstdlib/allocator/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"5. Allocators - 컨테이너의 동적 할당과 해제","name":"5. Allocators - 컨테이너의 동적 할당과 해제","description":"컨테이너의 메모리 할당과 해제","keywords":["cpp"],"articleBody":"template\u003cclass T, // 컨테이너 원소의 타입 class Allocator = std::allocator\u003cT\u003e\u003e // ????? 어떤 기본 값을 갖는다. class vector; 위와 코드는 vector컨테이너 클래스의 원형이다. 해석하면 T 는 컨테이너에 저장될 원소의 타입을 말한다. 그런데, Allocator라는 알 수 없는 녀석이 있다. 이런식으로 어떤 맥락에서 알 수 없는 요소는 개념을 이해하기 불편하고, 글을 읽기 어렵게 만든다고 생각한다. 그래서, 먼저 Allocator에 대해 간략하게 설명하고자 한다.\n1. Allocator란? array를 제외한 모든 컨테이너는 동적으로 할당/해제되는 구조를 가졌다. 동적할당을 위해서는 할당과 해제에 관련된 연산이 필요한데, Allocator는 이 할당/해제 연산을 어떻게 할 것인가를 정의한 것이다. 컨테이너는 Allocator에 따라 자신에게 필요한 메모리를 할당하고, 해제한다.\n우리는 정말 특수한 경우가 아니라면, Allocator를 직접 만들거나 신경 쓸 일은 없다. 왜냐하면, std에서는 기본적으로 사용할 수 있는 Allocator를 제공해주기 떄문이다. 위 Allocator의 기본값인 std::allocator가 바로 std에서 기본적으로 제공해주는 할당 구조체이다. std::allocator는 내부적으로 new와 delete 연산을 이용해서 할당/해제 연산을 수행한다. 따라서, 아래 내용은 생략하고 넘어가도 좋다.\n2. 별도의 Allocator 필요한 경우? 그러나, Allocator가 밖으로 드러나 있다는 것은 직접 Allocator를 만들어야할 경우가 있다는 것이다. 아마 이런 경우를 생각해볼 수 있을 것이다. (상황이 딱히 생각이 안나서 chatGPT의 도움을 일부 빌렸다.)\n어떤 레거시 코드에 이미 C-Style로 할당을 처리하는 경우 런타임에 돌아가는 가비지 콜렉터나, 직접 힙 메모리를 관리하는 경우 넉넉한 메모리를 우선 할당한 다음, 할당과 해제의 오버헤드를 줄이면서 직접 메모리를 관리해서 최적화 하거나, 별도의 GC를 직접 구현해 별도의 메모리 관리 정책이 있는 경우 이를 위한 별도의 Allocator를 작성해야할 수 있다. 기타 제약으로 인해서 allocator를 사용할 수 없을 때. 하드웨어 제약이나, 별도의 외부 메모리를 사용하고 이에 대한 로직이 따로 있는 경우 기본 allocator를 사용할 수 없기 때문에 어쩔 수 없이 Allocator를 만들어야 하는 경우가 있을 수 있다. 3. Allocator 정의 Allocator는 다음 4가지 연산 및 메서드를 반드시 구현해야 한다.\nT를 내부에서 value_type로 다시 타입 정의 할 것 operator==, operator!= 필수 연산이라고 되어있었지만, 단순한 vector 삽입 삭제에는 구현하지 않아도 문제 없었음. allocator() deallocator() 복사 생성자 (변환을 위한) MS 문서에는 필수라고 되어있지 않지만, 없는 경우 컴파일 에러 발생 MS 공식 문서에서 제공하는 C스타일 형식 Allocator 예제를 약간만 수정했다.\nMallocator.h // C-style Allocator // https://learn.microsoft.com/en-us/cpp/standard-library/allocators?view=msvc-170#writing-your-own-allocator-c11 #pragma once #include //size_t, malloc, free #include // bad_alloc, bad_array_new_length #include template \u003cclass T\u003e struct Mallocator { typedef T value_type; // value_type 정의 Mallocator() noexcept {} // 변환을 허용하는 복사생성자 template\u003cclass U\u003e Mallocator(const Mallocator\u003cU\u003e\u0026) noexcept {} T* allocate(const size_t n) const; void deallocate(T* const p, size_t) const noexcept; }; template \u003cclass T\u003e T* Mallocator\u003cT\u003e::allocate(const size_t n) const { if (n == 0) { return nullptr; } if (n \u003e static_cast\u003csize_t\u003e(-1) / sizeof(T)) { throw std::bad_array_new_length(); } void* const pv = malloc(n * sizeof(T)); if (!pv) { throw std::bad_alloc(); } return static_cast\u003cT*\u003e(pv); } template\u003cclass T\u003e void Mallocator\u003cT\u003e::deallocate(T* const p, size_t) const noexcept { free(p); } main.cpp #include #include #include\"Mallocator.h\" using namespace std; int main() { vector\u003cint, Mallocator\u003cint\u003e\u003e v1; // 삽입 중에 할당 및 재할당과 해제 과정이 존재 v1.push_back(1); v1.push_back(2); v1.push_back(3); v1.push_back(4); v1.push_back(5); for (auto\u0026 v : v1) { cout \u003c\u003c v \u003c\u003c ' '; } v1.clear(); } ","wordCount":"476","inLanguage":"ko","datePublished":"2023-08-21T16:40:03+09:00","dateModified":"2023-08-21T16:40:03+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/allocator/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>5. Allocators - 컨테이너의 동적 할당과 해제</h1><div class=post-meta><span title='2023-08-21 16:40:03 +0900 +0900'>8월 21, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-allocator%eb%9e%80 aria-label="1. Allocator란?">1. Allocator란?</a></li><li><a href=#2-%eb%b3%84%eb%8f%84%ec%9d%98-allocator-%ed%95%84%ec%9a%94%ed%95%9c-%ea%b2%bd%ec%9a%b0 aria-label="2. 별도의 Allocator 필요한 경우?">2. 별도의 Allocator 필요한 경우?</a></li><li><a href=#3-allocator-%ec%a0%95%ec%9d%98 aria-label="3. Allocator 정의">3. Allocator 정의</a></li></ul></div></details></div><div class=post-content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span>,                               <span style=color:#75715e>// 컨테이너 원소의 타입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Allocator</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>    <span style=color:#75715e>// ????? 어떤 기본 값을 갖는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>vector</span>;
</span></span></code></pre></div><p>&nbsp;&nbsp;
위와 코드는 <code>vector</code>컨테이너 클래스의 원형이다. 해석하면 T 는 컨테이너에 저장될 원소의 타입을 말한다. 그런데, Allocator라는 알 수 없는 녀석이 있다. 이런식으로 어떤 맥락에서 알 수 없는 요소는 개념을 이해하기 불편하고, 글을 읽기 어렵게 만든다고 생각한다. 그래서, 먼저 Allocator에 대해 간략하게 설명하고자 한다.</p><p><br>&nbsp;</p><h2 id=1-allocator란>1. Allocator란?<a hidden class=anchor aria-hidden=true href=#1-allocator란>#</a></h2><p>&nbsp;&nbsp;
array를 제외한 모든 컨테이너는 동적으로 할당/해제되는 구조를 가졌다. 동적할당을 위해서는 할당과 해제에 관련된 연산이 필요한데, <strong>Allocator는 이 할당/해제 연산을 어떻게 할 것인가를 정의한 것이다.</strong> 컨테이너는 Allocator에 따라 자신에게 필요한 메모리를 할당하고, 해제한다.</p><p>&nbsp;&nbsp;
우리는 정말 특수한 경우가 아니라면, <strong>Allocator를 직접 만들거나 신경 쓸 일은 없다.</strong> 왜냐하면, std에서는 기본적으로 사용할 수 있는 Allocator를 제공해주기 떄문이다. 위 Allocator의 기본값인 <code>std::allocator&lt;T></code>가 바로 std에서 기본적으로 제공해주는 할당 구조체이다. <code>std::allocator&lt;T></code>는 내부적으로 new와 delete 연산을 이용해서 할당/해제 연산을 수행한다. 따라서, <strong>아래 내용은 생략하고 넘어가도 좋다.</strong></p><br><h2 id=2-별도의-allocator-필요한-경우>2. 별도의 Allocator 필요한 경우?<a hidden class=anchor aria-hidden=true href=#2-별도의-allocator-필요한-경우>#</a></h2><p>&nbsp;&nbsp;
그러나, Allocator가 밖으로 드러나 있다는 것은 직접 Allocator를 만들어야할 경우가 있다는 것이다. 아마 이런 경우를 생각해볼 수 있을 것이다. (상황이 딱히 생각이 안나서 chatGPT의 도움을 일부 빌렸다.)</p><ol><li>어떤 레거시 코드에 이미 C-Style로 할당을 처리하는 경우</li><li>런타임에 돌아가는 가비지 콜렉터나, 직접 힙 메모리를 관리하는 경우<ul><li>넉넉한 메모리를 우선 할당한 다음, 할당과 해제의 오버헤드를 줄이면서 직접 메모리를 관리해서 최적화 하거나, 별도의 GC를 직접 구현해 별도의 메모리 관리 정책이 있는 경우 이를 위한 별도의 Allocator를 작성해야할 수 있다.</li></ul></li><li>기타 제약으로 인해서 allocator를 사용할 수 없을 때.<ul><li>하드웨어 제약이나, 별도의 외부 메모리를 사용하고 이에 대한 로직이 따로 있는 경우 기본 allocator를 사용할 수 없기 때문에 어쩔 수 없이 Allocator를 만들어야 하는 경우가 있을 수 있다.</li></ul></li></ol><br><h2 id=3-allocator-정의>3. Allocator 정의<a hidden class=anchor aria-hidden=true href=#3-allocator-정의>#</a></h2><p>&nbsp;&nbsp;
Allocator는 다음 4가지 연산 및 메서드를 반드시 구현해야 한다.</p><ol><li>T를 내부에서 <code>value_type</code>로 다시 타입 정의 할 것</li><li><code>operator==</code>, <code>operator!=</code><ul><li>필수 연산이라고 되어있었지만, 단순한 vector 삽입 삭제에는 구현하지 않아도 문제 없었음.</li></ul></li><li><code>allocator()</code></li><li><code>deallocator()</code></li><li>복사 생성자 (변환을 위한)<ul><li>MS 문서에는 필수라고 되어있지 않지만, 없는 경우 컴파일 에러 발생</li></ul></li></ol><p>MS 공식 문서에서 제공하는 C스타일 형식 Allocator 예제를 약간만 수정했다.</p><ul><li>Mallocator.h</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// C-style Allocator
</span></span></span><span style=display:flex><span><span style=color:#75715e>// https://learn.microsoft.com/en-us/cpp/standard-library/allocators?view=msvc-170#writing-your-own-allocator-c11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e> </span><span style=color:#75715e>//size_t, malloc, free
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;new&gt;</span><span style=color:#75715e> </span><span style=color:#75715e>// bad_alloc, bad_array_new_length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Mallocator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>typedef</span> T value_type;  <span style=color:#75715e>// value_type 정의
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Mallocator() <span style=color:#66d9ef>noexcept</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 변환을 허용하는 복사생성자
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>U</span><span style=color:#f92672>&gt;</span> Mallocator(<span style=color:#66d9ef>const</span> Mallocator<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;&amp;</span>) <span style=color:#66d9ef>noexcept</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#a6e22e>allocate</span>(<span style=color:#66d9ef>const</span> size_t n) <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deallocate</span>(T<span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> p, size_t) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T<span style=color:#f92672>*</span> Mallocator<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>allocate(<span style=color:#66d9ef>const</span> size_t n) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(T))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>bad_array_new_length();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> pv <span style=color:#f92672>=</span> malloc(n <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(T));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>pv) { <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>bad_alloc(); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>*&gt;</span>(pv);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Mallocator<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>deallocate(T<span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> p, size_t) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>noexcept</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    free(p);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>main.cpp</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;vector&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include&#34;Mallocator.h&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, Mallocator<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v1;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 삽입 중에 할당 및 재할당과 해제 과정이 존재
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    v1.push_back(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    v1.push_back(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    v1.push_back(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    v1.push_back(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    v1.push_back(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : v1) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> v <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    v1.clear();
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/iterator/><span class=title>« 이전 페이지</span><br><span>6. Iterators - 접근 인터페이스</span>
</a><a class=next href=https://green-21.github.io/posts/cppstdlib/pair/><span class=title>다음 페이지 »</span><br><span>3. pair: 두 타입을 묶는 구조체</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2024 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>