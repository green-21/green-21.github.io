<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2. 훑어보기 | gReen</title><meta name=keywords content="cpp"><meta name=description content="std에 대해 전반적으로 살펴본다."><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/outline/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/outline/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="2. 훑어보기"><meta property="og:description" content="std에 대해 전반적으로 살펴본다."><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/outline/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-20T22:09:49+09:00"><meta property="article:modified_time" content="2023-08-20T22:09:49+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="2. 훑어보기"><meta name=twitter:description content="std에 대해 전반적으로 살펴본다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"2. 훑어보기","item":"https://green-21.github.io/posts/cppstdlib/outline/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2. 훑어보기","name":"2. 훑어보기","description":"std에 대해 전반적으로 살펴본다.","keywords":["cpp"],"articleBody":"1. 맛보기 다음은 가장 많이 사용되는 컨테이너 vector와 vector의 이터레이터를 통한 값의 접근, 이터레이터(iterator)를 사용하는 정렬 알고리즘 sort()에 대한 간단한 예시 코드이다.\n#include #include #include using namespace std; int main() { vector\u003cint\u003e v1; // int를 보관하는 vector 컨테이너 생성 v1.push_back(3); // 컨테이너에 원소 삽입 v1.push_back(1); // 3 1 v1.push_back(9); // 3 1 9 v1.push_back(4); // 3 1 9 4 v1.push_back(5); // 3 1 9 4 5 // []연산자를 통한 원소 접근 v1[2] = 8;\t// 9 -\u003e 8 for (size_t i = 0; i \u003c v1.size(); i++) { cout \u003c\u003c v1[i] \u003c\u003c ' ';\t// 3 1 8 4 5 } cout \u003c\u003c endl; // 이터레이터를 통한 원소 접근 vector\u003cint\u003e::iterator vIter;\t// vector의 이터레이터1 vIter = v1.begin() + 3;\t// 3번째 원소를 가리키는 이터레이터 *vIter = 7;\t// 4 -\u003e 7 // v1의 시작점에서 마지막까지 순회 for (auto iter = v1.begin(); iter != v1.end(); iter++) { cout \u003c\u003c (*iter) \u003c\u003c ' ';\t// 3 1 8 7 5 } cout \u003c\u003c endl; // 정렬 알고리즘 (오름차순) sort(v1.begin(), v1.end()); // 범위 기반 for loop for (auto\u0026 v : v1) { cout \u003c\u003c v \u003c\u003c ' ';\t// 1 3 5 7 8 } return 0; } 2. Containers 컨테이너란 유명한 자료구조와 이를 처리하는 연산을 쉽게 구현할 수 있도록 미리 만들어서 제공하는 컬렉션 객체다. 컨테이너에서 제공하는 메서드와 이터레이터를 통해서 원하는 값을 삽입, 접근, 수정, 삭제할 수 있으며, 각 컨테이너 내부의 원소들은 컨테이너의 종류에 따라 다양한 방법으로 보관된다. 위 예제의 vector가 대표적인 컨테이너이다. 보관할 수 있는 데이터 타입 컨테이너는 템플릿을 사용해 자료구조에 보관될 타입을 설정할 수 있다. 일반적으로 컨테이너에 보관할 수 있는 데이터 타입은 복사가 가능한 모든 데이터 타입이다. set과 같은 일부 컨테이너는 데이터 타입의 추가적인 연산을 요구할 수 있다. 한 번 정해진 타입을 바꿀 수는 없다. 따라서, 하나의 컨테이너에 다른 여러 타입을 동시에 사용할 수는 없다.\nvector\u003cint\u003e v1; // int형 vector 컨테이너 생성 vector\u003cstring\u003e v2; // string형 vector 컨테이너 vector\u003cunique_ptr\u003cint\u003e\u003e v3; // 포인터를 저장하는 컨테이너 v1.push_back(10); // (O) int형 컨테이너에 int 값 삽입 메서드 v1.push_back(\"hello~~\"); // (X) int형 컨테이너에 string형 삽입 불가능 종류 컨테이너는 구조에 따라서 크게 3가지로 분류할 수 있으며, 그 외에 컨테이너를 활용해 추가적인 자료구조를 구현한 Adapters가 존재한다.\nSequence Container 삽입된 순서가 유지되며, 이를 순서대로(순차적으로) 접근할 수 있는 컨테이너 array - 정적 배열 (유일한 정적 컨테이너) vector - 동적 배열 deque - 이중 큐 (스택 + 큐) list - 이중 연결리스트 forward_list - 단일 연결 리스트 Associative Containers 이진 탐색 트리로 구현되어 정해진 우선순위에 의해 정렬된 상태를 유지하는 컨테이너 set - 집합 multiset - 중복을 포함하는 집합 map - 맵 (딕셔너리) multimap - 중복을 포함하는 맵 Unordered Associative Containers hash table로 구현되어 우선순위가 없지만 그 외에는 Associative 컨테이너와 같은 연산을 제공하는 컨테이너 unordered_set - 해시 집합 unordered_multiset - 해시 집합 (중복을 포함) unordered_map - 해시 맵 unordered_multimap - 해시 맵 (중복을 포함) Container Adapters 컨테이너를 활용해 구현한 추가적인 자료구조 stack - 스택 queue - 큐 priority_queue - 우선순위 큐 메서드 각 컨테이너에서 제공하는 메서드는 거의 비슷한 역할과 이름을 가졌다. 이를 살펴보고 세부적인 컨테이너 각각의 메서드를 공부하는 것이 전반적으로 이해하기 쉽다. 각 메서드는 역할에 따라 분류할 수 있는데, 특정 컨테이너에서만 존재하는 메서드를 제외하면 대략 5개 정도로 분류할 수 있다.\nIterators 컨테이너 내부 요소에 접근할 수 있는 이터레이터를 반환하는 메서드로 보통 시작과 끝의 다음 이터레이터를 반환 메서드 설명 begin() - 컨테이너의 첫 번째 이터레이터를 반환\n- cbegin()은 const형을 반환\n- rbegin()은 컨테이너의 마지막을 반환하고, 방향이 반대로 첫번째 이터레이터를 향함.\n- 둘을 합친 rcbegin() 존재 end() - 컨테이너의 마지막 원소 다음의 이터레이터를 반환\n- begin과 마찬가지로 cend() rend(), rcend() 사용 가능 Element access 원소 접근을 위한 메서드 (연산자 포함) 메서드 설명 at()\n[]연산자 (배열처럼)특정 인덱스나, 해당하는 키에 대한 원소 레퍼런스 반환 data() 원소들이 실제로 위치하는 포인터 주소 반환 (시작점) front()\nback() 첫 번째/마지막 번째 해당하는 원소의 레퍼런스 반환 Capacity 크기와 할당 용량과 관련된 메서드 메서드 설명 empty() 컨테이너가 비어있으면 true size() 저장된 원소의 수 max_size() 저장 가능한 최대 컨테이너 수 (할당 가능한 최대 heap 메모리 크기 정도) resize() 컨테이너의 size를 조절 capacity() 컨테이너에 할당된 저장 가능한 원소의 수 reserve() capacity 수 조절 Modifiers 원소 추가/삭제에 관련된 메서드 메서드 설명 clear() 컨테이너를 비운다. insert(v) (특정 위치에) 원소 v를 추가 emplace(v)\nemplace_front()\nemplace_back() (특정 위치에) 원소 v를 추가 push_front(v)\npush_back() 양 끝 위치에 원소 v를 추가 extract(x) x가 컨테이너에 존재하면 레퍼런스(node type) 반환 Lookup (association containers에서) 원소 탐색과 관련된 메서드 메서드 설명 count(x) 컨테이너에 포함된 x의 개수 find(x) x가 존재하면 x의 이터레이터 반환. 아니라면 end() 반환 contains(x) x가 존재하면 true 3. Iterators 이터레이터는 자료구조를 공통된 방법으로 접근하는 일종의 약속이다. 일반화된 포인터 오브젝트라고 생각하면 된다. 따라서, 대부분의 연산이 포인터 연산과 유사하다.\n은 자료구조를 접근하기 위해 이터레이터만을 사용한다. 이터레이터라는 공통된 자료 접근 인터페이스는 이터레이터를 구현한 모든 자료구조는 을 사용할 수 있도록 알고리즘과 자료구조간의 의존성을 제거한다. 모든 컨테이너는 이터레이터 형태의 인터페이스를 제공한다.\n4. Algorithm 은 탐색, 정렬, 카운팅과 같은 범용적으로 많이 사용하는 알고리즘들을 사용하기 쉽도록 미리 구현한 함수들을 말한다. 이터레이터를 사용해 어떤 데이터 타입이든 상관 없이 범용적으로 사용할 수 있도록 만들어졌다. 해당 함수들을 사용하면, JS나 java stream처럼 선언형으로 프로그래밍하는 느낌을 받을 수 있다. 제공되는 알고리즘 종류 원본을 수정하지 않는 순차 연산 탐색 조건 검색 카운팅 원본을 수정하는 순차 연산 복사 및 이동 채우기 회전(뒤집기) 중복 제거 자리 변경 쉬프트 변형 분할과 합치기(merge) 정렬 이진 탐색 집합 연산 힙 연산 최대/최소와 자르기 비교 순열과 조합 그 외 헤더 함수들 ","wordCount":"861","inLanguage":"ko","datePublished":"2023-08-20T22:09:49+09:00","dateModified":"2023-08-20T22:09:49+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/outline/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>2. 훑어보기</h1><div class=post-meta><span title='2023-08-20 22:09:49 +0900 +0900'>8월 20, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%eb%a7%9b%eb%b3%b4%ea%b8%b0 aria-label="1. 맛보기">1. 맛보기</a></li><li><a href=#2-containers aria-label="2. Containers">2. Containers</a><ul><li><a href=#%eb%b3%b4%ea%b4%80%ed%95%a0-%ec%88%98-%ec%9e%88%eb%8a%94-%eb%8d%b0%ec%9d%b4%ed%84%b0-%ed%83%80%ec%9e%85 aria-label="보관할 수 있는 데이터 타입">보관할 수 있는 데이터 타입</a></li><li><a href=#%ec%a2%85%eb%a5%98 aria-label=종류>종류</a></li><li><a href=#%eb%a9%94%ec%84%9c%eb%93%9c aria-label=메서드>메서드</a></li></ul></li><li><a href=#3-iterators aria-label="3. Iterators">3. Iterators</a></li><li><a href=#4-algorithm aria-label="4. Algorithm">4. Algorithm</a><ul><li><a href=#%ec%a0%9c%ea%b3%b5%eb%90%98%eb%8a%94-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%a2%85%eb%a5%98 aria-label="제공되는 알고리즘 종류">제공되는 알고리즘 종류</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=1-맛보기>1. 맛보기<a hidden class=anchor aria-hidden=true href=#1-맛보기>#</a></h2><p>&nbsp;&nbsp;
다음은 가장 많이 사용되는 컨테이너 <code>vector</code>와 vector의 이터레이터를 통한 값의 접근, 이터레이터(iterator)를 사용하는 정렬 알고리즘 <code>sort()</code>에 대한 간단한 예시 코드이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1;         <span style=color:#75715e>// int를 보관하는 vector 컨테이너 생성
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	v1.push_back(<span style=color:#ae81ff>3</span>);        <span style=color:#75715e>// 컨테이너에 원소 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v1.push_back(<span style=color:#ae81ff>1</span>);        <span style=color:#75715e>// 3 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v1.push_back(<span style=color:#ae81ff>9</span>);        <span style=color:#75715e>// 3 1 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v1.push_back(<span style=color:#ae81ff>4</span>);        <span style=color:#75715e>// 3 1 9 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v1.push_back(<span style=color:#ae81ff>5</span>);        <span style=color:#75715e>// 3 1 9 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// []연산자를 통한 원소 접근
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v1[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;						<span style=color:#75715e>// 9 -&gt; 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> v1.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> v1[i] <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;		<span style=color:#75715e>// 3 1 8 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 이터레이터를 통한 원소 접근
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>iterator vIter;	<span style=color:#75715e>// vector&lt;int&gt;의 이터레이터1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	vIter <span style=color:#f92672>=</span> v1.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>;			<span style=color:#75715e>// 3번째 원소를 가리키는 이터레이터 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>*</span>vIter <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;						<span style=color:#75715e>// 4 -&gt; 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// v1의 시작점에서 마지막까지 순회
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> v1.begin(); iter <span style=color:#f92672>!=</span> v1.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> (<span style=color:#f92672>*</span>iter) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;		<span style=color:#75715e>// 3 1 8 7 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 정렬 알고리즘 (오름차순)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	sort(v1.begin(), v1.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 범위 기반 for loop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> v : v1) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> v <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span>;			<span style=color:#75715e>// 1 3 5 7 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><br>&nbsp;</p><h2 id=2-containers>2. Containers<a hidden class=anchor aria-hidden=true href=#2-containers>#</a></h2><p>&nbsp;&nbsp;
<strong>컨테이너</strong>란 유명한 자료구조와 이를 처리하는 연산을 쉽게 구현할 수 있도록 미리 만들어서 제공하는 컬렉션 객체다. 컨테이너에서 제공하는 메서드와 이터레이터를 통해서 원하는 값을 삽입, 접근, 수정, 삭제할 수 있으며, 각 컨테이너 내부의 원소들은 컨테이너의 종류에 따라 다양한 방법으로 보관된다. 위 예제의 <code>vector</code>가 대표적인 컨테이너이다.<figure><img loading=lazy src=1.png#center width=400></figure></p><br><h3 id=보관할-수-있는-데이터-타입>보관할 수 있는 데이터 타입<a hidden class=anchor aria-hidden=true href=#보관할-수-있는-데이터-타입>#</a></h3><p>&nbsp;&nbsp;
컨테이너는 <strong>템플릿</strong>을 사용해 자료구조에 보관될 타입을 설정할 수 있다. 일반적으로 컨테이너에 보관할 수 있는 데이터 타입은 <em><strong>복사가 가능한 모든 데이터 타입</strong></em>이다. set과 같은 일부 컨테이너는 데이터 타입의 추가적인 연산을 요구할 수 있다. 한 번 정해진 타입을 바꿀 수는 없다. 따라서, 하나의 컨테이너에 다른 여러 타입을 동시에 사용할 수는 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1;             <span style=color:#75715e>// int형 vector 컨테이너 생성
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> v2;          <span style=color:#75715e>// string형 vector 컨테이너
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>unique_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v3; <span style=color:#75715e>// 포인터를 저장하는 컨테이너
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>v1.push_back(<span style=color:#ae81ff>10</span>);           <span style=color:#75715e>// (O) int형 컨테이너에 int 값 삽입 메서드
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>v1.push_back(<span style=color:#e6db74>&#34;hello~~&#34;</span>);    <span style=color:#75715e>// (X) int형 컨테이너에 string형 삽입 불가능
</span></span></span></code></pre></div><br><h3 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h3><p>&nbsp;&nbsp;
컨테이너는 구조에 따라서 크게 <strong>3가지</strong>로 분류할 수 있으며, 그 외에 컨테이너를 활용해 추가적인 자료구조를 구현한 Adapters가 존재한다.</p><ul><li><strong>Sequence Container</strong><ul><li>삽입된 순서가 유지되며, 이를 순서대로(순차적으로) 접근할 수 있는 컨테이너</li><li><code>array</code> - 정적 배열 (유일한 정적 컨테이너)</li><li><code>vector</code> - 동적 배열</li><li><code>deque</code> - 이중 큐 (스택 + 큐)</li><li><code>list</code> - 이중 연결리스트</li><li><code>forward_list</code> - 단일 연결 리스트</li></ul></li><li><strong>Associative Containers</strong><ul><li>이진 탐색 트리로 구현되어 정해진 우선순위에 의해 정렬된 상태를 유지하는 컨테이너</li><li><code>set</code> - 집합</li><li><code>multiset</code> - 중복을 포함하는 집합</li><li><code>map</code> - 맵 (딕셔너리)</li><li><code>multimap</code> - 중복을 포함하는 맵</li></ul></li><li><strong>Unordered Associative Containers</strong><ul><li>hash table로 구현되어 우선순위가 없지만 그 외에는 Associative 컨테이너와 같은 연산을 제공하는 컨테이너</li><li><code>unordered_set</code> - 해시 집합</li><li><code>unordered_multiset</code> - 해시 집합 (중복을 포함)</li><li><code>unordered_map</code> - 해시 맵</li><li><code>unordered_multimap</code> - 해시 맵 (중복을 포함)</li></ul></li><li><strong>Container Adapters</strong><ul><li>컨테이너를 활용해 구현한 추가적인 자료구조</li><li><code>stack</code> - 스택</li><li><code>queue</code> - 큐</li><li><code>priority_queue</code> - 우선순위 큐</li></ul></li></ul><br><h3 id=메서드>메서드<a hidden class=anchor aria-hidden=true href=#메서드>#</a></h3><p>&nbsp;&nbsp;
각 컨테이너에서 제공하는 메서드는 거의 비슷한 역할과 이름을 가졌다. 이를 살펴보고 세부적인 컨테이너 각각의 메서드를 공부하는 것이 전반적으로 이해하기 쉽다. 각 메서드는 역할에 따라 분류할 수 있는데, 특정 컨테이너에서만 존재하는 메서드를 제외하면 대략 5개 정도로 분류할 수 있다.</p><ul><li><strong>Iterators</strong><ul><li>컨테이너 내부 요소에 접근할 수 있는 이터레이터를 반환하는 메서드로 보통 시작과 끝의 다음 이터레이터를 반환</li></ul></li></ul><div class=table><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>begin()</code></td><td>- 컨테이너의 첫 번째 이터레이터를 반환<br>- <code>cbegin()</code>은 <code>const</code>형을 반환<br>- <code>rbegin()</code>은 컨테이너의 마지막을 반환하고, 방향이 반대로 첫번째 이터레이터를 향함.<br>- 둘을 합친 <code>rcbegin()</code> 존재</td></tr><tr><td><code>end()</code></td><td>- 컨테이너의 마지막 원소 다음의 이터레이터를 반환<br>- begin과 마찬가지로 <code>cend()</code> <code>rend()</code>, <code>rcend()</code> 사용 가능</td></tr></tbody></table></div><ul><li><strong>Element access</strong><ul><li>원소 접근을 위한 메서드 (연산자 포함)</li></ul></li></ul><div class=table><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>at()</code><br><code>[]연산자</code></td><td>(배열처럼)특정 인덱스나, 해당하는 키에 대한 원소 레퍼런스 반환</td></tr><tr><td><code>data()</code></td><td>원소들이 실제로 위치하는 포인터 주소 반환 (시작점)</td></tr><tr><td><code>front()</code><br><code>back()</code></td><td>첫 번째/마지막 번째 해당하는 원소의 레퍼런스 반환</td></tr></tbody></table></div><ul><li><strong>Capacity</strong><ul><li>크기와 할당 용량과 관련된 메서드</li></ul></li></ul><div class=table><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>empty()</code></td><td>컨테이너가 비어있으면 true</td></tr><tr><td><code>size()</code></td><td>저장된 원소의 수</td></tr><tr><td><code>max_size()</code></td><td>저장 가능한 최대 컨테이너 수 (할당 가능한 최대 heap 메모리 크기 정도)</td></tr><tr><td><code>resize()</code></td><td>컨테이너의 size를 조절</td></tr><tr><td><code>capacity()</code></td><td>컨테이너에 할당된 저장 가능한 원소의 수</td></tr><tr><td><code>reserve()</code></td><td>capacity 수 조절</td></tr></tbody></table></div><ul><li><strong>Modifiers</strong><ul><li>원소 추가/삭제에 관련된 메서드</li></ul></li></ul><div class=table><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>clear()</code></td><td>컨테이너를 비운다.</td></tr><tr><td><code>insert(v)</code></td><td>(특정 위치에) 원소 v를 추가</td></tr><tr><td><code>emplace(v)</code><br><code>emplace_front()</code><br><code>emplace_back()</code></td><td>(특정 위치에) 원소 v를 추가</td></tr><tr><td><code>push_front(v)</code><br><code>push_back()</code></td><td>양 끝 위치에 원소 v를 추가</td></tr><tr><td><code>extract(x)</code></td><td>x가 컨테이너에 존재하면 레퍼런스(node type) 반환</td></tr></tbody></table></div><ul><li><strong>Lookup</strong><ul><li>(association containers에서) 원소 탐색과 관련된 메서드</li></ul></li></ul><div class=table><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>count(x)</code></td><td>컨테이너에 포함된 x의 개수</td></tr><tr><td><code>find(x)</code></td><td>x가 존재하면 x의 이터레이터 반환. 아니라면 end() 반환</td></tr><tr><td><code>contains(x)</code></td><td>x가 존재하면 true</td></tr></tbody></table></div><br><h2 id=3-iterators>3. Iterators<a hidden class=anchor aria-hidden=true href=#3-iterators>#</a></h2><p>&nbsp;&nbsp;
이터레이터는 자료구조를 공통된 방법으로 접근하는 일종의 약속이다. <strong>일반화된 포인터 오브젝트</strong>라고 생각하면 된다. 따라서, 대부분의 연산이 포인터 연산과 유사하다.</p><p>&nbsp;&nbsp;
<code>&lt;algorithm></code>은 자료구조를 접근하기 위해 이터레이터만을 사용한다. 이터레이터라는 공통된 자료 접근 인터페이스는 이터레이터를 구현한 모든 자료구조는 <code>&lt;algorithm></code>을 사용할 수 있도록 알고리즘과 자료구조간의 <strong>의존성을 제거</strong>한다. 모든 컨테이너는 이터레이터 형태의 인터페이스를 제공한다.</p><br><h2 id=4-algorithm>4. Algorithm<a hidden class=anchor aria-hidden=true href=#4-algorithm>#</a></h2><p>&nbsp;&nbsp;
<code>&lt;algorithm></code>은 탐색, 정렬, 카운팅과 같은 범용적으로 많이 사용하는 알고리즘들을 사용하기 쉽도록 미리 구현한 함수들을 말한다. 이터레이터를 사용해 어떤 데이터 타입이든 상관 없이 범용적으로 사용할 수 있도록 만들어졌다. 해당 함수들을 사용하면, JS나 java stream처럼 선언형으로 프로그래밍하는 느낌을 받을 수 있다.<br>&nbsp;</p><h3 id=제공되는-알고리즘-종류>제공되는 알고리즘 종류<a hidden class=anchor aria-hidden=true href=#제공되는-알고리즘-종류>#</a></h3><ul><li>원본을 수정하지 않는 순차 연산<ul><li>탐색</li><li>조건 검색</li><li>카운팅</li></ul></li><li>원본을 수정하는 순차 연산<ul><li>복사 및 이동</li><li>채우기</li><li>회전(뒤집기)</li><li>중복 제거</li><li>자리 변경</li><li>쉬프트</li><li>변형</li></ul></li><li>분할과 합치기(merge)</li><li>정렬</li><li>이진 탐색</li><li>집합 연산</li><li>힙 연산</li><li>최대/최소와 자르기</li><li>비교</li><li>순열과 조합</li><li>그 외 <code>&lt;numeric></code> 헤더 함수들</li></ul><br></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/pair/><span class=title>« 이전 페이지</span><br><span>3. pair: 두 타입을 묶는 구조체</span></a>
<a class=next href=https://green-21.github.io/posts/cppstdlib/history/><span class=title>다음 페이지 »</span><br><span>1. STL vs C++ std - 이름에 관한 이야기</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>