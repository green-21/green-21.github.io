<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>9. insert vs emplace vs push | gReen</title><meta name=keywords content="cpp"><meta name=description content="삽입 메서드 insert, emplace, push의 차이"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/insertion/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/insertion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="9. insert vs emplace vs push"><meta property="og:description" content="삽입 메서드 insert, emplace, push의 차이"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/insertion/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-27T00:52:58+09:00"><meta property="article:modified_time" content="2023-08-27T00:52:58+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="9. insert vs emplace vs push"><meta name=twitter:description content="삽입 메서드 insert, emplace, push의 차이"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"9. insert vs emplace vs push","item":"https://green-21.github.io/posts/cppstdlib/insertion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"9. insert vs emplace vs push","name":"9. insert vs emplace vs push","description":"삽입 메서드 insert, emplace, push의 차이","keywords":["cpp"],"articleBody":" vector의 삽입 메서드를 보면, 3개의 이름을 가진 별도의 메서드가 있는 것을 알 수 있다. 언뜻 보기에는 별 다른 차이가 없어보이는 메서드가 3개나 존재한다. 왜 3개나 되는 삽입 메서드가 존재하는지 알아보자.\n1. 함수 원형 및 쓰임의 차이 insert()와 push_()는 이미 생성된 요소를 삽입할 때 사용한다. insert는 삽입될 유치를 직접 지정해줘야하고, 여러개의 요소를 삽입할 수 있다. push_()는 시작과 끝이 존재하는 컨테이너에서 양쪽 끝에 새로운 원소를 단 한 개만 삽입하고자 할 때 사용한다. 어떻게 보면 insert의 특수화라고 생각할 수도 있다. 따라서, 어떤 vector v의 v.push_back(e)는 v.insert(v.end(), e)와 같다고 생각할 수 있다.\n반면, emplace()는 요소의 생성자를 직접 호출해서 메서드 내부에서 요소를 생성한다. 그래서 매개변수로도 요소 자체가 아니라, 생성시 필요한 것들을 가변인수를 통해서 매개변수로 받는다. 그래서 기존 int형으로는 차이가 두드러지지 않는다. Point라는 클래스를 예시로 들어 차이를 확인해보자.\n#include using namespace std; class Point { public: int x, y; Point() :x(0), y(0) {} Point(int x, int y) : x(x), y(y) {} }; int main() { vector\u003cPoint\u003e v; Point p1{ 10,10 }; Point p2{ 20,20 }; v.insert(v.end(), p1);\t// 기존에 존재하는 요소를 삽입 v.insert(v.end(), Point(1,1));\t// 새로 요소를 생성하면서 삽입 v.insert(v.end(), {2,3});\t// list-initializer를 이용한 생성 후 삽입 v.insert(v.end(), {p1, p2});\t// 여러 개의 요소를 list-initialier로 묶어서 삽입 v.insert(v.end(), { Point(), Point(1,1)});\t// 생성과 동시에 삽입 가능 v.insert(v.end(), { {4,5},{3,2} });\t// 생성과 동시에 삽입 가능 v.insert(v.end(), 5, p1);\t// 동일한 요소롤 반복 추가 가능 //v.insert(v.end(), 3,3);\t// 알 수 없는 잘못된 삽입 연산 v.push_back(p1);\t// 기존에 존재하는 요소를 삽입 v.push_back(Point(1, 1));\t// 새로 요소를 생성하면서 삽입 v.push_back({ 2,3 });\t// list-initializer를 이용한 생성 후 삽입 //v.push_back({ p1, p2 });\t// 여러 개의 요소를 삽입할 수 없다. //v.push_back(4, 5);\t// 알 수 없는 잘못된 삽입 연산 v.emplace(v.end(), 1, 2);\t// Point(1,2)를 내부에서 생성함. v.emplace(v.end());\t// Point()를 내부에서 생성함. v.emplace(v.end(), p1);\t// 복사 생성자를 호출 v.emplace(v.end(), Point(1, 1));\t// 복사 생성자 호출 // v.emplace(v.end(), {p1,p2});\t// 여러 개의 요소 생성 불가능. } 그 외에도 insert와 emplace는 새로 생성된 요소(들의 시작점)의 이터레이터를 반환하는 것에 비해, push는 void 형인 차이점도 있다.\n2. 내부적으로는 어떻게 구현되어 있는가. 가끔 인터넷 블로그나 chatGPT에 물어보면, emplace는 이동 시멘틱을 사용하기 때문에 다른 삽입 연산보다 빠를 수 있다는 말을 한다. 그러나, 이것은 틀린 설명이다. insert와 push도 가능한 경우 이동 시멘틱을 사용하며, 실제 내부 구현은 emplace를 호출하는 식으로 되어 있다. (여러 요소를 추가할 수 있는 insert의 경우 다른 방법을 사용하지만, 이동 시멘틱을 쓸 수 있으면 쓰는 것은 동일하다.)\n즉, 성능상의 차이 함수 스택이 하나 더 쌓이는 것 말고는 없다고 봐도 무방하다. 상황에 따라 쓰고 싶은 메서드를 적절히 사용하면 된다. 아래의 코드는 chatGPT를 이용해서 복사보다 이동이 빠른 클래스의 emplace와 push_back을 비교한 코드이다. 주석처리한 생성자 속 출력문의 주석을 해제하면, push_back도 이동 생성자를 이용하는 것을 알 수 있다. 성능 측정 결과는 두 메서드간의 차이가 거의 없음을 보여준다. (오히려, 메모리 할당의 문제로 늦게 메모리 할당을 수행하는 emplace가 더 느린 결과를 보여준다.)\n#include #include #include class LargeMemoryBlock { public: LargeMemoryBlock(size_t size) : data(new int[size]), size(size) { // Simulate expensive resource allocation for (size_t i = 0; i \u003c size; ++i) { data[i] = i; } } LargeMemoryBlock(const LargeMemoryBlock\u0026 other) : data(new int[other.size]), size(other.size) { //std::cout \u003c\u003c \"Copy constructor\" \u003c\u003c std::endl; for (size_t i = 0; i \u003c size; ++i) { data[i] = other.data[i]; } } LargeMemoryBlock(LargeMemoryBlock\u0026\u0026 other) noexcept : data(other.data), size(other.size) { //std::cout \u003c\u003c \"Move constructor\" \u003c\u003c std::endl; other.data = nullptr; other.size = 0; } ~LargeMemoryBlock() { delete[] data; } private: int* data; size_t size; }; int main() { const int numObjects = 10000; const size_t blockSize = 10000; // 4 MB const int N = 10; std::vector\u003cLargeMemoryBlock\u003e vecCopy; std::vector\u003cLargeMemoryBlock\u003e vecMove; // Benchmark push_back() with LargeMemoryBlock for (int t = 0; t \u003c N; t++) { auto start = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u003c numObjects; ++i) { vecCopy.push_back(LargeMemoryBlock(blockSize)); } auto end = std::chrono::high_resolution_clock::now(); std::chrono::duration\u003cdouble\u003e pushBackCopyTime = end - start; std::cout \u003c\u003c \"push_back() with LargeMemoryBlock time: \" \u003c\u003c pushBackCopyTime.count() \u003c\u003c \" seconds\" \u003c\u003c std::endl; // Benchmark emplace_back() with LargeMemoryBlock start = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u003c numObjects; ++i) { vecMove.emplace_back(blockSize); } end = std::chrono::high_resolution_clock::now(); std::chrono::duration\u003cdouble\u003e emplaceBackMoveTime = end - start; std::cout \u003c\u003c \"emplace_back() with LargeMemoryBlock time: \" \u003c\u003c emplaceBackMoveTime.count() \u003c\u003c \" seconds\" \u003c\u003c std::endl; } return 0; } push_back() with LargeMemoryBlock time: 1.03201 seconds emplace_back() with LargeMemoryBlock time: 1.09236 seconds push_back() with LargeMemoryBlock time: 0.957107 seconds emplace_back() with LargeMemoryBlock time: 0.977603 seconds push_back() with LargeMemoryBlock time: 0.934155 seconds emplace_back() with LargeMemoryBlock time: 0.973151 seconds push_back() with LargeMemoryBlock time: 0.943765 seconds emplace_back() with LargeMemoryBlock time: 0.995767 seconds push_back() with LargeMemoryBlock time: 0.932459 seconds emplace_back() with LargeMemoryBlock time: 0.965338 seconds push_back() with LargeMemoryBlock time: 0.968607 seconds emplace_back() with LargeMemoryBlock time: 1.01215 seconds push_back() with LargeMemoryBlock time: 0.966702 seconds emplace_back() with LargeMemoryBlock time: 0.971681 seconds push_back() with LargeMemoryBlock time: 0.923538 seconds emplace_back() with LargeMemoryBlock time: 0.976951 seconds push_back() with LargeMemoryBlock time: 0.978641 seconds emplace_back() with LargeMemoryBlock time: 0.985579 seconds push_back() with LargeMemoryBlock time: 0.950241 seconds emplace_back() with LargeMemoryBlock time: 0.974465 seconds ","wordCount":"802","inLanguage":"ko","datePublished":"2023-08-27T00:52:58+09:00","dateModified":"2023-08-27T00:52:58+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/insertion/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>9. insert vs emplace vs push</h1><div class=post-meta><span title='2023-08-27 00:52:58 +0900 +0900'>8월 27, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ed%95%a8%ec%88%98-%ec%9b%90%ed%98%95-%eb%b0%8f-%ec%93%b0%ec%9e%84%ec%9d%98-%ec%b0%a8%ec%9d%b4 aria-label="1. 함수 원형 및 쓰임의 차이">1. 함수 원형 및 쓰임의 차이</a></li><li><a href=#2-%eb%82%b4%eb%b6%80%ec%a0%81%ec%9c%bc%eb%a1%9c%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%ea%b5%ac%ed%98%84%eb%90%98%ec%96%b4-%ec%9e%88%eb%8a%94%ea%b0%80 aria-label="2. 내부적으로는 어떻게 구현되어 있는가.">2. 내부적으로는 어떻게 구현되어 있는가.</a></li></ul></div></details></div><div class=post-content><p>&nbsp;&nbsp;
<code>vector</code>의 삽입 메서드를 보면, 3개의 이름을 가진 별도의 메서드가 있는 것을 알 수 있다. 언뜻 보기에는 별 다른 차이가 없어보이는 메서드가 3개나 존재한다. 왜 3개나 되는 삽입 메서드가 존재하는지 알아보자.</p><p><br>&nbsp;</p><h2 id=1-함수-원형-및-쓰임의-차이>1. 함수 원형 및 쓰임의 차이<a hidden class=anchor aria-hidden=true href=#1-함수-원형-및-쓰임의-차이>#</a></h2><p>&nbsp;&nbsp;
<code>insert()</code>와 <code>push_()</code>는 <strong>이미 생성된 요소를 삽입</strong>할 때 사용한다. <code>insert</code>는 삽입될 유치를 직접 지정해줘야하고, 여러개의 요소를 삽입할 수 있다. <code>push_()</code>는 시작과 끝이 존재하는 컨테이너에서 양쪽 끝에 새로운 원소를 단 한 개만 삽입하고자 할 때 사용한다. 어떻게 보면 insert의 특수화라고 생각할 수도 있다. 따라서, 어떤 vector v의 <code>v.push_back(e)</code>는 <code>v.insert(v.end(), e)</code>와 같다고 생각할 수 있다.</p><p>&nbsp;&nbsp;
반면, <code>emplace()</code>는 <strong>요소의 생성자를 직접 호출해서 메서드 내부에서 요소를 생성한다.</strong> 그래서 매개변수로도 요소 자체가 아니라, 생성시 필요한 것들을 가변인수를 통해서 매개변수로 받는다. 그래서 기존 int형으로는 차이가 두드러지지 않는다. Point라는 클래스를 예시로 들어 차이를 확인해보자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> x, y;
</span></span><span style=display:flex><span>	Point() <span style=color:#f92672>:</span>x(<span style=color:#ae81ff>0</span>), y(<span style=color:#ae81ff>0</span>) {}
</span></span><span style=display:flex><span>	Point(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) <span style=color:#f92672>:</span> x(x), y(y) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> v;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Point p1{ <span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>10</span> };
</span></span><span style=display:flex><span>	Point p2{ <span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>20</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	v.insert(v.end(), p1);						<span style=color:#75715e>// 기존에 존재하는 요소를 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.insert(v.end(), Point(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>));				<span style=color:#75715e>// 새로 요소를 생성하면서 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.insert(v.end(), {<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>});					<span style=color:#75715e>// list-initializer를 이용한 생성 후 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.insert(v.end(), {p1, p2});				<span style=color:#75715e>// 여러 개의 요소를 list-initialier로 묶어서 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.insert(v.end(), { Point(), Point(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>)});	<span style=color:#75715e>// 생성과 동시에 삽입 가능
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.insert(v.end(), { {<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>},{<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>2</span>} });			<span style=color:#75715e>// 생성과 동시에 삽입 가능
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.insert(v.end(), <span style=color:#ae81ff>5</span>, p1);					<span style=color:#75715e>// 동일한 요소롤 반복 추가 가능
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//v.insert(v.end(), 3,3);					// 알 수 없는 잘못된 삽입 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	v.push_back(p1);							<span style=color:#75715e>// 기존에 존재하는 요소를 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.push_back(Point(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>));					<span style=color:#75715e>// 새로 요소를 생성하면서 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.push_back({ <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span> });						<span style=color:#75715e>// list-initializer를 이용한 생성 후 삽입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//v.push_back({ p1, p2 });					// 여러 개의 요소를 삽입할 수 없다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//v.push_back(4, 5);						// 알 수 없는 잘못된 삽입 연산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	v.emplace(v.end(), <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);					<span style=color:#75715e>// Point(1,2)를 내부에서 생성함.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.emplace(v.end());							<span style=color:#75715e>// Point()를 내부에서 생성함.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.emplace(v.end(), p1);						<span style=color:#75715e>// 복사 생성자를 호출
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	v.emplace(v.end(), Point(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>));			<span style=color:#75715e>// 복사 생성자 호출
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// v.emplace(v.end(), {p1,p2});				// 여러 개의 요소 생성 불가능.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>&nbsp;&nbsp;
그 외에도 <code>insert</code>와 <code>emplace</code>는 새로 생성된 요소(들의 시작점)의 이터레이터를 반환하는 것에 비해, <code>push</code>는 void 형인 차이점도 있다.</p><p><br>&nbsp;</p><h2 id=2-내부적으로는-어떻게-구현되어-있는가>2. 내부적으로는 어떻게 구현되어 있는가.<a hidden class=anchor aria-hidden=true href=#2-내부적으로는-어떻게-구현되어-있는가>#</a></h2><p>&nbsp;&nbsp;
가끔 인터넷 블로그나 chatGPT에 물어보면, emplace는 이동 시멘틱을 사용하기 때문에 다른 삽입 연산보다 빠를 수 있다는 말을 한다. <strong>그러나, 이것은 틀린 설명이다. insert와 push도 가능한 경우 이동 시멘틱을 사용하며, 실제 내부 구현은 emplace를 호출하는 식으로 되어 있다.</strong> (여러 요소를 추가할 수 있는 insert의 경우 다른 방법을 사용하지만, 이동 시멘틱을 쓸 수 있으면 쓰는 것은 동일하다.)</p><p>&nbsp;&nbsp;
즉, <strong>성능상의 차이 함수 스택이 하나 더 쌓이는 것 말고는 없다고 봐도 무방하다.</strong> 상황에 따라 쓰고 싶은 메서드를 적절히 사용하면 된다. 아래의 코드는 chatGPT를 이용해서 복사보다 이동이 빠른 클래스의 emplace와 push_back을 비교한 코드이다. 주석처리한 생성자 속 출력문의 주석을 해제하면, push_back도 이동 생성자를 이용하는 것을 알 수 있다. 성능 측정 결과는 두 메서드간의 차이가 거의 없음을 보여준다. (오히려, 메모리 할당의 문제로 늦게 메모리 할당을 수행하는 emplace가 더 느린 결과를 보여준다.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;chrono&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LargeMemoryBlock</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    LargeMemoryBlock(size_t size) 
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> data(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[size]), size(size) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Simulate expensive resource allocation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            data[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    LargeMemoryBlock(<span style=color:#66d9ef>const</span> LargeMemoryBlock<span style=color:#f92672>&amp;</span> other) 
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> data(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[other.size]), size(other.size) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//std::cout &lt;&lt; &#34;Copy constructor&#34; &lt;&lt; std::endl;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (size_t i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> size; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            data[i] <span style=color:#f92672>=</span> other.data[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    LargeMemoryBlock(LargeMemoryBlock<span style=color:#f92672>&amp;&amp;</span> other) <span style=color:#66d9ef>noexcept</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> data(other.data), size(other.size) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//std::cout &lt;&lt; &#34;Move constructor&#34; &lt;&lt; std::endl;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        other.data <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>        other.size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>LargeMemoryBlock() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span>[] data;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> data;
</span></span><span style=display:flex><span>    size_t size;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> numObjects <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> size_t blockSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span>;  <span style=color:#75715e>// 4 MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>LargeMemoryBlock<span style=color:#f92672>&gt;</span> vecCopy;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>LargeMemoryBlock<span style=color:#f92672>&gt;</span> vecMove;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Benchmark push_back() with LargeMemoryBlock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; t <span style=color:#f92672>&lt;</span> N; t<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> start <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>high_resolution_clock<span style=color:#f92672>::</span>now();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numObjects; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            vecCopy.push_back(LargeMemoryBlock(blockSize));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> end <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>high_resolution_clock<span style=color:#f92672>::</span>now();
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>duration<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> pushBackCopyTime <span style=color:#f92672>=</span> end <span style=color:#f92672>-</span> start;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;push_back() with LargeMemoryBlock time: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pushBackCopyTime.count() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; seconds&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Benchmark emplace_back() with LargeMemoryBlock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        start <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>high_resolution_clock<span style=color:#f92672>::</span>now();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numObjects; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            vecMove.emplace_back(blockSize);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        end <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>high_resolution_clock<span style=color:#f92672>::</span>now();
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>chrono<span style=color:#f92672>::</span>duration<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> emplaceBackMoveTime <span style=color:#f92672>=</span> end <span style=color:#f92672>-</span> start;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;emplace_back() with LargeMemoryBlock time: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> emplaceBackMoveTime.count() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; seconds&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>push_back() with LargeMemoryBlock time: 1.03201 seconds
emplace_back() with LargeMemoryBlock time: 1.09236 seconds
push_back() with LargeMemoryBlock time: 0.957107 seconds
emplace_back() with LargeMemoryBlock time: 0.977603 seconds
push_back() with LargeMemoryBlock time: 0.934155 seconds
emplace_back() with LargeMemoryBlock time: 0.973151 seconds
push_back() with LargeMemoryBlock time: 0.943765 seconds
emplace_back() with LargeMemoryBlock time: 0.995767 seconds
push_back() with LargeMemoryBlock time: 0.932459 seconds
emplace_back() with LargeMemoryBlock time: 0.965338 seconds
push_back() with LargeMemoryBlock time: 0.968607 seconds
emplace_back() with LargeMemoryBlock time: 1.01215 seconds
push_back() with LargeMemoryBlock time: 0.966702 seconds
emplace_back() with LargeMemoryBlock time: 0.971681 seconds
push_back() with LargeMemoryBlock time: 0.923538 seconds
emplace_back() with LargeMemoryBlock time: 0.976951 seconds
push_back() with LargeMemoryBlock time: 0.978641 seconds
emplace_back() with LargeMemoryBlock time: 0.985579 seconds
push_back() with LargeMemoryBlock time: 0.950241 seconds
emplace_back() with LargeMemoryBlock time: 0.974465 seconds
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/forward-list/><span class=title>« 이전 페이지</span><br><span>10. forward_list: 단일 연결리스트 컨테이너</span></a>
<a class=next href=https://green-21.github.io/posts/cppstdlib/vector/><span class=title>다음 페이지 »</span><br><span>8. vector: 가변 길이 배열 컨테이너</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>