<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3. pair: 두 타입을 묶는 구조체 | gReen</title>
<meta name=keywords content="cpp"><meta name=description content="두 타입을 묶어서 사용할 수 있는 구조체 pair에 대한 정리."><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/pair/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/pair/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="3. pair: 두 타입을 묶는 구조체"><meta property="og:description" content="두 타입을 묶어서 사용할 수 있는 구조체 pair에 대한 정리."><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/pair/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-21T13:40:03+09:00"><meta property="article:modified_time" content="2023-08-21T13:40:03+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="3. pair: 두 타입을 묶는 구조체"><meta name=twitter:description content="두 타입을 묶어서 사용할 수 있는 구조체 pair에 대한 정리."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"3. pair: 두 타입을 묶는 구조체","item":"https://green-21.github.io/posts/cppstdlib/pair/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3. pair: 두 타입을 묶는 구조체","name":"3. pair: 두 타입을 묶는 구조체","description":"두 타입을 묶어서 사용할 수 있는 구조체 pair에 대한 정리.","keywords":["cpp"],"articleBody":"template\u003cclass T1, class T2\u003e struct pair { T1 first; T2 second; }; pair는 두 개의 타입을 하나로 묶은 구조체이다. 에서 다음과 같은 구조로 정의되어 있다. 대부분의 컨테이너는 utility를 포함하고 있기 때문에 컨테이너 헤더를 포함했다면, 헤더를 직접 포함하지 않고도 사용할 수 있다.\n직접 구조체를 만드는 것에 비해 pair을 사용하는 이점은 복사, 이동과 같은 다양한 생성 연산이 구현되어 있다는 것과 비교/대소 연산이 정의되어 있어 이와 관련된 코드를 다시 작성할 필요가 없다는 것이다.\n사용법 생성 기본 생성자 first와 second를 입력 받는 생성자 (이동 연산 포함) list_initializer 복사와 이동 생성자 make_pair() 함수 이용 #include #include using namespace std; int main() { // 1. 기본 생성자 pair\u003cint, int\u003e p1;\t// 0\t0 pair\u003cint, float\u003e p1_1;\t// 0\t0.000.. pair\u003cdouble, string\u003e p1_2;\t// 0.000..\t\"\" // 2. first와 second를 입력 받는다. pair\u003cint, int\u003e p2(1,2);\t// 1 2 // 3. list_initializer pair\u003cint, int\u003e p3{ 2,3 };\t// 2 3 pair\u003cint, int\u003e p3_2 = { 2,3 }; pair\u003cint, int\u003e p3_3({ 2,3 }); // 4. 복사, 이동 생성자 및 대입 연산자 pair\u003cint, int\u003e p4(p3);\t// 2 3 pair\u003cint, int\u003e p4_2(pair\u003cint,int\u003e(1,1));\t// 1 1 pair\u003cint, int\u003e p4_3 = p4; // make_pair auto p5 = make_pair\u003cint, int\u003e(1, 1); auto p6 = make_pair(1, 1); } 접근 각 요소에 접근하는 두 가지 방법이 있다. 첫 번째는 .first, .second로 멤버에 직접 접근하는 방법이고, 다른 하나는 get(pair)를 사용하는 방법이다. 마지막은 구조적 바인딩을 이용하는 것이다.\n// 1. 멤버에 직접 접근 pair\u003cint, string\u003e p{ 1, \"\" }; p.first = 5; p.second = \"뉴진스\"; cout \u003c\u003c p.first \u003c\u003c \", \" \u003c\u003c p.second \u003c\u003c endl; // 2. get(pair) 사용 get\u003c0\u003e(p) = 11; cout \u003c\u003c get\u003c0\u003e(p) \u003c\u003c \", \" \u003c\u003c get\u003c1\u003e(p) \u003c\u003c endl; // 3. structured binding auto\u0026 [i, str] = p; str = \"스진뉴\"; cout \u003c\u003c i \u003c\u003c \", \" \u003c\u003c str \u003c\u003c endl; 5, 뉴진스 11, 뉴진스 11, 스진뉴 비교 pair의 비교 연산은 첫 번쨰를 기준으로 이루어진다. 만약 first가 같다면 second 비교를 통해 비교 연산을 수행한다. 두 요소가 모두 같다면 두 pair는 같다. 당연히 first와 second의 타입인 T1과 T2의 연산자가 정의되어 있어야 한다.\npair\u003cint, int\u003e p1{ 0,1 }; pair\u003cint, int\u003e p2{ 1,0 }; pair\u003cint, int\u003e p3{ 0,2 }; pair\u003cint, int\u003e p4{ 0,1 }; // \u003c= 와 \u003e=도 가능 cout \u003c\u003c (p1 \u003e p2) \u003c\u003c endl;\t// 0 cout \u003c\u003c (p1 \u003e p3) \u003c\u003c endl;\t// 0 cout \u003c\u003c (p1 == p4) \u003c\u003c endl;\t// 1 cout \u003c\u003c (p1 != p2) \u003c\u003c endl;\t// 1 교환 swap() 함수를 통해서 두 pair을 쉽게 교환할 수 있다.\npair\u003cint, int\u003e p1 = { 1,1 }; pair\u003cint, int\u003e p2 = { 2,2 }; cout \u003c\u003c \"최초 값\" \u003c\u003c endl; cout \u003c\u003c p1.first \u003c\u003c \", \" \u003c\u003c p1.second \u003c\u003c endl; cout \u003c\u003c p2.first \u003c\u003c \", \" \u003c\u003c p2.second \u003c\u003c endl; // swap method p1.swap(p2); cout \u003c\u003c \"교환\" \u003c\u003c endl; cout \u003c\u003c p1.first \u003c\u003c \", \" \u003c\u003c p1.second \u003c\u003c endl; cout \u003c\u003c p2.first \u003c\u003c \", \" \u003c\u003c p2.second \u003c\u003c endl; // swap function swap(p1, p2); cout \u003c\u003c \"재교환\" \u003c\u003c endl; cout \u003c\u003c p1.first \u003c\u003c \", \" \u003c\u003c p1.second \u003c\u003c endl; cout \u003c\u003c p2.first \u003c\u003c \", \" \u003c\u003c p2.second \u003c\u003c endl; 최초 값 1, 1 2, 2 교환 2, 2 1, 1 재교환 1, 1 2, 2 사용 예시 컨테이너의 타입으로 사용 다음은 vector 컨테이너의 타입으로 pair를 사용하는 예시이다. 코드는 백준 11000번 강의실 배정 문제의 풀이 코드이다. 정확한 내용은 강의가 시작 시간과 끝 시간으로 주어졌을 때, 이를 먼저 끝나는 강의 순으로 정렬한 다음, 겹치지 않는 다음 강의를 선택해 가능한 최대의 강의 수를 구하는 코드이다. 이런식으로 컨테이너 요소의 타입으로 사용할 수 있는 예를 보이기 위함이기 때문에 코드를 이해하지 못하더라도 문제는 없다.\n#include #include #include using namespace std; int main() { int N; // 회의의 개수 cin \u003e\u003e N; // 회의의 수를 입력 받는다. // 회의 수만큼 컨테이너의 공간을 확보한다. vector\u003cpair\u003cint,int\u003e\u003e meeting(N); for(int i=0; i\u003cN; i++) { // N번 반복 int s; // 회의 시작시간 int e; // 회의 종료 시간 cin \u003e\u003e s \u003e\u003e e; // 두 시간을 입력 받는다. // pair{e,s}를 컨테이너에 삽입한다. meeting[i] = make_pair(e,s); } // 먼저 끝나는 순으로 컨테이너를 정렬한다. // meeting의 first인 e가 오름차순으로 정렬 // e가 같은 경우에 한해서 second인 s 순으로 오름차순 정렬 sort(meeting.begin(), meeting.end()); int ans=0; // 정답 int t=0; // 현재 시간 // 현재 회의가 끝난 다음 고를 수 있느 회의를 찾는다. for(auto\u0026 [e,s] : meeting) { if (s \u003e= t) { ans++; t = e; } } cout \u003c\u003c ans; } map 컨테이너에서 map 컨테이너는 key와 value 두 가지 값을 묶어서 저장하는 컨테이너이다. 이터레이터로 어떤 요소에 접근할 때, pair\u003c\u0026key, \u0026value\u003e 형태로 레퍼런스를 반환한다. 역시 pair를 반환하는 컨테이너가 있음을 보여주기 위함이었기 때문에 map에 대해 잘 이해가 안가더라도 문제 없다.\n#include #include using namespace std; int main() { map\u003cint, string\u003e m{ {1, \"브로콜리너마저\"}, {2, \"쏜애플\"}, {3, \"델리스파이스\"} }; auto iter = m.begin(); pair\u003cint, string\u003e p = (*iter); cout \u003c\u003c get\u003c0\u003e(p) \u003c\u003c \", \" \u003c\u003c get\u003c1\u003e(p) \u003c\u003c endl; } 1, 브로콜리너마저 ","wordCount":"790","inLanguage":"ko","datePublished":"2023-08-21T13:40:03+09:00","dateModified":"2023-08-21T13:40:03+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/pair/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>3. pair: 두 타입을 묶는 구조체</h1><div class=post-meta><span title='2023-08-21 13:40:03 +0900 +0900'>8월 21, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ec%82%ac%ec%9a%a9%eb%b2%95 aria-label=사용법>사용법</a><ul><li><a href=#%ec%83%9d%ec%84%b1 aria-label=생성>생성</a></li><li><a href=#%ec%a0%91%ea%b7%bc aria-label=접근>접근</a></li><li><a href=#%eb%b9%84%ea%b5%90 aria-label=비교>비교</a></li><li><a href=#%ea%b5%90%ed%99%98 aria-label=교환>교환</a></li></ul></li><li><a href=#%ec%82%ac%ec%9a%a9-%ec%98%88%ec%8b%9c aria-label="사용 예시">사용 예시</a><ul><li><a href=#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%9d%98-%ed%83%80%ec%9e%85%ec%9c%bc%eb%a1%9c-%ec%82%ac%ec%9a%a9 aria-label="컨테이너의 타입으로 사용">컨테이너의 타입으로 사용</a></li><li><a href=#map-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90%ec%84%9c aria-label="map 컨테이너에서">map 컨테이너에서</a></li></ul></li></ul></div></details></div><div class=post-content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T1</span>, <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T2</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pair</span> {
</span></span><span style=display:flex><span>    T1 first;
</span></span><span style=display:flex><span>    T2 second;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>&nbsp;&nbsp;
<code>pair</code>는 두 개의 타입을 하나로 묶은 구조체이다. <code>&lt;utility></code>에서 다음과 같은 구조로 정의되어 있다. 대부분의 컨테이너는 utility를 포함하고 있기 때문에 컨테이너 헤더를 포함했다면, <code>&lt;utility></code> 헤더를 직접 포함하지 않고도 사용할 수 있다.</p><p>&nbsp;&nbsp;
직접 구조체를 만드는 것에 비해 pair을 사용하는 이점은 복사, 이동과 같은 다양한 생성 연산이 구현되어 있다는 것과 비교/대소 연산이 정의되어 있어 이와 관련된 코드를 다시 작성할 필요가 없다는 것이다.</p><p><br>&nbsp;</p><h2 id=사용법>사용법<a hidden class=anchor aria-hidden=true href=#사용법>#</a></h2><h3 id=생성>생성<a hidden class=anchor aria-hidden=true href=#생성>#</a></h3><ol><li>기본 생성자</li><li>first와 second를 입력 받는 생성자 (이동 연산 포함)</li><li>list_initializer</li><li>복사와 이동 생성자</li><li>make_pair() 함수 이용</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;utility&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;string&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 1. 기본 생성자
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p1;					<span style=color:#75715e>// 0		0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span> p1_1;				<span style=color:#75715e>// 0		0.000..
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span>, string<span style=color:#f92672>&gt;</span> p1_2;			<span style=color:#75715e>// 0.000..	&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 2. first와 second를 입력 받는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p2(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>);				<span style=color:#75715e>// 1 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 3. list_initializer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p3{ <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span> };			<span style=color:#75715e>// 2 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p3_2 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span> };
</span></span><span style=display:flex><span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p3_3({ <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 4. 복사, 이동 생성자 및 대입 연산자
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p4(p3);						<span style=color:#75715e>// 2 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p4_2(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>));	<span style=color:#75715e>// 1 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p4_3 <span style=color:#f92672>=</span> p4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// make_pair
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>auto</span> p5 <span style=color:#f92672>=</span> make_pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> p6 <span style=color:#f92672>=</span> make_pair(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><h3 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h3><p>&nbsp;&nbsp;
각 요소에 접근하는 두 가지 방법이 있다. 첫 번째는 <code>.first</code>, <code>.second</code>로 멤버에 직접 접근하는 방법이고, 다른 하나는 <code>get&lt;n>(pair)</code>를 사용하는 방법이다. 마지막은 구조적 바인딩을 이용하는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 1. 멤버에 직접 접근
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> p{ <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;&#34;</span> };
</span></span><span style=display:flex><span>p.first <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>p.second <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;뉴진스&#34;</span>;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2. get&lt;n&gt;(pair) 사용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(p) <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(p) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>(p) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. structured binding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [i, str] <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;스진뉴&#34;</span>;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> str <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span></code></pre></div><pre tabindex=0><code>5, 뉴진스
11, 뉴진스
11, 스진뉴
</code></pre><br><h3 id=비교>비교<a hidden class=anchor aria-hidden=true href=#비교>#</a></h3><p>&nbsp;&nbsp;
pair의 비교 연산은 첫 번쨰를 기준으로 이루어진다. 만약 first가 같다면 second 비교를 통해 비교 연산을 수행한다. 두 요소가 모두 같다면 두 pair는 같다. 당연히 first와 second의 타입인 T1과 T2의 연산자가 정의되어 있어야 한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p1{ <span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p2{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p3{ <span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p4{ <span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// &lt;= 와 &gt;=도 가능
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> (p1 <span style=color:#f92672>&gt;</span> p2) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> (p1 <span style=color:#f92672>&gt;</span> p3) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> (p1 <span style=color:#f92672>==</span> p4) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> (p1 <span style=color:#f92672>!=</span> p2) <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 1
</span></span></span></code></pre></div><br><h3 id=교환>교환<a hidden class=anchor aria-hidden=true href=#교환>#</a></h3><p><code>swap()</code> 함수를 통해서 두 pair을 쉽게 교환할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p1 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span> };
</span></span><span style=display:flex><span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> p2 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;최초 값&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p1.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p1.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p2.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p2.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// swap method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>p1.swap(p2);
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;교환&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p1.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p1.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p2.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p2.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// swap function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>swap(p1, p2);
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;재교환&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p1.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p1.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> p2.first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> p2.second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span></code></pre></div><pre tabindex=0><code>최초 값
1, 1
2, 2
교환
2, 2
1, 1
재교환
1, 1
2, 2
</code></pre><p><br>&nbsp;</p><h2 id=사용-예시>사용 예시<a hidden class=anchor aria-hidden=true href=#사용-예시>#</a></h2><h3 id=컨테이너의-타입으로-사용>컨테이너의 타입으로 사용<a hidden class=anchor aria-hidden=true href=#컨테이너의-타입으로-사용>#</a></h3><p>&nbsp;&nbsp;
다음은 vector 컨테이너의 타입으로 <code>pair&lt;int,int></code>를 사용하는 예시이다. 코드는 백준 11000번 강의실 배정 문제의 풀이 코드이다. 정확한 내용은 강의가 시작 시간과 끝 시간으로 주어졌을 때, 이를 먼저 끝나는 강의 순으로 정렬한 다음, 겹치지 않는 다음 강의를 선택해 가능한 최대의 강의 수를 구하는 코드이다. 이런식으로 컨테이너 요소의 타입으로 사용할 수 있는 예를 보이기 위함이기 때문에 코드를 이해하지 못하더라도 문제는 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;vector&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;algorithm&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> N;  <span style=color:#75715e>// 회의의 개수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cin <span style=color:#f92672>&gt;&gt;</span> N;   <span style=color:#75715e>// 회의의 수를 입력 받는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 회의 수만큼 컨테이너의 공간을 확보한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,<span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> meeting(N);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span>N; i<span style=color:#f92672>++</span>) { <span style=color:#75715e>// N번 반복
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> s;   <span style=color:#75715e>// 회의 시작시간
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> e;   <span style=color:#75715e>// 회의 종료 시간
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        cin <span style=color:#f92672>&gt;&gt;</span> s <span style=color:#f92672>&gt;&gt;</span> e;  <span style=color:#75715e>// 두 시간을 입력 받는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pair{e,s}를 컨테이너에 삽입한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        meeting[i] <span style=color:#f92672>=</span> make_pair(e,s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 먼저 끝나는 순으로 컨테이너를 정렬한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// meeting의 first인 e가 오름차순으로 정렬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// e가 같은 경우에 한해서 second인 s 순으로 오름차순 정렬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sort(meeting.begin(), meeting.end());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ans<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;      <span style=color:#75715e>// 정답
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> t<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;        <span style=color:#75715e>// 현재 시간
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 현재 회의가 끝난 다음 고를 수 있느 회의를 찾는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [e,s] <span style=color:#f92672>:</span> meeting) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>&gt;=</span> t) {
</span></span><span style=display:flex><span>            ans<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            t <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> ans;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><h3 id=map-컨테이너에서>map 컨테이너에서<a hidden class=anchor aria-hidden=true href=#map-컨테이너에서>#</a></h3><p>&nbsp;&nbsp;
map 컨테이너는 key와 value 두 가지 값을 묶어서 저장하는 컨테이너이다. 이터레이터로 어떤 요소에 접근할 때, <code>pair&lt;&amp;key, &amp;value></code> 형태로 레퍼런스를 반환한다. 역시 pair를 반환하는 컨테이너가 있음을 보여주기 위함이었기 때문에 map에 대해 잘 이해가 안가더라도 문제 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;map&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> m{
</span></span><span style=display:flex><span>		{<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;브로콜리너마저&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;쏜애플&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;델리스파이스&#34;</span>}
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> m.begin();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>iter);
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(p) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>(p) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>1, 브로콜리너마저
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/allocator/><span class=title>« 이전 페이지</span><br><span>5. Allocators - 컨테이너의 동적 할당과 해제</span>
</a><a class=next href=https://green-21.github.io/posts/cppstdlib/outline/><span class=title>다음 페이지 »</span><br><span>2. 훑어보기</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2024 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>