<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>1. STL vs C++ std - 이름에 관한 이야기 | gReen</title><meta name=keywords content="cpp"><meta name=description content="C++ std 컨테이너를 부르는 이름과 그에 대한 역사 정리"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/history/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/history/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="1. STL vs C++ std - 이름에 관한 이야기"><meta property="og:description" content="C++ std 컨테이너를 부르는 이름과 그에 대한 역사 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/history/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-02T23:51:06+09:00"><meta property="article:modified_time" content="2023-08-02T23:51:06+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="1. STL vs C++ std - 이름에 관한 이야기"><meta name=twitter:description content="C++ std 컨테이너를 부르는 이름과 그에 대한 역사 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"1. STL vs C++ std - 이름에 관한 이야기","item":"https://green-21.github.io/posts/cppstdlib/history/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"1. STL vs C++ std - 이름에 관한 이야기","name":"1. STL vs C\u002b\u002b std - 이름에 관한 이야기","description":"C++ std 컨테이너를 부르는 이름과 그에 대한 역사 정리","keywords":["cpp"],"articleBody":" 라이브러리를 부르는 이름이 여러 개다. 표준 라이브러리를 부르는 이름이 사람마다 상이하다. 많은 사람이 표준 라이브러리, 혹은 컨테이너 부분만 따로 떼서 STL이라고 부른다. MS의 표준 라이브러리 github repo의 이름도 STL로 되어있고, MS공식 문서에서도 STL을 많이 사용되는 이름이라고 언급한다. 국내에서 유명한 책 이름에도 STL이 들어간다. 심지어, C++ 언어 창시자의 문법 서적에서도 STL이라는 용어를 사용하는 것 같다.\n그런데, 누군가는 이 표현이 잘못되었다고 말한다. STL은 컨테이너 자체의 개념과 표준에 편입되기 전 컨테이너의 구현체를 말하는 것이고, 이를 표준 라이브러리의 컨테이너와는 구분해야 한다는 것이다. 실제로 ISO 표준에는 STL이라는 용어가 쓰이지 않는다. 또, 위에서 언급한 MS의 공식 문서에서도 STL을 언급하고 있을지언정 공식적인 이름으로 사용하고 있지는 않다.\n처음 C++의 자료구조 라이브러리를 공부하는 입장에서는 이러한 이름 논쟁이 달갑지는 않다. 공부를 시작하기도 전에 이름에서부터 혼란이 오고, 해결하기 위해 이것저것 찾아봐야 하기 때문이다. 그래서, 세부적인 라이브러리의 내용을 다루기 전에 이러한 혼란을 우선 잠재우려고 한다. 그러기 위해서는 STL과 C++표준 라이브러리의 역사를 알아야 한다.\n역사 1. C++는 자료구조를 지원하지 않았다. 최초 C++에는 배열, 구조체를 넘어가는 복잡한 자료구조를 위한 표준 라이브러리가 없었다고 한다. 세상에! 자료구조를 지원하지 않는 언어도 있다니. 현대에 이 말은 참 이상하게 들린다. 그런데, 그 현대에도 자료구조를 지원하지 않는 언어가 있다. 바로 C++의 전신인 C언어다!\n보통 자료구조를 제공해 주는 현대의 언어들은 두 가지 패러다임을 포함하고 있는 경우가 많다. 바로 객체지향과 일반화 프로그래밍이다. 그런데, C언어에서는 template문법은 당연히 없고, 심지어 객체지향 언어도 아니다. 이런 패러다임이 대중적이게 된 것은 C언어가 만들어진 후 한참 뒤인 C++가 등장할 때쯤이다. 당시에 범용적인 자료구조를 구현해서 제공하기에는 제약이 너무 많을 것이다. 이러한 이유로 C에는 표준 라이브러리에 존재하지 않았고, C를 기반으로 만들어졌던 C++에도 자료구조는 없었다.\n2. 일반화(Generic) 프로그래밍 연구 1970~80년, 컴퓨터 과학자 알렉산더 스테파노프(Alexander Stepanov)를 중심으로 일반화 프로그래밍이 연구되었다. 이 연구의 목표는 알고리즘의 구현과 자료구조를 추상화해서 이 둘 사이의 결합도를 끊어내는 것이었다. 데이터 타입마다 전용 알고리즘을 따로따로 구현하는 것이 아니라, 정해진 연산(인터페이스)를 만족하는 자료구조는 무엇이든 딱 한 번 구현된 (자료구조로부터 추상화된) 알고리즘 코드를 사용할 수 있도록 하는 것이다. 연구의 최초의 구현 시도는 Ada라는 언어였으나, 이 시도는 컴파일러의 한계로 실패했다고 한다.\n3. STL과 C++ 표준 C++에 자료구조가 추가된 것은 1990년대 였는데, 이때 한참 ISO에서 C++의 문법을 표준화하고 있었다. 그 당시 동료에게 표준 위원회에 도움을 줄 것을 요청을 받은 스테파노프는 그간의 연구들을 집약했다. C++ templete를 이용해 일반화 프로그래밍을 구현한 자료구조를 개발하고, 이를 C++ 표준 위원회에 제안하게 된다. 이때, 제안된 개념과 구현이 바로 STL, Standard Template Library이다. C++ 표준 위원회에서는 이 제안을 적극 환영했고, STL의 주요 개념과 구조가 C++ 표준으로 편입된다. 편입된 개념은 Containers, Algorithms, Iterators이다. 개념들이 표준에 편입되면서 STL이라는 용어는 표준에서는 사라졌지만, 그 당시 개발자들에 의해 구전되어 지금까지 내려와서 사용되고 있다.\n결론 STL이라고 부를 수 있는 것은 C++ 표준 라이브러리의 일부분에 적용된 개념이라고 할 수 있다. 물론, 표준 외의 다른 STL 구현체가 현재까지 유지되지 않고, 저명한 저서들에서도 STL이라는 용어를 사용해, STL을 그대로 사용하는 것도 문제가 없을 수도 있다. 개인적으로도 크게 문제가 될 것이 없다고 생각한다. 다만, 정확한 표현은 표준 문서의 내용대로 STL을 빼고 C++ 표준 라이브러리라고 하는 것이 맞다.\n결국 이름에 관한 논쟁의 결론은 다음과 같다. STL이라고 불러도 상관없지만, 정확한 표현은 C++ 표준 라이브러리라고만 부르는 것이 맞다. 앞으로의 글에서도 이를 따라서 표준 라이브러리나 줄여서 std라는 용어를 사용하고자 한다.\n참고자료 Standard Template Library (wikipedia) Generic Programming (wikipeida) Short History of STL ","wordCount":"509","inLanguage":"ko","datePublished":"2023-08-02T23:51:06+09:00","dateModified":"2023-08-02T23:51:06+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/history/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>1. STL vs C++ std - 이름에 관한 이야기</h1><div class=post-meta><span title='2023-08-02 23:51:06 +0900 +0900'>8월 2, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac%eb%a5%bc-%eb%b6%80%eb%a5%b4%eb%8a%94-%ec%9d%b4%eb%a6%84%ec%9d%b4-%ec%97%ac%eb%9f%ac-%ea%b0%9c%eb%8b%a4 aria-label="라이브러리를 부르는 이름이 여러 개다.">라이브러리를 부르는 이름이 여러 개다.</a></li><li><a href=#%ec%97%ad%ec%82%ac aria-label=역사>역사</a><ul><li><a href=#1-c%eb%8a%94-%ec%9e%90%eb%a3%8c%ea%b5%ac%ec%a1%b0%eb%a5%bc-%ec%a7%80%ec%9b%90%ed%95%98%ec%a7%80-%ec%95%8a%ec%95%98%eb%8b%a4 aria-label="1. C++는 자료구조를 지원하지 않았다.">1. C++는 자료구조를 지원하지 않았다.</a></li><li><a href=#2-%ec%9d%bc%eb%b0%98%ed%99%94generic-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%98%eb%b0%8d-%ec%97%b0%ea%b5%ac aria-label="2. 일반화(Generic) 프로그래밍 연구">2. 일반화(Generic) 프로그래밍 연구</a></li><li><a href=#3-stl%ea%b3%bc-c-%ed%91%9c%ec%a4%80 aria-label="3. STL과 C++ 표준">3. STL과 C++ 표준</a></li></ul></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li><li><a href=#%ec%b0%b8%ea%b3%a0%ec%9e%90%eb%a3%8c aria-label=참고자료>참고자료</a></li></ul></div></details></div><div class=post-content><br><h2 id=라이브러리를-부르는-이름이-여러-개다>라이브러리를 부르는 이름이 여러 개다.<a hidden class=anchor aria-hidden=true href=#라이브러리를-부르는-이름이-여러-개다>#</a></h2><p>&nbsp;&nbsp;
표준 라이브러리를 부르는 이름이 사람마다 상이하다. 많은 사람이 표준 라이브러리, 혹은 컨테이너 부분만 따로 떼서 STL이라고 부른다. MS의 표준 라이브러리 github <a href=https://github.com/microsoft/STL>repo</a>의 이름도 STL로 되어있고, <a href="https://learn.microsoft.com/en-us/cpp/standard-library/cpp-standard-library-reference?view=msvc-170">MS공식 문서</a>에서도 STL을 많이 사용되는 이름이라고 언급한다. 국내에서 <a href="https://hanbit.co.kr/store/books/look.php?p_code=B5912645820">유명한 책</a> 이름에도 STL이 들어간다. 심지어, C++ 언어 창시자의 문법 서적에서도 STL이라는 용어를 사용하는 것 같다.</p><p>&nbsp;&nbsp;
그런데, 누군가는 이 표현이 잘못되었다고 말한다. STL은 컨테이너 자체의 개념과 표준에 편입되기 전 컨테이너의 구현체를 말하는 것이고, 이를 표준 라이브러리의 컨테이너와는 구분해야 한다는 것이다. 실제로 ISO 표준에는 STL이라는 용어가 쓰이지 않는다. 또, 위에서 언급한 MS의 공식 문서에서도 STL을 언급하고 있을지언정 공식적인 이름으로 사용하고 있지는 않다.</p><p>&nbsp;&nbsp;
처음 C++의 자료구조 라이브러리를 공부하는 입장에서는 이러한 이름 논쟁이 달갑지는 않다. 공부를 시작하기도 전에 이름에서부터 혼란이 오고, 해결하기 위해 이것저것 찾아봐야 하기 때문이다. 그래서, 세부적인 라이브러리의 내용을 다루기 전에 이러한 혼란을 우선 잠재우려고 한다. 그러기 위해서는 STL과 C++표준 라이브러리의 역사를 알아야 한다.</p><p><br>&nbsp;</p><h2 id=역사>역사<a hidden class=anchor aria-hidden=true href=#역사>#</a></h2><h3 id=1-c는-자료구조를-지원하지-않았다>1. C++는 자료구조를 지원하지 않았다.<a hidden class=anchor aria-hidden=true href=#1-c는-자료구조를-지원하지-않았다>#</a></h3><p>&nbsp;&nbsp;
최초 C++에는 배열, 구조체를 넘어가는 복잡한 자료구조를 위한 표준 라이브러리가 없었다고 한다. 세상에! 자료구조를 지원하지 않는 언어도 있다니. 현대에 이 말은 참 이상하게 들린다. 그런데, 그 현대에도 자료구조를 지원하지 않는 언어가 있다. 바로 C++의 전신인 C언어다!</p><p>&nbsp;&nbsp;
보통 자료구조를 제공해 주는 현대의 언어들은 두 가지 패러다임을 포함하고 있는 경우가 많다. 바로 객체지향과 일반화 프로그래밍이다. 그런데, C언어에서는 template문법은 당연히 없고, 심지어 객체지향 언어도 아니다. 이런 패러다임이 대중적이게 된 것은 C언어가 만들어진 후 한참 뒤인 C++가 등장할 때쯤이다. 당시에 범용적인 자료구조를 구현해서 제공하기에는 제약이 너무 많을 것이다. 이러한 이유로 C에는 표준 라이브러리에 존재하지 않았고, C를 기반으로 만들어졌던 C++에도 자료구조는 없었다.</p><br><h3 id=2-일반화generic-프로그래밍-연구>2. 일반화(Generic) 프로그래밍 연구<a hidden class=anchor aria-hidden=true href=#2-일반화generic-프로그래밍-연구>#</a></h3><p>&nbsp;&nbsp;
1970~80년, 컴퓨터 과학자 알렉산더 스테파노프(Alexander Stepanov)를 중심으로 일반화 프로그래밍이 연구되었다. 이 연구의 목표는 알고리즘의 구현과 자료구조를 추상화해서 이 둘 사이의 결합도를 끊어내는 것이었다. 데이터 타입마다 전용 알고리즘을 따로따로 구현하는 것이 아니라, 정해진 연산(인터페이스)를 만족하는 자료구조는 무엇이든 딱 한 번 구현된 (자료구조로부터 추상화된) 알고리즘 코드를 사용할 수 있도록 하는 것이다. 연구의 최초의 구현 시도는 Ada라는 언어였으나, 이 시도는 컴파일러의 한계로 실패했다고 한다.</p><br><h3 id=3-stl과-c-표준>3. STL과 C++ 표준<a hidden class=anchor aria-hidden=true href=#3-stl과-c-표준>#</a></h3><p>&nbsp;&nbsp;
C++에 자료구조가 추가된 것은 1990년대 였는데, 이때 한참 ISO에서 C++의 문법을 표준화하고 있었다. 그 당시 동료에게 표준 위원회에 도움을 줄 것을 요청을 받은 스테파노프는 그간의 연구들을 집약했다. C++ templete를 이용해 일반화 프로그래밍을 구현한 자료구조를 개발하고, 이를 C++ 표준 위원회에 제안하게 된다. 이때, 제안된 개념과 구현이 바로 STL, Standard Template Library이다. C++ 표준 위원회에서는 이 제안을 적극 환영했고, STL의 주요 개념과 구조가 C++ 표준으로 편입된다. 편입된 개념은 <code>Containers</code>, <code>Algorithms</code>, <code>Iterators</code>이다. 개념들이 표준에 편입되면서 STL이라는 용어는 표준에서는 사라졌지만, 그 당시 개발자들에 의해 구전되어 지금까지 내려와서 사용되고 있다.</p><p><br>&nbsp;</p><h2 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h2><p>&nbsp;&nbsp;
STL이라고 부를 수 있는 것은 C++ 표준 라이브러리의 일부분에 적용된 <strong>개념</strong>이라고 할 수 있다. 물론, 표준 외의 다른 STL 구현체가 현재까지 유지되지 않고, 저명한 저서들에서도 STL이라는 용어를 사용해, STL을 그대로 사용하는 것도 문제가 없을 수도 있다. 개인적으로도 크게 문제가 될 것이 없다고 생각한다. 다만, 정확한 표현은 표준 문서의 내용대로 STL을 빼고 C++ 표준 라이브러리라고 하는 것이 맞다.</p><p>&nbsp;&nbsp;
결국 이름에 관한 논쟁의 결론은 다음과 같다. <strong>STL이라고 불러도 상관없지만, 정확한 표현은 C++ 표준 라이브러리라고만 부르는 것이 맞다.</strong> 앞으로의 글에서도 이를 따라서 표준 라이브러리나 줄여서 std라는 용어를 사용하고자 한다.</p><p><br>&nbsp;</p><h2 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Standard_Template_Library>Standard Template Library (wikipedia)</a><br><a href=https://en.wikipedia.org/wiki/Generic_programming>Generic Programming (wikipeida)</a><br><a href=http://stepanovpapers.com/>Short History of STL</a><br>&nbsp;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/outline/><span class=title>« 이전 페이지</span><br><span>2. 훑어보기</span></a>
<a class=next href=https://green-21.github.io/posts/study/hugo%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/><span class=title>다음 페이지 »</span><br><span>Hugo사용하기1</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>