<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>12. deque: 끝단에서 빠른 자료구조 | gReen</title>
<meta name=keywords content="cpp"><meta name=description content="이중 큐라고 불리는 deque를 구현한 컨테이너 deque에 대한 정리"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/deque/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/deque/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="12. deque: 끝단에서 빠른 자료구조"><meta property="og:description" content="이중 큐라고 불리는 deque를 구현한 컨테이너 deque에 대한 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/deque/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-28T02:01:01+09:00"><meta property="article:modified_time" content="2023-08-28T02:01:01+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="12. deque: 끝단에서 빠른 자료구조"><meta name=twitter:description content="이중 큐라고 불리는 deque를 구현한 컨테이너 deque에 대한 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"12. deque: 끝단에서 빠른 자료구조","item":"https://green-21.github.io/posts/cppstdlib/deque/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"12. deque: 끝단에서 빠른 자료구조","name":"12. deque: 끝단에서 빠른 자료구조","description":"이중 큐라고 불리는 deque를 구현한 컨테이너 deque에 대한 정리","keywords":["cpp"],"articleBody":" template\u003c class Ty, class Allocator = std::allocator\u003cTy\u003e \u003e class deque; deque는 컨테이너의 시작과 끝의 삽입과 삭제가 빠른 자료구조를 구현한 것이다. 헤더에 구현되어 있다. deque는 double ended queue의 줄임말이다. std의 deque는 독특하게 O(1)의 속도로 모든 원소에 접근할 수 있다는 특징이 있다.\n1. 사용 생성 다양한 방법을 이용해 생성 가능하다. 빈 컨테이너를 생성하거나, 미리 요소가 추가된 컨테이너를 생성할 수 있다. 각 생성자들은 Allocator를 추가적으로 받을 수 있다.\n기본 생성자 size를 전달하는 생성자 initializer_list를 전달하는 생성자 시작과 끝의 이터레이터를 전달하는 생성자 복사 생성자 이동 생성자 // 1.\t기본 생성자 //\t아무것도 할당되지 않은 상태로 초기화. deque\u003cint\u003e q1; // 2.\tsize를 전달 받는 생성자. //\tsize이상의 공간을 할당하고 값을 기본값 으로 채움 deque\u003cint\u003e q2(5);\t// 0 0 0 0 0 // 2-2.\tsize와 초기화 값 v을 받는 생성자 //\tsize이상의 공간을 할당하고, v값으로 채움 deque\u003cint\u003e q2_2(5, 1);\t// 1 1 1 1 1 // 3.\tinitializer_list deque\u003cint\u003e q3 = { 1,2,3,4,5 };\t// 1 2 3 4 5 deque\u003cint\u003e q3_2{ 1,2,3,4,5 }; deque\u003cint\u003e q3_3({ 1,2,3,4,5 }); // 4.\titerator deque\u003cint\u003e q4(q3.begin(), q3.end());\t// 1 2 3 4 5; // 5.\tcopy deque\u003cint\u003e q5(q4);\t// 1 2 3 4 5 // 6. move deque\u003cint\u003e q6(move(q5));\t// 1 2 3 4 5 접근 front()와 back()을 통해서 양쪽 끝단에 있는 요소의 레퍼런스를 얻을 수 있다. 또, 원하는 인덱스의 요소를 at() 또는 [] 연산자로 레퍼런스를 얻을 수 있다.\n#include #include using namespace std; int main() { deque\u003cint\u003e q{ 1,2,3,4,5 }; q.front() = 10;\t// 1-\u003e10 q.back();\t// 5 q.at(3) = 0;\t// 4-\u003e0 for (int i = 0; i \u003c 5; i++) { cout \u003c\u003c q[i] \u003c\u003c endl;\t// 10 2 3 0 5 } } 이터레이터 deque의 이터레이터는 모든 연산을 지원한다.\n용량 shrink_to_fit()이 존재하는 이유를 알기 위해서는 deque의 내부 구조를 이해해야 한다.\nsize() - 현재 보관 중인 요소의 개수를 반환한다. max_size() - 메모리상 할당 가능한 요소의 개수를 반환한다. empty() - 컨테이너가 비어있는지 확인한다. shrink_to_fit() - 할당되어있지만, 보관 중인 요소가 없는 메모리를 해제한다. deque\u003cint\u003e q{ 1,2,3,4,5 }; q.size();\t// 5 q.empty();\t// false q.max_size();\t// 메모리의 총량 q.pop_back();\t// 5를 제거한다. q.shrink_to_fit();\t// 5가 있던 요소의 메모리 블록을 해제한다. 수정 insert()와 emplace()로 원하는 위치에 요소를 삽입할 수 있다. erase()를 이용해 원하는 위치의 요소를 삭제할 수 있다. 인덱스를 지정해 일어나는 연산은 모두 O(N)이다. push_back(), push_front(), emplace_back(), emplace_front()를 통해 양쪽 끝에서 삽입이 가능하다. pop_back(), pop_front()를 통해 양쪽 끝의 원소를 삭제할 수 있다. 양쪽 끝에서 일어나는 연산은 모두 O(1)이다.\ndeque\u003cint\u003e q{ 1,3,4 }; auto iter = q.begin() + 1; iter = q.insert(iter, 2);\t// 1 2 3 4 q.insert(iter+1, 100);\t// 1 2 100 3 4 q.emplace(q.end(), 5);\t// 1 2 100 3 4 5 q.erase(q.begin()+2);\t// 1 2 3 4 5 q.push_back(6);\t// 1 2 3 4 5 6 q.push_front(0);\t// 0 1 2 3 4 5 6\tq.pop_front();\t// 1 2 3 4 5 6 q.pop_front();\t// 2 3 4 5 6 q.pop_front();\t// 3 4 5 6 q.pop_front();\t// 4 5 6 q.pop_back();\t// 4 5 resize()는 현재 size보다 작게 설정하면 해당 인덱스 전까지 모든 요소들이 삭제된다. 또, size보다 큰 값으로 설정하면 첫 요소를 기준으로 해당하는 크기만큼 추가적으로 할당한다. 새로 추가된 요소들을 일정한 값으로 채운다. clear()를 이용하면 현재 할당된 데이터를 삭제할 수 있다.\ndeque\u003cint\u003eq{ 1,2,3,4,5,6,7 }; q.resize(3);\t// 1 2 3 q.resize(5, 10);\t// 1 2 3 10 10 q.clear();\t// empty 2. 내부 구조 deque 내부 기능 구현에 호기심이 생길만한 가장 큰 요소는 어떻게 앞단 삽입이 O(1) 이면서 Random Access 역시 O(1)을 보장하고 있느냐이다. 그 외에도 메모리적으로 어떻게 관리되는지 궁금할 수 있다. 이러한 궁금증을 해소하기 위해서 내부 구현에 대한 설명을 3단계로 나누어봤다.\n1_ 특정 단위 크기의 메모리 블록으로 관리한다. deque는 일정한 크기의 메모리 블록 단위로 메모리를 할당하고, 블록에 요소들을 보관한다. msvc++에서는 16바이트 단위로 블록이 생성된다. 예를 들어 deque는 int[4]가 하나의 블록이 된다. 블록에 여유 메모리가 있다면, 블록을 채운식으로 삽입연산이 일어난다. 만약, 블록이 다 채워진 경우, 추가적인 블록을 생성하고, 블록간의 관계를 정의한다. 또, 삽입의 방향이 다른 경우, 새로운 블록을 생성해야할 수도 있다. 위 그림에서 push_front() 메서드를 수행하려면 1 이전에 공간이 필요한데, block 1에는 1 이전에 공간이 없다. 때문에 새로운 블록을 생성하고, block 1 과 연결해야 한다. 이러한 식으로 블록 단위로 요소들을 관리하고, 블록은 연결 관계에 의해서 일련의 배열이라고 추상화 할 수 있다. 그러기 위해서는 연결 관계를 정의해야하는데, 가장 쉬운 방법을 블록을 연결리스트로 연결하는 것이다. 그러나, 그렇게 되면 random access시 O(n)이 되는 문제가 있다.\n2_ map을 통해 인덱싱한다. random access 시에 O(1)을 보장하기 위해 사용할 수 있는 방법은 별도의 인덱싱 테이블을 만드는 것이다. 그리고 그것을 map이라고 한다. map은 인덱스와 블록의 메모리 주소를 1:1로 대응시킨 테이블이라고 볼 수 있다. map에 원하는 인덱스를 요청하면 그에 맞는 블록의 메모리 주소를 반환한다.\n3_ (msvc++ 에서는) map으로 동적할당된 요소 타입의 배열 포인터를 사용한다. msvc++에서는 block의 포인터를 저장하기 위한 배열 포인터와 front가 속한 block이 저장된 인덱스, 요소의 개수만을 가지고 map을 구현한다. 최초 삽입시 맵의 크기는 8로 고정되어 있으며, 블록이 8개가 넘어가면 2씩 곱하면서 크기를 새로 할당한다. (8 -\u003e 16 -\u003e 32 ..)\n최초 block은 0번 인덱스에 저장된다. 만약, 최초 block이 꽉 찼고, push_back()연산이 일어난다면, 새로 만들어지는 블록은 1번 인덱스에 삽입된다. 만약 push_front()연산을 수행해야 한다면, 배열의 마지막 위치인 7번에 새로운 블록을 생성하고, 블록의 끝 인덱스인 7*4+4인 32를 가리키는 31번 인덱스를 offset으로 설정한다. 즉, 선형 배열을 시작과 끝이 연결된 원형처럼 사용하는 것이다. 추가적으로 back에 새로운 block이 필요하면 2번에 저장하고, 새로운 front 블록이 필요하다면 6번 위치에 block에 새로 추가하고, offset을 변경한다. 삽입이 지속되어서 9번째 block이 생성되어야할 때, 새로 2배인 크기가 16인 배열 포인터를 할당하고, 기존 map에서 offset 부터 offset index를 유지하면서 복사한다. 이를 코드로 구현하면 아래와 같다.\n#include #include // int형 전용 Deque // 연산은 대부분 msvc++ std::deque의 연산을 그대로 가져오려고 했음 // https://github.com/microsoft/STL/blob/main/stl/inc/deque class Deque { private: const int blockSize = 4; const int minimumMapSize = 8; int** map; int mapSize; int offset; int size; // map의 크기를 확장한다. void expandMap(int count) { int newSize = mapSize \u003c\u003c count; int** newMap = constructMap(newSize); int blockOffset = offset / blockSize; // offset 부터 끝까지 복사 const int copySize = mapSize-blockOffset; copyMap(newMap, blockOffset, map, blockOffset, copySize); if (blockOffset) { const int restSize = (mapSize - copySize); copyMap(newMap, blockOffset + copySize, map, 0, restSize); } if (map != nullptr) { delete[] map; } map = newMap; mapSize = newSize; } int** constructMap(int size) { int** m = new int* [size]; memset(m, 0, size * sizeof(int*)); return m; } void copyMap(int** newMap, int newOff, int** oldMap, int oldOff, int _size) { _size *= sizeof(int*); memcpy_s(newMap + newOff, _size, oldMap + oldOff, _size); } int getBlock(int i) { return (i / blockSize) \u0026 (mapSize - 1); // 나머지 연산 대신 \u0026 사용 } int* newBlock() { return new int[blockSize]; } public: Deque() : map(constructMap(minimumMapSize)), mapSize(minimumMapSize), offset(0), size(0) {} ~Deque() { for (int i = 0; i \u003c mapSize; i++) { if (map[i] != nullptr) { delete[] map[i]; } } delete[] map; } void push_front(int v) { // 맵이 꽉 찼다면 확장한다. if ((offset + size) % blockSize == 0 \u0026\u0026 mapSize \u003c= ((size + blockSize) / blockSize)) { expandMap(1); } // 새로운 offset을 구한다. offset \u0026= mapSize * blockSize - 1; // 나머지 연산 대신 \u0026 사용 int newOffset = offset != 0 ? offset : mapSize * blockSize; // offset 위치에 block이 없다면 생성한다. const auto block = getBlock(--newOffset); if (map[block] == nullptr) { map[block] = newBlock(); } // 요소를 삽입한다. map[block][newOffset \u0026 (blockSize-1)] = v; offset = newOffset; ++size; } void push_back(int v) { // 맵이 꽉 찼다면 확장한다. if ((offset + size) % blockSize == 0 \u0026\u0026 mapSize \u003c= ((size + blockSize) / blockSize)) { expandMap(1); } // 새로운 offset을 구한다. offset \u0026= mapSize * blockSize - 1; // 나머지 연산 대신 \u0026 사용 int newOffset = offset + size; const int block = getBlock(newOffset); if (map[block] == nullptr) { map[block] = newBlock(); } // 요소를 삽입한다. map[block][newOffset \u0026 (blockSize-1)] = v; ++size; } int\u0026 operator[](int index) { assert((0 \u003c= index \u0026\u0026 index \u003c size)); auto block = getBlock(index+offset); return map[block][index \u0026 (blockSize-1)]; } int\u0026 front() { return (*this)[0]; } int\u0026 back() { return (*this)[size-1]; } }; ","wordCount":"1306","inLanguage":"ko","datePublished":"2023-08-28T02:01:01+09:00","dateModified":"2023-08-28T02:01:01+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/deque/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>12. deque: 끝단에서 빠른 자료구조</h1><div class=post-meta><span title='2023-08-28 02:01:01 +0900 +0900'>8월 28, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ec%82%ac%ec%9a%a9 aria-label="1. 사용">1. 사용</a><ul><li><a href=#%ec%83%9d%ec%84%b1 aria-label=생성>생성</a></li><li><a href=#%ec%a0%91%ea%b7%bc aria-label=접근>접근</a></li><li><a href=#%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0 aria-label=이터레이터>이터레이터</a></li><li><a href=#%ec%9a%a9%eb%9f%89 aria-label=용량>용량</a></li><li><a href=#%ec%88%98%ec%a0%95 aria-label=수정>수정</a></li></ul></li><li><a href=#2-%eb%82%b4%eb%b6%80-%ea%b5%ac%ec%a1%b0 aria-label="2. 내부 구조">2. 내부 구조</a><ul><li><a href=#1_-%ed%8a%b9%ec%a0%95-%eb%8b%a8%ec%9c%84-%ed%81%ac%ea%b8%b0%ec%9d%98-%eb%a9%94%eb%aa%a8%eb%a6%ac-%eb%b8%94%eb%a1%9d%ec%9c%bc%eb%a1%9c-%ea%b4%80%eb%a6%ac%ed%95%9c%eb%8b%a4 aria-label="1_ 특정 단위 크기의 메모리 블록으로 관리한다.">1_ 특정 단위 크기의 메모리 블록으로 관리한다.</a></li><li><a href=#2_-map%ec%9d%84-%ed%86%b5%ed%95%b4-%ec%9d%b8%eb%8d%b1%ec%8b%b1%ed%95%9c%eb%8b%a4 aria-label="2_ map을 통해 인덱싱한다.">2_ map을 통해 인덱싱한다.</a></li><li><a href=#3_-msvc-%ec%97%90%ec%84%9c%eb%8a%94-map%ec%9c%bc%eb%a1%9c-%eb%8f%99%ec%a0%81%ed%95%a0%eb%8b%b9%eb%90%9c-%ec%9a%94%ec%86%8c-%ed%83%80%ec%9e%85%ec%9d%98-%eb%b0%b0%ec%97%b4-%ed%8f%ac%ec%9d%b8%ed%84%b0%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%9c%eb%8b%a4 aria-label="3_ (msvc++ 에서는) map으로 동적할당된 요소 타입의 배열 포인터를 사용한다.">3_ (msvc++ 에서는) map으로 동적할당된 요소 타입의 배열 포인터를 사용한다.</a></li></ul></li></ul></div></details></div><div class=post-content><p>&nbsp;&nbsp;<figure><img loading=lazy src=1.png#center width=400></figure></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ty</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Allocator</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>Ty<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>deque</span>;
</span></span></code></pre></div><p>&nbsp;&nbsp;
<code>deque</code>는 컨테이너의 시작과 끝의 삽입과 삭제가 빠른 자료구조를 구현한 것이다. <code>&lt;deque></code> 헤더에 구현되어 있다. deque는 double ended queue의 줄임말이다. std의 <code>deque</code>는 독특하게 O(1)의 속도로 모든 원소에 접근할 수 있다는 특징이 있다.</p><h2 id=1-사용>1. 사용<a hidden class=anchor aria-hidden=true href=#1-사용>#</a></h2><h3 id=생성>생성<a hidden class=anchor aria-hidden=true href=#생성>#</a></h3><p>다양한 방법을 이용해 생성 가능하다. 빈 컨테이너를 생성하거나, 미리 요소가 추가된 컨테이너를 생성할 수 있다. 각 생성자들은 Allocator를 추가적으로 받을 수 있다.</p><ol><li>기본 생성자</li><li>size를 전달하는 생성자</li><li>initializer_list를 전달하는 생성자</li><li>시작과 끝의 이터레이터를 전달하는 생성자</li><li>복사 생성자</li><li>이동 생성자</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 1.	기본 생성자
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		아무것도 할당되지 않은 상태로 초기화.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.	size를 전달 받는 생성자.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		size이상의 공간을 할당하고 값을 기본값 으로 채움
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q2(<span style=color:#ae81ff>5</span>);						<span style=color:#75715e>// 0 0 0 0 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2-2.	size와 초기화 값 v을 받는 생성자
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		size이상의 공간을 할당하고,  v값으로 채움
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q2_2(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>1</span>);					<span style=color:#75715e>// 1 1 1 1 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3.	initializer_list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q3 <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };		<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q3_2{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q3_3({ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4.	iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q4(q3.begin(), q3.end());	<span style=color:#75715e>// 1 2 3 4 5;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 5.	copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q5(q4);					<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 6. move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q6(move(q5));			<span style=color:#75715e>// 1 2 3 4 5
</span></span></span></code></pre></div><br><h3 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h3><p>&nbsp;&nbsp;
<code>front()</code>와 <code>back()</code>을 통해서 양쪽 끝단에 있는 요소의 레퍼런스를 얻을 수 있다. 또, 원하는 인덱스의 요소를 <code>at()</code> 또는 <code>[] 연산자</code>로 레퍼런스를 얻을 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;iostream&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;deque&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	q.front() <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;		<span style=color:#75715e>// 1-&gt;10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	q.back();			<span style=color:#75715e>// 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	q.at(<span style=color:#ae81ff>3</span>) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;			<span style=color:#75715e>// 4-&gt;0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> q[i] <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 10 2 3 0 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><h3 id=이터레이터>이터레이터<a hidden class=anchor aria-hidden=true href=#이터레이터>#</a></h3><p>&nbsp;&nbsp;
<code>deque</code>의 이터레이터는 <a href=https://green-21.github.io/posts/cppstdlib/iterator/#3-연산 title=iterator>모든 연산</a>을 지원한다.</p><br><h3 id=용량>용량<a hidden class=anchor aria-hidden=true href=#용량>#</a></h3><p><code>shrink_to_fit()</code>이 존재하는 이유를 알기 위해서는 deque의 내부 구조를 이해해야 한다.</p><ul><li><code>size()</code> - 현재 보관 중인 요소의 개수를 반환한다.</li><li><code>max_size()</code> - 메모리상 할당 가능한 요소의 개수를 반환한다.</li><li><code>empty()</code> - 컨테이너가 비어있는지 확인한다.</li><li><code>shrink_to_fit()</code> - 할당되어있지만, 보관 중인 요소가 없는 메모리를 해제한다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span> };
</span></span><span style=display:flex><span>q.size();			<span style=color:#75715e>// 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.empty();			<span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.max_size();		<span style=color:#75715e>// 메모리의 총량
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>q.pop_back();		<span style=color:#75715e>// 5를 제거한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.shrink_to_fit();	<span style=color:#75715e>// 5가 있던 요소의 메모리 블록을 해제한다.
</span></span></span></code></pre></div><br><h3 id=수정>수정<a hidden class=anchor aria-hidden=true href=#수정>#</a></h3><p>&nbsp;&nbsp;
<code>insert()</code>와 <code>emplace()</code>로 원하는 위치에 요소를 삽입할 수 있다. <code>erase()</code>를 이용해 원하는 위치의 요소를 삭제할 수 있다. 인덱스를 지정해 일어나는 연산은 모두 O(N)이다.
&nbsp;&nbsp;
<code>push_back()</code>, <code>push_front()</code>, <code>emplace_back()</code>, <code>emplace_front()</code>를 통해 양쪽 끝에서 삽입이 가능하다. <code>pop_back()</code>, <code>pop_front()</code>를 통해 양쪽 끝의 원소를 삭제할 수 있다. 양쪽 끝에서 일어나는 연산은 모두 O(1)이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span> };
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> q.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>iter <span style=color:#f92672>=</span> q.insert(iter, <span style=color:#ae81ff>2</span>);		<span style=color:#75715e>// 1 2 3 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.insert(iter<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>);			<span style=color:#75715e>// 1 2 100 3 4 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.emplace(q.end(), <span style=color:#ae81ff>5</span>);			<span style=color:#75715e>// 1 2 100 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>q.erase(q.begin()<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>);			<span style=color:#75715e>// 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>q.push_back(<span style=color:#ae81ff>6</span>);		<span style=color:#75715e>// 1 2 3 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.push_front(<span style=color:#ae81ff>0</span>);	<span style=color:#75715e>// 0 1 2 3 4 5 6		
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>q.pop_front();		<span style=color:#75715e>// 1 2 3 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.pop_front();		<span style=color:#75715e>// 2 3 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.pop_front();		<span style=color:#75715e>// 3 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.pop_front();		<span style=color:#75715e>// 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>q.pop_back();		<span style=color:#75715e>// 4 5
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
<code>resize()</code>는 현재 size보다 작게 설정하면 해당 인덱스 전까지 모든 요소들이 삭제된다. 또, size보다 큰 값으로 설정하면 첫 요소를 기준으로 해당하는 크기만큼 추가적으로 할당한다. 새로 추가된 요소들을 일정한 값으로 채운다. <code>clear()</code>를 이용하면 현재 할당된 데이터를 삭제할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>q{ <span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>,<span style=color:#ae81ff>7</span> };
</span></span><span style=display:flex><span>q.resize(<span style=color:#ae81ff>3</span>);		<span style=color:#75715e>// 1 2 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>q.resize(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>10</span>);	<span style=color:#75715e>// 1 2 3 10 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>q.clear();			<span style=color:#75715e>// empty
</span></span></span></code></pre></div><p><br>&nbsp;</p><h2 id=2-내부-구조>2. 내부 구조<a hidden class=anchor aria-hidden=true href=#2-내부-구조>#</a></h2><p>&nbsp;&nbsp;
<code>deque</code> 내부 기능 구현에 호기심이 생길만한 가장 큰 요소는 <strong>어떻게 앞단 삽입이 O(1) 이면서 Random Access 역시 O(1)을 보장하고 있느냐이다.</strong> 그 외에도 메모리적으로 어떻게 관리되는지 궁금할 수 있다. 이러한 궁금증을 해소하기 위해서 내부 구현에 대한 설명을 3단계로 나누어봤다.</p><br><h3 id=1_-특정-단위-크기의-메모리-블록으로-관리한다>1_ 특정 단위 크기의 메모리 블록으로 관리한다.<a hidden class=anchor aria-hidden=true href=#1_-특정-단위-크기의-메모리-블록으로-관리한다>#</a></h3><p>&nbsp;&nbsp;
deque는 <strong>일정한 크기의 메모리 블록</strong> 단위로 메모리를 할당하고, 블록에 요소들을 보관한다. msvc++에서는 16바이트 단위로 블록이 생성된다. 예를 들어 <code>deque&lt;int></code>는 <code>int[4]</code>가 하나의 블록이 된다.<figure><img loading=lazy src=2.png#center width=200></figure>블록에 여유 메모리가 있다면, 블록을 채운식으로 삽입연산이 일어난다.<figure><img loading=lazy src=3.png#center width=370></figure>만약, 블록이 다 채워진 경우, <strong>추가적인 블록을 생성하고, 블록간의 관계를 정의</strong>한다.<figure><img loading=lazy src=4.png#center width=420></figure>&nbsp;&nbsp;
또, 삽입의 방향이 다른 경우, 새로운 블록을 생성해야할 수도 있다. 위 그림에서 push_front() 메서드를 수행하려면 1 이전에 공간이 필요한데, <code>block 1</code>에는 1 이전에 공간이 없다. 때문에 새로운 블록을 생성하고, <code>block 1</code> 과 연결해야 한다.<figure><img loading=lazy src=5.png#center width=650></figure></p><p>&nbsp;&nbsp;
이러한 식으로 블록 단위로 요소들을 관리하고, 블록은 연결 관계에 의해서 일련의 배열이라고 추상화 할 수 있다. 그러기 위해서는 연결 관계를 정의해야하는데, 가장 쉬운 방법을 블록을 연결리스트로 연결하는 것이다. 그러나, 그렇게 되면 random access시 O(n)이 되는 문제가 있다.</p><br><h3 id=2_-map을-통해-인덱싱한다>2_ map을 통해 인덱싱한다.<a hidden class=anchor aria-hidden=true href=#2_-map을-통해-인덱싱한다>#</a></h3><p>&nbsp;&nbsp;
random access 시에 O(1)을 보장하기 위해 사용할 수 있는 방법은 별도의 인덱싱 테이블을 만드는 것이다. 그리고 그것을 map이라고 한다. map은 인덱스와 블록의 메모리 주소를 1:1로 대응시킨 테이블이라고 볼 수 있다. map에 원하는 인덱스를 요청하면 그에 맞는 블록의 메모리 주소를 반환한다.</p><figure><img loading=lazy src=6.png#center></figure><br><h3 id=3_-msvc-에서는-map으로-동적할당된-요소-타입의-배열-포인터를-사용한다>3_ (msvc++ 에서는) map으로 동적할당된 요소 타입의 배열 포인터를 사용한다.<a hidden class=anchor aria-hidden=true href=#3_-msvc-에서는-map으로-동적할당된-요소-타입의-배열-포인터를-사용한다>#</a></h3><p>&nbsp;&nbsp;
msvc++에서는 <strong>block의 포인터를 저장하기 위한 배열 포인터와 front가 속한 block이 저장된 인덱스, 요소의 개수</strong>만을 가지고 map을 구현한다. 최초 삽입시 맵의 크기는 8로 고정되어 있으며, 블록이 8개가 넘어가면 2씩 곱하면서 크기를 새로 할당한다. (8 -> 16 -> 32 ..)</p><p>&nbsp;&nbsp;
최초 block은 0번 인덱스에 저장된다. 만약, 최초 block이 꽉 찼고, push_back()연산이 일어난다면, 새로 만들어지는 블록은 1번 인덱스에 삽입된다. 만약 push_front()연산을 수행해야 한다면, 배열의 마지막 위치인 7번에 새로운 블록을 생성하고, 블록의 끝 인덱스인 7*4+4인 32를 가리키는 31번 인덱스를 offset으로 설정한다. 즉, 선형 배열을 시작과 끝이 연결된 원형처럼 사용하는 것이다.<figure><img loading=lazy src=7.png#cener></figure><br>&nbsp;&nbsp;
추가적으로 back에 새로운 block이 필요하면 2번에 저장하고, 새로운 front 블록이 필요하다면 6번 위치에 block에 새로 추가하고, offset을 변경한다.<figure><img loading=lazy src=8.png#center></figure><br>&nbsp;&nbsp;
삽입이 지속되어서 9번째 block이 생성되어야할 때, 새로 2배인 크기가 16인 배열 포인터를 할당하고, 기존 map에서 offset 부터 offset index를 유지하면서 복사한다.<figure><img loading=lazy src=9.png#center></figure><br>이를 코드로 구현하면 아래와 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>#include&lt;cassert&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include&lt;memory&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// int형 전용 Deque
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 연산은 대부분 msvc++ std::deque의 연산을 그대로 가져오려고 했음
</span></span></span><span style=display:flex><span><span style=color:#75715e>// https://github.com/microsoft/STL/blob/main/stl/inc/deque
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Deque</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> blockSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> minimumMapSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> map;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> mapSize;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> offset;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// map의 크기를 확장한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>expandMap</span>(<span style=color:#66d9ef>int</span> count) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> newSize <span style=color:#f92672>=</span> mapSize <span style=color:#f92672>&lt;&lt;</span> count;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> newMap <span style=color:#f92672>=</span> constructMap(newSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> blockOffset <span style=color:#f92672>=</span> offset <span style=color:#f92672>/</span> blockSize;
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#75715e>// offset 부터 끝까지 복사
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> copySize <span style=color:#f92672>=</span> mapSize<span style=color:#f92672>-</span>blockOffset;
</span></span><span style=display:flex><span>		copyMap(newMap, blockOffset, map, blockOffset, copySize);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (blockOffset) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> restSize <span style=color:#f92672>=</span> (mapSize <span style=color:#f92672>-</span> copySize);
</span></span><span style=display:flex><span>			copyMap(newMap, blockOffset <span style=color:#f92672>+</span> copySize, map, <span style=color:#ae81ff>0</span>, restSize);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (map <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>delete</span>[] map;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		map <span style=color:#f92672>=</span> newMap;
</span></span><span style=display:flex><span>		mapSize <span style=color:#f92672>=</span> newSize;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> <span style=color:#a6e22e>constructMap</span>(<span style=color:#66d9ef>int</span> size) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> m <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> [size];
</span></span><span style=display:flex><span>		memset(m, <span style=color:#ae81ff>0</span>, size <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> m;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>copyMap</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> newMap, <span style=color:#66d9ef>int</span> newOff, <span style=color:#66d9ef>int</span><span style=color:#f92672>**</span> oldMap, <span style=color:#66d9ef>int</span> oldOff, <span style=color:#66d9ef>int</span> _size) {
</span></span><span style=display:flex><span>		_size <span style=color:#f92672>*=</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>		memcpy_s(newMap <span style=color:#f92672>+</span> newOff, _size, oldMap <span style=color:#f92672>+</span> oldOff, _size);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getBlock</span>(<span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> (i <span style=color:#f92672>/</span> blockSize) <span style=color:#f92672>&amp;</span> (mapSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 나머지 연산 대신 &amp; 사용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>newBlock</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[blockSize];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	Deque()
</span></span><span style=display:flex><span>		<span style=color:#f92672>:</span> map(constructMap(minimumMapSize)),
</span></span><span style=display:flex><span>		mapSize(minimumMapSize),
</span></span><span style=display:flex><span>		offset(<span style=color:#ae81ff>0</span>), size(<span style=color:#ae81ff>0</span>) {}
</span></span><span style=display:flex><span>	<span style=color:#f92672>~</span>Deque() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> mapSize; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (map[i] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>delete</span>[] map[i];
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>delete</span>[] map;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push_front</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 맵이 꽉 찼다면 확장한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> ((offset <span style=color:#f92672>+</span> size) <span style=color:#f92672>%</span> blockSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> mapSize <span style=color:#f92672>&lt;=</span> ((size <span style=color:#f92672>+</span> blockSize) <span style=color:#f92672>/</span> blockSize)) {
</span></span><span style=display:flex><span>			expandMap(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 새로운 offset을 구한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		offset <span style=color:#f92672>&amp;=</span> mapSize <span style=color:#f92672>*</span> blockSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 나머지 연산 대신 &amp; 사용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>int</span> newOffset <span style=color:#f92672>=</span> offset <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> offset : mapSize <span style=color:#f92672>*</span> blockSize;
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#75715e>// offset 위치에 block이 없다면 생성한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> block <span style=color:#f92672>=</span> getBlock(<span style=color:#f92672>--</span>newOffset);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (map[block] <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>			map[block] <span style=color:#f92672>=</span> newBlock();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 요소를 삽입한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		map[block][newOffset <span style=color:#f92672>&amp;</span> (blockSize<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>		offset <span style=color:#f92672>=</span> newOffset;
</span></span><span style=display:flex><span>		<span style=color:#f92672>++</span>size;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 맵이 꽉 찼다면 확장한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> ((offset <span style=color:#f92672>+</span> size) <span style=color:#f92672>%</span> blockSize <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> mapSize <span style=color:#f92672>&lt;=</span> ((size <span style=color:#f92672>+</span> blockSize) <span style=color:#f92672>/</span> blockSize)) {
</span></span><span style=display:flex><span>			expandMap(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 새로운 offset을 구한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		offset <span style=color:#f92672>&amp;=</span> mapSize <span style=color:#f92672>*</span> blockSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 나머지 연산 대신 &amp; 사용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>int</span> newOffset <span style=color:#f92672>=</span> offset <span style=color:#f92672>+</span> size;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> block <span style=color:#f92672>=</span> getBlock(newOffset);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (map[block] <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>			map[block] <span style=color:#f92672>=</span> newBlock();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 요소를 삽입한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		map[block][newOffset <span style=color:#f92672>&amp;</span> (blockSize<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)] <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>		<span style=color:#f92672>++</span>size;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span>[](<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>		assert((<span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> index <span style=color:#f92672>&amp;&amp;</span> index <span style=color:#f92672>&lt;</span> size));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>auto</span> block <span style=color:#f92672>=</span> getBlock(index<span style=color:#f92672>+</span>offset);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> map[block][index <span style=color:#f92672>&amp;</span> (blockSize<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> front() { <span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>)[<span style=color:#ae81ff>0</span>]; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> back() { <span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>)[size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/set/><span class=title>« 이전 페이지</span><br><span>14. 집합 컨테이너 - set, multiset</span>
</a><a class=next href=https://green-21.github.io/posts/cppstdlib/list/><span class=title>다음 페이지 »</span><br><span>11. list: 이중 연결리스트 컨테이너</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2024 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>