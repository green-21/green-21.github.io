<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>15. 사전형 컨테이너 - map, multimap | gReen</title><meta name=keywords content="cpp"><meta name=description content="key와 value 쌍을 저장하는 map, multimap에 대한 정리"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/cppstdlib/map/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/cppstdlib/map/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="15. 사전형 컨테이너 - map, multimap"><meta property="og:description" content="key와 value 쌍을 저장하는 map, multimap에 대한 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/cppstdlib/map/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-29T18:02:31+09:00"><meta property="article:modified_time" content="2023-08-29T18:02:31+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="15. 사전형 컨테이너 - map, multimap"><meta name=twitter:description content="key와 value 쌍을 저장하는 map, multimap에 대한 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ std 라이브러리","item":"https://green-21.github.io/posts/cppstdlib/"},{"@type":"ListItem","position":3,"name":"15. 사전형 컨테이너 - map, multimap","item":"https://green-21.github.io/posts/cppstdlib/map/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"15. 사전형 컨테이너 - map, multimap","name":"15. 사전형 컨테이너 - map, multimap","description":"key와 value 쌍을 저장하는 map, multimap에 대한 정리","keywords":["cpp"],"articleBody":"template\u003c class Key, class Ty, class Compare = std::less\u003cKey\u003e, class Allocator = std::allocator\u003cstd::pair\u003cconst Key, Ty\u003e\u003e \u003e class map; map은 key와 value 쌍을 하나의 요소로 저장하는 자료구조를 구현한 컨테이너이다. 헤더에 구현되어 있다. key를 통해서 컨테이너 내부를 탐색해 value를 얻을 수 있다. set 과 유사하게 key에 대해 이진탐색트리로 구현되어 있다. 대부분의 연산은 O(lgN)으로 이루어진다.\n1. 사용 보통 map은 특정한 데이터(value)를 key에 따라 보관하고 key를 이용해서 꺼내 쓰고 싶을 때 사용한다. 예를 들면, id가 있고 id 마다 어떤 유저 정보가 있을 때 id : info 쌍으로 map을 생성할 수 있다. 기본적으로 균형 이진 탐색 트리를 사용하기 때문에, key에 따른 정렬된 순서를 유지한다.\n생성 다양한 방법을 이용해 생성 가능하다. 빈 컨테이너를 생성하거나, 미리 요소가 추가된 컨테이너를 생성할 수 있다. 각 생성자들은 Allocator를 추가적으로 받을 수 있다. 모든 삽입 연산은 O(lgN)이기 때문에 N개의 요소를 동시에 생성하는 생성자는 O(NlgN)의 실행시간을 갖는다.\n기본 생성자 initializer_list를 전달하는 생성자 시작과 끝의 이터레이터를 전달하는 생성자 복사 생성자 이동 생성자 // 1.\t기본 생성자 //\t아무것도 할당되지 않은 상태로 초기화. map\u003cstring, int\u003e m1; // 2.\tinitializer_list map\u003cstring, int\u003e m2 = {\t// 용직 - 준혁 - 효빈 {\"효빈\", 4}, {\"준혁\", 10}, {\"용직\", 1} };\tmap\u003cstring, string\u003e m2_2{\t// bdd - chovy - faker {\"faker\", \"이상혁\"}, {\"chovy\", \"정지훈\"}, {\"bdd\", \"곽보성\"} }; map\u003cint, int\u003e m2_3({ {1,1}, {2,20}, {3, 111}\t// 1 - 2 - 3 }); // 3.\titerator map\u003cstring, int\u003e m3(m2.begin(), m2.end());\t// 용직 - 준혁 - 효빈 // 4.\tcopy map\u003cstring, int\u003e m4(m3);\t// 용직 - 준혁 - 효빈 // 5. move map\u003cstring, int\u003e m5(move(m4));\t// 용직 - 준혁 - 효빈 추가적으로 compare 함수를 전달할 수 있다. compare는 컨테이너가 내부에서 요소간 비교를 수행할 때, 그 연산을 수행하는 함수이다. 이는 삽입, 검색 등 다양한 곳에 이용된다. comp를 전달하지 않은 set은 기본적으로 오름차순 관계를 갖는다. std에서는 기본적인 compare 함수를 제공하는데, 오름차순으로 정렬되는 std::less()와 내림차순으로 정렬되는 std::greater()가 있다. compare를 전달하지 않으면 기본적으로 std::less\u003c\u003e가 전달된다.\n// 6.\tcomp 전달 //\t내림차순으로 정렬됨. map\u003cstring, int\u003e m6(greater\u003cstring\u003e()); map\u003cstring, int, greater\u003cstring\u003e\u003e m6_2; // 7.\tcomp with initializer_limt map\u003cstring, int, greater\u003cstring\u003e\u003e m7({\t// 효빈 - 준혁 - 용직 {\"효빈\", 4}, {\"준혁\", 10}, {\"용직\", 1} } ); // 8.\titerator map\u003cstring, int, greater\u003cstring\u003e\u003e m8(m7.begin(), m7.end());\t// 효빈 - 준혁 - 용직 // 9.\tcopy map\u003cstring, int, greater\u003cstring\u003e\u003e m9(m7);\t// 효빈 - 준혁 - 용직 // 10. move map\u003cstring, int, greater\u003cstring\u003e\u003e m10(move(m9));\t// 효빈 - 준혁 - 용직 greater와 less는 괄호 연산자가 로버로딩된 구조체이다. 필요에 따라서 직접 정의할 수도 있다.\ntemplate \u003cclass _Ty = void\u003e struct Greater { bool operator()(_Ty\u0026 _Left, _Ty\u0026 _Right) { return _Left \u003e _Right; } }; template \u003cclass _Ty = void\u003e struct Less { bool operator()(_Ty\u0026 _Left, _Ty\u0026 _Right) { return _Left \u003c _Right; } }; 이를 구조체가 아닌 일반 함수로 만들어 사용할 수도 있다.\ntemplate\u003ctypename Ty\u003e bool greaterFunc(Ty\u0026 left, Ty\u0026 right) { return left \u003e right; } // 템플릿을 사용하지 않는 경우 bool lessIntFunc(int\u0026 left, int\u0026 right) { return left \u003c right; } 접근 []연산자와 at()을 통해서 접근이 가능하다. 단, 이 연산자에 입력 값은 인덱스가 아니라, key 값이다. map은 요소를 key 통해서 접근한다. 트리에서 key값을 탐색해야하기 때문에 O(lgN) 의 실행시간이 필요하다. 그 외의 접근 방법은 이터레이터나 조회(Lookup) 메서드를 사용하는 것 뿐이다.\nmap\u003cstring, string\u003e m{ {\"faker\", \"이상혁\"}, {\"chovy\", \"정지훈\"}, {\"bdd\", \"곽보성\"} }; cout \u003c\u003c m[\"faker\"] \u003c\u003c endl;\t// 이상혁 cout \u003c\u003c m[\"chovy\"] \u003c\u003c endl;\t// 정지훈 cout \u003c\u003c m.at(\"bdd\") \u003c\u003c endl;\t// 곽보성 접근 메서드를 활용하면, 컨테이너에 존재하지 않은 key로 접근하는 경우, 해당 키로 새로운 요소를 생성해 저장한다. key에 대응하는 value는 타입의 zero 값으로 생성된다.\ncout \u003c\u003c m[\"showmaker\"] \u003c\u003c endl;\t// 빈 문자열이 생성됨! m[\"scout\"] = \"이예찬\";\t// bdd - chovy - faker - scout - showmaker // \"곽보성\" - \"정지훈\" - \"이상혁\" - \"이예찬\" - \"\" 이터레이터 --와 ++ 연산자를 지원한다. 역참조는 pair를 반환한다. key는 const로 수정할 수 없다.\nmap\u003cstring, string\u003e m{ {\"faker\", \"이상혁\"}, {\"chovy\", \"정지훈\"}, {\"bdd\", \"곽보성\"} }; auto iter = m.begin(); cout \u003c\u003c iter-\u003efirst \u003c\u003c \", \" \u003c\u003c iter-\u003esecond \u003c\u003c endl;\t// \"bdd\", \"곽보성\" // iter-\u003efirst = \"ddb\"\t// error iter-\u003esecond = \"비디디\";\t// \"bdd\", \"비디디\" 용량 size() 저장된 요소의 개수를 반환 empty() 컨테이너가 비어있으면 true max_size() 저장 가능한 컨테이너 수 반환 수정 insert()와 emplace()로 삽입할 수 있다. erase()로 요소를 삭제한다. key의 대소 관계에 따라서 위치가 정해지기 때문에 직접 위치를 지정할 수는 없다. 이미 존재하는 key의 value를 수정하고 싶다면 삽입 대신 insert_assign()을 사용한다.\nmap\u003cint, int\u003e m{ {1,1}, {2,2} }; m.insert({ 3,3 });\t// {1,1}, {2,2}, {3,3} m.emplace(4,4);\t// {1,1}, {2,2}, {3,3}, {4,4} // 수정 실패 m.insert({ 3,4 });\t// {1,1}, {2,2}, {3,3}, {4,4} // 지우고 다시 삽입하는 방식으로 수정 m.erase(3);\t// {1,1}, {2,2}, {4,4} m.insert({ 3,4 });\t// {1,1}, {2,2}, {3,4}, {4,4} // 삽입 혹은 수정 m.insert_or_assign(3, 3);\t// {1,1}, {2,2}, {3,3}, {4,4} m.insert_or_assign(5, 5);\t// {1,1}, {2,2}, {3,3}, {4,4}, {5,5} merge()를 이용해서 타입이 같은 두 map을 하나로 합칠 수 있다. 매개변수로 들어오는 set은 복사가 아니라 이동된다. clear()함수로 컨테이너를 비울 수 있다.\nmap\u003cint, int\u003e m1{ {1,1}, {3,3} }; map\u003cint, int\u003e m2{ {2,2}, {4,4} }; m1.merge(m2);\t// {1,1} {2,2} {3,3} {4,4} m1.clear();\t// empty extract는 set에서 요소를 제거하면서 제거된 요소의 tree_node를 반환한다. 반환된 node에는 요소의 값은 물론 기존 연결되어 있었던 부모, 자식에게도 접근할 수 있다.\n// 4 // 2 5 // 1 3 map\u003cint, int\u003e m{ {1,1},{2,2},{3,3},{4,4},{5,5} }; auto node = m.extract(1); auto v = node._Getptr()-\u003e_Parent; cout \u003c\u003c node.mapped() \u003c\u003c endl;\t// 1 cout \u003c\u003c v-\u003e_Myval.second \u003c\u003c endl;\t// 2 cout \u003c\u003c v-\u003e_Left-\u003e_Myval.second \u003c\u003c endl;\t// 스레기 값(1 이 tree에서 삭제됨.) cout \u003c\u003c v-\u003e_Right-\u003e_Myval.second \u003c\u003c endl;\t// 3 조회 map의 핵심 기능은 트리에서 key를 찾는 것이다. 이와 관련된 다양한 연산이 존재한다.\ncount(key) - 보관된 key의 개수를 반환한다. find(key) - key가 존재하면 key의 이터레이터를, 아니면 past-the-end 이터레이터를 반환한다. contains(key) - key가 존재하면 true를 반환한다. equal_range(key) - key값이 존재하는 범위에 대한 시작, 끝 이터레이터를 반환한다. lower_bound(key) - key 값이나 없다면 key에 가장 가까운 오른쪽 값을 반환한다. upper_bound(key) - key과 가장 가까운 오른쪽 값을 반환한다. lower_bound()와 upper_bound()는 past-the-end를 반환할 수 있다는 점에서 항상 주의해야 한다. 오름차순을 기준으로 lower_bound는 v가 존재하면 v를 아니면 v보다 큰 수 중 가장 작은 수를 반환한다. upper_bound는 항상 v보다 크면서 가장 작은 수를 반환한다.\nmap\u003cint, int\u003e m{ {1,1},{1,2},{2,3},{2,4},{2,5},{3,6} }; // {1,1} {2,3} {3,6}; (중복키 제거됨) m.count(1);\t// 1 auto iter = m.find(6);\t// past-the-end if (iter == m.end()) { cout \u003c\u003c \"end 이터레이터\" \u003c\u003c endl; } if (m.contains(3)) { cout \u003c\u003c \"키가 3인 원소가 존재함\" \u003c\u003c endl; } cout \u003c\u003c \"i\\tlower\\tupper\" \u003c\u003c endl; for (int i = 0; i \u003c 5; i++) { cout \u003c\u003c i \u003c\u003c '\\t'; auto lower = m.lower_bound(i); if (lower == m.end()) { cout \u003c\u003c \"end\\t\"; } else { cout \u003c\u003c lower-\u003efirst \u003c\u003c \",\" \u003c\u003c lower-\u003esecond \u003c\u003c '\\t'; } auto upper = m.upper_bound(i); if (upper == m.end()) { cout \u003c\u003c \"end\" \u003c\u003c endl; } else { cout \u003c\u003c upper-\u003efirst \u003c\u003c \",\" \u003c\u003c upper-\u003esecond \u003c\u003c endl; } } end 이터레이터 키가 3인 원소가 존재함 i lower upper 0 1,1 1,1 1 1,1 2,3 2 2,3 3,6 3 3,6 end 4 end end 2. multimap multimap은 중복을 허용하는 map이다. 중복된 키가 동시에 컨테이너에 존재할 수 있다. 중복 허용은 많은 메서드의 결과를 달라지게 만든다. multiset은 헤더에 구현되어 있다.\n우선 count()를 더 의미있게 사용할 수 있다. map에서는 0아니면 1이었기 때문에 find나 contains를 사용하는 것과 다를게 없었지만, multiset에서는 같은 요소가 여러 번 저장될 수 있기 때문에 보관된 요소의 수를 출력한다. equal_range()역시 map에 비해서 의미있게 사용할 수 있다. 해당 메서드를 사용해서 중복되는 모든 요소의 이터레이터를 얻을 수 있다.\nmultimap\u003cint, char\u003e mm{ {1,'A'},{2,'B'},{2,'C'}, {2,'D'}, {3,'E'} }; cout \u003c\u003c mm.count(2) \u003c\u003c endl;\t// 2 auto [begin, end] = mm.equal_range(2); for (auto iter = begin; iter != end; iter++) { cout \u003c\u003c iter-\u003efirst \u003c\u003c \", \" \u003c\u003c iter-\u003esecond \u003c\u003c endl; } 3 2, B 2, C 2, D find()의 경우에는 가장 왼쪽에 있는 요소의 이터레이터를 반환한다. lower_bound와 upper_bound 역시 연산을 만족하는 가장 왼편의 값을 반환한다.\nfor (auto iter = mm.find(2); iter != mm.end(); iter++) { cout \u003c\u003c iter-\u003efirst \u003c\u003c \", \" \u003c\u003c iter-\u003esecond \u003c\u003c endl; } cout \u003c\u003c endl; // 가장 왼편의 2를 선택함 for (auto iter = mm.lower_bound(2); iter != mm.end(); iter++) { cout \u003c\u003c iter-\u003efirst \u003c\u003c \", \" \u003c\u003c iter-\u003esecond \u003c\u003c endl; } cout \u003c\u003c endl; // 가장 왼편의 3을 선택함. for (auto iter = mm.upper_bound(2); iter != mm.end(); iter++) { cout \u003c\u003c iter-\u003efirst \u003c\u003c \", \" \u003c\u003c iter-\u003esecond \u003c\u003c endl; } 2, B 2, C 2, D 3, E 2, B 2, C 2, D 3, E 3, E ","wordCount":"1364","inLanguage":"ko","datePublished":"2023-08-29T18:02:31+09:00","dateModified":"2023-08-29T18:02:31+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/cppstdlib/map/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>15. 사전형 컨테이너 - map, multimap</h1><div class=post-meta><span title='2023-08-29 18:02:31 +0900 +0900'>8월 29, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#1-%ec%82%ac%ec%9a%a9 aria-label="1. 사용">1. 사용</a><ul><li><a href=#%ec%83%9d%ec%84%b1 aria-label=생성>생성</a></li><li><a href=#%ec%a0%91%ea%b7%bc aria-label=접근>접근</a></li><li><a href=#%ec%9d%b4%ed%84%b0%eb%a0%88%ec%9d%b4%ed%84%b0 aria-label=이터레이터>이터레이터</a></li><li><a href=#%ec%9a%a9%eb%9f%89 aria-label=용량>용량</a></li><li><a href=#%ec%88%98%ec%a0%95 aria-label=수정>수정</a></li><li><a href=#%ec%a1%b0%ed%9a%8c aria-label=조회>조회</a></li></ul></li><li><a href=#2-multimap aria-label="2. multimap">2. multimap</a></li></ul></div></details></div><div class=post-content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Key</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ty</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Compare</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>less<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Allocator</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Key, Ty<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>map</span>;
</span></span></code></pre></div><p>&nbsp;&nbsp;
<code>map</code>은 key와 value 쌍을 하나의 요소로 저장하는 자료구조를 구현한 컨테이너이다. <code>&lt;map></code> 헤더에 구현되어 있다. key를 통해서 컨테이너 내부를 탐색해 value를 얻을 수 있다. <code>set</code> 과 유사하게 key에 대해 이진탐색트리로 구현되어 있다. 대부분의 연산은 O(lgN)으로 이루어진다.</p><p><br>&nbsp;</p><h2 id=1-사용>1. 사용<a hidden class=anchor aria-hidden=true href=#1-사용>#</a></h2><p>&nbsp;&nbsp;
보통 map은 특정한 데이터(value)를 key에 따라 보관하고 key를 이용해서 꺼내 쓰고 싶을 때 사용한다. 예를 들면, id가 있고 id 마다 어떤 유저 정보가 있을 때 id : info 쌍으로 map을 생성할 수 있다. 기본적으로 균형 이진 탐색 트리를 사용하기 때문에, key에 따른 정렬된 순서를 유지한다.</p><br><h3 id=생성>생성<a hidden class=anchor aria-hidden=true href=#생성>#</a></h3><p>다양한 방법을 이용해 생성 가능하다. 빈 컨테이너를 생성하거나, 미리 요소가 추가된 컨테이너를 생성할 수 있다. 각 생성자들은 Allocator를 추가적으로 받을 수 있다. 모든 삽입 연산은 O(lgN)이기 때문에 N개의 요소를 동시에 생성하는 생성자는 O(NlgN)의 실행시간을 갖는다.</p><ol><li>기본 생성자</li><li>initializer_list를 전달하는 생성자</li><li>시작과 끝의 이터레이터를 전달하는 생성자</li><li>복사 생성자</li><li>이동 생성자</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 1.	기본 생성자
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		아무것도 할당되지 않은 상태로 초기화.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.	initializer_list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m2 <span style=color:#f92672>=</span> {			<span style=color:#75715e>// 용직 - 준혁 - 효빈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	{<span style=color:#e6db74>&#34;효빈&#34;</span>, <span style=color:#ae81ff>4</span>},
</span></span><span style=display:flex><span>	{<span style=color:#e6db74>&#34;준혁&#34;</span>, <span style=color:#ae81ff>10</span>},
</span></span><span style=display:flex><span>	{<span style=color:#e6db74>&#34;용직&#34;</span>, <span style=color:#ae81ff>1</span>}
</span></span><span style=display:flex><span>};		
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string, string<span style=color:#f92672>&gt;</span> m2_2{		<span style=color:#75715e>// bdd - chovy - faker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	{<span style=color:#e6db74>&#34;faker&#34;</span>, <span style=color:#e6db74>&#34;이상혁&#34;</span>},
</span></span><span style=display:flex><span>	{<span style=color:#e6db74>&#34;chovy&#34;</span>, <span style=color:#e6db74>&#34;정지훈&#34;</span>},
</span></span><span style=display:flex><span>	{<span style=color:#e6db74>&#34;bdd&#34;</span>, <span style=color:#e6db74>&#34;곽보성&#34;</span>}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m2_3({
</span></span><span style=display:flex><span>	{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>20</span>}, {<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>111</span>}		<span style=color:#75715e>// 1 - 2 - 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3.	iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m3(m2.begin(), m2.end());	<span style=color:#75715e>// 용직 - 준혁 - 효빈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4.	copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m4(m3);					<span style=color:#75715e>// 용직 - 준혁 - 효빈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 5. move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m5(move(m4));				<span style=color:#75715e>// 용직 - 준혁 - 효빈
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
추가적으로 compare 함수를 전달할 수 있다. compare는 컨테이너가 내부에서 요소간 비교를 수행할 때, 그 연산을 수행하는 함수이다. 이는 삽입, 검색 등 다양한 곳에 이용된다. comp를 전달하지 않은 <code>set</code>은 기본적으로 오름차순 관계를 갖는다. std에서는 기본적인 compare 함수를 제공하는데, 오름차순으로 정렬되는 <code>std::less&lt;Ty>()</code>와 내림차순으로 정렬되는 <code>std::greater&lt;Ty>()</code>가 있다. compare를 전달하지 않으면 기본적으로 <code>std::less&lt;></code>가 전달된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 6.	comp 전달
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		내림차순으로 정렬됨.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m6(greater<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> m6_2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 7.	comp with initializer_limt
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> m7({							<span style=color:#75715e>// 효빈 - 준혁 - 용직
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	{<span style=color:#e6db74>&#34;효빈&#34;</span>, <span style=color:#ae81ff>4</span>},
</span></span><span style=display:flex><span>	{<span style=color:#e6db74>&#34;준혁&#34;</span>, <span style=color:#ae81ff>10</span>},
</span></span><span style=display:flex><span>	{<span style=color:#e6db74>&#34;용직&#34;</span>, <span style=color:#ae81ff>1</span>} }
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 8.	iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> m8(m7.begin(), m7.end());		<span style=color:#75715e>// 효빈 - 준혁 - 용직
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 9.	copy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> m9(m7);						<span style=color:#75715e>// 효빈 - 준혁 - 용직
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 10. move
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;&gt;</span> m10(move(m9));				<span style=color:#75715e>// 효빈 - 준혁 - 용직
</span></span></span></code></pre></div><p><code>greater</code>와 <code>less</code>는 괄호 연산자가 로버로딩된 구조체이다. 필요에 따라서 직접 정의할 수도 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Ty</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Greater</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(_Ty<span style=color:#f92672>&amp;</span> _Left, _Ty<span style=color:#f92672>&amp;</span> _Right) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _Left <span style=color:#f92672>&gt;</span> _Right;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_Ty</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Less</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(_Ty<span style=color:#f92672>&amp;</span> _Left, _Ty<span style=color:#f92672>&amp;</span> _Right) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _Left <span style=color:#f92672>&lt;</span> _Right;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>이를 구조체가 아닌 일반 함수로 만들어 사용할 수도 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Ty<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> greaterFunc(Ty<span style=color:#f92672>&amp;</span> left, Ty<span style=color:#f92672>&amp;</span> right) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> left <span style=color:#f92672>&gt;</span> right;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 템플릿을 사용하지 않는 경우
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>lessIntFunc</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> left, <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> right) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> left <span style=color:#f92672>&lt;</span> right;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><h3 id=접근>접근<a hidden class=anchor aria-hidden=true href=#접근>#</a></h3><p>&nbsp;&nbsp;
<code>[]연산자</code>와 <code>at()</code>을 통해서 접근이 가능하다. 단, 이 연산자에 입력 값은 인덱스가 아니라, key 값이다. map은 요소를 key 통해서 접근한다. 트리에서 key값을 탐색해야하기 때문에 O(lgN) 의 실행시간이 필요하다. 그 외의 접근 방법은 이터레이터나 조회(Lookup) 메서드를 사용하는 것 뿐이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string, string<span style=color:#f92672>&gt;</span> m{
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;faker&#34;</span>, <span style=color:#e6db74>&#34;이상혁&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;chovy&#34;</span>, <span style=color:#e6db74>&#34;정지훈&#34;</span>},
</span></span><span style=display:flex><span>		{<span style=color:#e6db74>&#34;bdd&#34;</span>, <span style=color:#e6db74>&#34;곽보성&#34;</span>}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> m[<span style=color:#e6db74>&#34;faker&#34;</span>] <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 이상혁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> m[<span style=color:#e6db74>&#34;chovy&#34;</span>] <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 정지훈
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> m.at(<span style=color:#e6db74>&#34;bdd&#34;</span>) <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// 곽보성
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
접근 메서드를 활용하면, 컨테이너에 존재하지 않은 key로 접근하는 경우, 해당 키로 새로운 요소를 생성해 저장한다. key에 대응하는 value는 타입의 zero 값으로 생성된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> m[<span style=color:#e6db74>&#34;showmaker&#34;</span>] <span style=color:#f92672>&lt;&lt;</span> endl;		<span style=color:#75715e>// 빈 문자열이 생성됨!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>m[<span style=color:#e6db74>&#34;scout&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;이예찬&#34;</span>;			<span style=color:#75715e>//   bdd   -   chovy  -  faker  -  scout   - showmaker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>								<span style=color:#75715e>// &#34;곽보성&#34; - &#34;정지훈&#34; - &#34;이상혁&#34; - &#34;이예찬&#34; - &#34;&#34;
</span></span></span></code></pre></div><br><h3 id=이터레이터>이터레이터<a hidden class=anchor aria-hidden=true href=#이터레이터>#</a></h3><p>&nbsp;&nbsp;
<code>--</code>와 <code>++</code> 연산자를 지원한다. 역참조는 <code>pair&lt;key, value></code>를 반환한다. key는 const로 수정할 수 없다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>string, string<span style=color:#f92672>&gt;</span> m{
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#34;faker&#34;</span>, <span style=color:#e6db74>&#34;이상혁&#34;</span>},
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#34;chovy&#34;</span>, <span style=color:#e6db74>&#34;정지훈&#34;</span>},
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#34;bdd&#34;</span>, <span style=color:#e6db74>&#34;곽보성&#34;</span>}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> m.begin();
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// &#34;bdd&#34;, &#34;곽보성&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// iter-&gt;first = &#34;ddb&#34;		// error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;비디디&#34;</span>;		<span style=color:#75715e>// &#34;bdd&#34;, &#34;비디디&#34;
</span></span></span></code></pre></div><br><h3 id=용량>용량<a hidden class=anchor aria-hidden=true href=#용량>#</a></h3><ul><li><code>size()</code> 저장된 요소의 개수를 반환</li><li><code>empty()</code> 컨테이너가 비어있으면 true</li><li><code>max_size()</code> 저장 가능한 컨테이너 수 반환</li></ul><br><h3 id=수정>수정<a hidden class=anchor aria-hidden=true href=#수정>#</a></h3><p><code>insert()</code>와 <code>emplace()</code>로 삽입할 수 있다. <code>erase()</code>로 요소를 삭제한다. key의 대소 관계에 따라서 위치가 정해지기 때문에 직접 위치를 지정할 수는 없다. 이미 존재하는 key의 value를 수정하고 싶다면 삽입 대신 <code>insert_assign()</code>을 사용한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m{
</span></span><span style=display:flex><span>	{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>m.insert({ <span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span> });			<span style=color:#75715e>// {1,1}, {2,2}, {3,3}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m.emplace(<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>4</span>);				<span style=color:#75715e>// {1,1}, {2,2}, {3,3}, {4,4}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 수정 실패
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m.insert({ <span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span> });			<span style=color:#75715e>// {1,1}, {2,2}, {3,3}, {4,4}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 지우고 다시 삽입하는 방식으로 수정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m.erase(<span style=color:#ae81ff>3</span>);					<span style=color:#75715e>// {1,1}, {2,2}, {4,4}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m.insert({ <span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span> });			<span style=color:#75715e>// {1,1}, {2,2}, {3,4}, {4,4}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 삽입 혹은 수정
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m.insert_or_assign(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>);	<span style=color:#75715e>// {1,1}, {2,2}, {3,3}, {4,4}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m.insert_or_assign(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span>);	<span style=color:#75715e>// {1,1}, {2,2}, {3,3}, {4,4}, {5,5}
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
<code>merge()</code>를 이용해서 <code>&lt;key, value></code> 타입이 같은 두 map을 하나로 합칠 수 있다. 매개변수로 들어오는 set은 복사가 아니라 이동된다. <code>clear()</code>함수로 컨테이너를 비울 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m1{ {<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>}, {<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>} };
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m2{ {<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>}, {<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>4</span>} };
</span></span><span style=display:flex><span>m1.merge(m2);	<span style=color:#75715e>// {1,1} {2,2} {3,3} {4,4}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>m1.clear();		<span style=color:#75715e>// empty
</span></span></span></code></pre></div><p>&nbsp;&nbsp;
<code>extract</code>는 set에서 요소를 제거하면서 제거된 요소의 tree_node를 반환한다. 반환된 node에는 요소의 값은 물론 기존 연결되어 있었던 부모, 자식에게도 접근할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>//        4
</span></span></span><span style=display:flex><span><span style=color:#75715e>//     2     5
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   1  3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m{ {<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>},{<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>},{<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>},{<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>4</span>},{<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>5</span>} };
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> node <span style=color:#f92672>=</span> m.extract(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> v <span style=color:#f92672>=</span> node._Getptr()<span style=color:#f92672>-&gt;</span>_Parent;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> node.mapped() <span style=color:#f92672>&lt;&lt;</span> endl;				<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> v<span style=color:#f92672>-&gt;</span>_Myval.second <span style=color:#f92672>&lt;&lt;</span> endl;			<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> v<span style=color:#f92672>-&gt;</span>_Left<span style=color:#f92672>-&gt;</span>_Myval.second <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// 스레기 값(1 이 tree에서 삭제됨.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>cout <span style=color:#f92672>&lt;&lt;</span> v<span style=color:#f92672>-&gt;</span>_Right<span style=color:#f92672>-&gt;</span>_Myval.second <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// 3
</span></span></span></code></pre></div><br><h3 id=조회>조회<a hidden class=anchor aria-hidden=true href=#조회>#</a></h3><p>&nbsp;&nbsp;
map의 핵심 기능은 트리에서 key를 찾는 것이다. 이와 관련된 다양한 연산이 존재한다.</p><ul><li><code>count(key)</code> - 보관된 key의 개수를 반환한다.</li><li><code>find(key)</code> - key가 존재하면 key의 이터레이터를, 아니면 past-the-end 이터레이터를 반환한다.</li><li><code>contains(key)</code> - key가 존재하면 true를 반환한다.</li><li><code>equal_range(key)</code> - key값이 존재하는 범위에 대한 시작, 끝 이터레이터를 반환한다.</li><li><code>lower_bound(key)</code> - key 값이나 없다면 key에 가장 가까운 오른쪽 값을 반환한다.</li><li><code>upper_bound(key)</code> - key과 가장 가까운 오른쪽 값을 반환한다.</li></ul><p>&nbsp;&nbsp;
<code>lower_bound()</code>와 <code>upper_bound()</code>는 past-the-end를 반환할 수 있다는 점에서 항상 주의해야 한다. 오름차순을 기준으로 lower_bound는 v가 존재하면 v를 아니면 v보다 큰 수 중 가장 작은 수를 반환한다. upper_bound는 항상 v보다 크면서 가장 작은 수를 반환한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m{ {<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>},{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>},{<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>},{<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>4</span>},{<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>},{<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>6</span>} };
</span></span><span style=display:flex><span>				<span style=color:#75715e>// {1,1} {2,3} {3,6}; (중복키 제거됨)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>m.count(<span style=color:#ae81ff>1</span>);		<span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> m.find(<span style=color:#ae81ff>6</span>);		<span style=color:#75715e>// past-the-end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (iter <span style=color:#f92672>==</span> m.end()) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;end 이터레이터&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (m.contains(<span style=color:#ae81ff>3</span>)) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;키가 3인 원소가 존재함&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>lower</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>upper&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\t&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> lower <span style=color:#f92672>=</span> m.lower_bound(i);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (lower <span style=color:#f92672>==</span> m.end()) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;end</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> lower<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#f92672>&lt;&lt;</span> lower<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\t&#39;</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>auto</span> upper <span style=color:#f92672>=</span> m.upper_bound(i);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (upper <span style=color:#f92672>==</span> m.end()) {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;end&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		cout <span style=color:#f92672>&lt;&lt;</span> upper<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#f92672>&lt;&lt;</span> upper<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>end 이터레이터
키가 3인 원소가 존재함
i       lower   upper
0       1,1     1,1
1       1,1     2,3
2       2,3     3,6
3       3,6     end
4       end     end
</code></pre><p><br>&nbsp;</p><h2 id=2-multimap>2. multimap<a hidden class=anchor aria-hidden=true href=#2-multimap>#</a></h2><p>&nbsp;&nbsp;
<code>multimap</code>은 중복을 허용하는 map이다. 중복된 키가 동시에 컨테이너에 존재할 수 있다. 중복 허용은 많은 메서드의 결과를 달라지게 만든다. multiset은 <code>&lt;set></code> 헤더에 구현되어 있다.</p><p>&nbsp;&nbsp;
우선 <code>count()</code>를 더 의미있게 사용할 수 있다. map에서는 0아니면 1이었기 때문에 find나 contains를 사용하는 것과 다를게 없었지만, multiset에서는 같은 요소가 여러 번 저장될 수 있기 때문에 보관된 요소의 수를 출력한다.<br>&nbsp;
<code>equal_range()</code>역시 map에 비해서 의미있게 사용할 수 있다. 해당 메서드를 사용해서 중복되는 모든 요소의 이터레이터를 얻을 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>multimap<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> mm{ {<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#39;A&#39;</span>},{<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#39;B&#39;</span>},{<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#39;C&#39;</span>}, {<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#39;D&#39;</span>}, {<span style=color:#ae81ff>3</span>,<span style=color:#e6db74>&#39;E&#39;</span>} };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> mm.count(<span style=color:#ae81ff>2</span>) <span style=color:#f92672>&lt;&lt;</span> endl;	<span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> [begin, end] <span style=color:#f92672>=</span> mm.equal_range(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> begin; iter <span style=color:#f92672>!=</span> end; iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>3
2, B
2, C
2, D
</code></pre><p>&nbsp;&nbsp;
<code>find()</code>의 경우에는 가장 왼쪽에 있는 요소의 이터레이터를 반환한다. lower_bound와 upper_bound 역시 연산을 만족하는 가장 왼편의 값을 반환한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> mm.find(<span style=color:#ae81ff>2</span>); iter <span style=color:#f92672>!=</span> mm.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 가장 왼편의 2를 선택함
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> mm.lower_bound(<span style=color:#ae81ff>2</span>); iter <span style=color:#f92672>!=</span> mm.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 가장 왼편의 3을 선택함.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> mm.upper_bound(<span style=color:#ae81ff>2</span>); iter <span style=color:#f92672>!=</span> mm.end(); iter<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> iter<span style=color:#f92672>-&gt;</span>second <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code>2, B
2, C
2, D
3, E

2, B
2, C
2, D
3, E

3, E
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/cppstdlib/unordered-set/><span class=title>« 이전 페이지</span><br><span>17. unordered_set: 해시를 이용한 set</span></a>
<a class=next href=https://green-21.github.io/posts/cppstdlib/set/><span class=title>다음 페이지 »</span><br><span>14. 집합 컨테이너 - set, multiset</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>