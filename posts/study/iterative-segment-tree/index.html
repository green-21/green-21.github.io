<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>반복을 이용한 세그먼트 트리 | gReen</title>
<meta name=keywords content="algorithms,python"><meta name=description content="반복을 이용한 세그먼트 트리의 원리와 구현"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/study/iterative-segment-tree/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/study/iterative-segment-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="반복을 이용한 세그먼트 트리"><meta property="og:description" content="반복을 이용한 세그먼트 트리의 원리와 구현"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/study/iterative-segment-tree/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-27T23:25:26+09:00"><meta property="article:modified_time" content="2023-09-27T23:25:26+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="반복을 이용한 세그먼트 트리"><meta name=twitter:description content="반복을 이용한 세그먼트 트리의 원리와 구현"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"study","item":"https://green-21.github.io/posts/study/"},{"@type":"ListItem","position":3,"name":"반복을 이용한 세그먼트 트리","item":"https://green-21.github.io/posts/study/iterative-segment-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"반복을 이용한 세그먼트 트리","name":"반복을 이용한 세그먼트 트리","description":"반복을 이용한 세그먼트 트리의 원리와 구현","keywords":["algorithms","python"],"articleBody":" Efficient and easy segment trees에서 소개하는 일반적인 세그먼트 트리 구현보다 조금 더 빠르고, 메모리 효율성이 좋은 구현 방법을 정리하고자 한다. C++코드는 링크를 타고 확인할 수 있기 때문에 파이썬으로 정리했다. 정확히 증명을 했다기 보다는 직관적으로 이해한 느낌이라 설명이 부실할 수도 있다.\n특징 재귀가 아닌 반복으로 구현한다. (파이썬에서 특히 유용하다.) 배열을 통해서 트리를 구현한다. 2^N-1 보다 적은 2N의 공간복잡도로 구현이 가능하다. 항상 완전 이진트리지만 항상 포화인 것은 아니다. 인덱스 연산에 사칙 연산 대신 비트 연산을 사용한다. query(l,r) 연산은[l, r)의 범위로 계산된다. 코드 우선, 전체 코드를 살펴보자. 구간 합에 대한 세그먼트 트리의 생성, 수정, 질의 코드는 다음과 같다.\n# 구간의 합을 구하는 세그먼트 트리 def build(arr, n): seg = [0] * n + arr for i in reversed(range(1, n)): seg[i] = seg[i\u003c\u003c1] + seg[i\u003c\u003c1|1] return seg def modify(seg,n, idx, val): idx += n seg[idx] = val while idx \u003e 1: seg[idx\u003e\u003e1] = seg[idx] + seg[idx^1] idx \u003e\u003e= 1 def query(seg, n, l ,r): l += n r += n result = 0 while l\u003cr: if l\u00261: result += seg[l] l += 1 if r\u00261: r -= 1 result += seg[r] l \u003e\u003e=1 r \u003e\u003e=1 return result 각 기능별로 쪼개서 하나씩 살펴보도록 하자.\nbuild # arr : 트리에 들어갈 원소들 ex) arr = {1,2,3,4,5} # n : arr의 원소의 개수 ex) n = 5 def build(arr, n): # 원소들이 값이 0이고 크기가 n인 배열을 만들고, # 거기에 arr을 이어 붙인다. # ex) seg = {0,0,0,0,0,1,2,3,4,5} seg = [0] * n + arr # 0 이었던 n-1부터 왼쪽 자식과 오른쪽 자식의 합으로 원소를 채운다. # ex) seg = {0, 15, 10, 5, 9, 1, 2, 3, 4, 5} for i in reversed(range(1, n)): # 왼쪽 오른쪽 자식의 합을 저장. # i\u003c\u003c1은 항상 짝수이므로 i\u003c\u003c1|1 == i\u003c\u003c1+1 seg[i] = seg[i\u003c\u003c1] + seg[i\u003c\u003c1|1] return seg 먼저, 들어오는 배열 arr의 원소의 수 만큼 트리를 위한 배열을 만들고, 배열 arr을 합쳐 총 2*N 크기의 배열을 생성한다. 이렇게 하면, 항상 잎들은 arr의 원소 값으로 채워지고, 나머지는 0인 트리를 생성할 수 있다. 그 다음, 잎이 아닌 1~n-1번 까지의 노드(0번은 사용하지 않는다.)를 역순인 n-1부터 거꾸로 돌면서 자식들의 합으로 채워 기본적인 세그먼트 트리를 완성시킨다. 인덱스 연산에서 비트 연산으로 or을 사용하는데, 이는 인덱스에 +1을 해주는 것과 같다.\nmodify # seg: 트리 배열 # n : 트리를 이루는 잎의 수 (최초 입력된 노드의 수) # idx : 수정할 노드의 위치 (arr에서의 위치) # val : 덮어 쓸 값. def modify(seg,n, idx, val): # 1 ~ n-1은 부분합을 저장하기 때문에, # 실제 트리에 수정할 잎이 존재하는 위치를 n을 더해서 얻는다. idx += n # 값을 수정한다. seg[idx] = val # 구간합 노드들에 수정된 값을 반영한다. while idx \u003e 1: # idx가 짝수면 idx^1은 idx+1 # idx가 홀수이면 idx-1 seg[idx\u003e\u003e1] = seg[idx] + seg[idx^1] idx \u003e\u003e= 1 # idx = idx // 2 수정할 요소들은 항상 잎에 있다. 그 외의 노드들은 어떤 구간의 합을 저장하는 노드들이다. 또, 잎의 시작 위치는 기존에 n 개의 0으로 초기화 했던 것을 기억하면, n번 노드부터 잎이라는 것을 알 수 있다. 따라서, 입력된 arr의 인덱스에 n을 더해 수정해야할 요소를 찾고, 값을 val로 바꾼다. 그 다음, root를 향해 올라가면서 변경된 값을 부분합이 저장된 중간 노드들에도 반영한다. 여기서는 xor 비트 연산을 사용했는데, 이는 idx가 부모 기준으로 왼쪽인지 오른쪽인지 알수 없기 때문이다. 비트 연산을 통해 어느쪽이든 상관 없게 간결하게 일관된 방법을 이용할 수 있다.\n이진 트리에 성질에 의해 왼쪽 자식은 짝수, 오른쪽 자식은 홀수(왼쪽 +1)로 정해져 있다. 여기서 idx가 홀수이면 이진수로 표현했을 때, 마지막 비트가 1인데, 1과 xor연산을 하면 나머지 비트는 그대로고, 마지막 비트가 0으로 변해 -1 한 것과 같은 효과가 있다. 반대로, idx가 짝수이면 마지막 비트가 0이고, 1과 xor 연산을 하면 나머지 비트는 그대로고, 마지막 비트가 1로 바뀌어 +1과 같은 효과가 있다. query # seg : 트리가 저장된 배열 # n : 트리의 잎 수 # l : 왼쪽 범위 # r : 오른쪽 범위 def query(seg, n, l ,r): l += n # 왼쪽 구간의 잎의 위치 r += n # 오른쪽 구간의 잎의 위치 result = 0 # 질의의 결과 while l\u003cr: # L이 홀수(right)이면 자신을 더하고, 옆 칸으로 넘어간다. if l\u00261: result += seg[l] l += 1 # R이 홀수(right)이면 자신의 형제 (같은 부모의 왼쪽 자식)을 더한다. if r\u00261: r -= 1 result += seg[r] # 각각 부모로 이동 l \u003e\u003e=1 r \u003e\u003e=1 return result 전혀 직관적이지 않은 코드다. 특이한 점은 매 반복마다 홀수 일 때만 어떤 액션을 취해주는데, 왼쪽에서는 인덱스가 홀수인 자기 자신을 더하고, 오른쪽 구간에서는 항상 옆에 있는 같은 부모의 왼쪽 형제를 더한다는 것이다. 각각의 구간이 홀수, 짝수일 때를 각각 따져보자.\n우선, 왼쪽 닫힌 구간이 홀수이면 어떤 노드의 오른쪽 자식이라는 말이 된다. 그 말은 왼쪽 형제는 범위에 포함되지 않는다는 소리이고, 왼쪽 자식의 값이 포함된 부모 역시 범위에 포함될 수 없다. 따라서, 자기 자신을 더하고, 1을 더해 범위를 한칸 이동시킨다.(범위를 좁힌다.) 여기서 1을 더해도 문제가 없는 이유는 같은 레벨(높이)에서 오른쪽은 항상 범위에 포함되기 때문이다.\n반대로 왼쪽 닫힌 구간이 짝수라면, 어떤 중간 노드의 왼쪽 자식이 된다. 이 경우에는 양쪽 형제들이 모두 범위에 포함되고, 그 값은 부모가 가지고 있기 때문에 부모쪽에서 계산하도록 아무 행동도 하지 않는다.\n오른쪽 열린 구간이 홀수이면 역시 어떤 노드의 오른쪽 자식이고, 항상 왼쪽 형제가 존재한다. 열린 구간이기 때문에 자신은 포함되어서는 안되지만, 형제는 범위에 포함되기 때문에 -1을 해 형제로 이동하고, 형제를 결과에 더한다.\n마지막으로 오른쪽 열린 구간이 짝수이면, 이쪽 트리는 구간에 포함되지 않는다고 볼 수 있다. 따라서, 아무 행동도 하지 않는다.\n예시\n글로만 이루어진 설명으로는 이해하기 힘들어 예제를 준비했다. 기존에 예를 들었던 배열 arr=[1,2,3,4,5]로 트리를 생성하고, qeury(seg,5, 0, 4)라는 연산을 수행한다고 하자. arr의 인덱스 0, 1, 2, 3의 부분합인 1+2+3+4=10이 나와야 한다. 아래 트리 사진으로 더할 구간을 눈으로 확인할 수 있다. 코드를 따라가서, 가장 먼저 두 값에 n을 더해 잎의 위치를 찾으면 왼쪽 닫힌 구간(L)과 오른쪽 열린 구간(R)은 각각 5와 9가 된다. 두 구간 다 홀수이기 때문에 if에 걸린다. 그러면 seg[5]와 seg[8]의 값이 더해지고 범위는 6과 8이 된다. 반복의 마지막 연산으로 부모로 이동하면 3과 4가 된다. 그 다음 반복에서, 3과 4 중 왼쪽 닫힌 구간(L)은 자기의 범위를 포함하기 때문에 자신을 더한 다음, 4로 이동하고 부모인 2로 이동한다. 오른쪽 열린 구간은 짝수기 때문에 바로 부모인 2로 올라간다. 두 구간의 값이 같아 졌기 때문에 더 이상의 반복을 진행하지 않는다. 3번 5번 8번 인덱스를 더함으로 원하던 [0, 4) 구간의 합 10을 구할 수 있다.\n기타 해당 자료구조의 구현이 삽입 연산, Lazy Propagation 등 역시 구현할 수 있다고 한다. 그러나, 이러한 문제를 아직 풀지 않아서, 나중에 해당 문제들을 이해하게 된다면 추가로 정리하도록 하겠다.\n","wordCount":"1036","inLanguage":"ko","datePublished":"2023-09-27T23:25:26+09:00","dateModified":"2023-09-27T23:25:26+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/study/iterative-segment-tree/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>반복을 이용한 세그먼트 트리</h1><div class=post-meta><span title='2023-09-27 23:25:26 +0900 +0900'>9월 27, 2023</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ed%8a%b9%ec%a7%95 aria-label=특징>특징</a></li><li><a href=#%ec%bd%94%eb%93%9c aria-label=코드>코드</a><ul><li><a href=#build aria-label=build>build</a></li><li><a href=#modify aria-label=modify>modify</a></li><li><a href=#query aria-label=query>query</a></li></ul></li><li><a href=#%ea%b8%b0%ed%83%80 aria-label=기타>기타</a></li></ul></div></details></div><div class=post-content><p>&nbsp;&nbsp;
<a href=https://codeforces.com/blog/entry/18051>Efficient and easy segment trees</a>에서 소개하는 일반적인 세그먼트 트리 구현보다 조금 더 빠르고, 메모리 효율성이 좋은 구현 방법을 정리하고자 한다. C++코드는 링크를 타고 확인할 수 있기 때문에 파이썬으로 정리했다. 정확히 증명을 했다기 보다는 직관적으로 이해한 느낌이라 설명이 부실할 수도 있다.</p><br><h2 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h2><ol><li>재귀가 아닌 반복으로 구현한다. (파이썬에서 특히 유용하다.)</li><li><strong>배열</strong>을 통해서 트리를 구현한다.</li><li>2^N-1 보다 적은 <strong>2N</strong>의 공간복잡도로 구현이 가능하다.</li><li>항상 완전 이진트리지만 항상 포화인 것은 아니다.</li><li>인덱스 연산에 사칙 연산 대신 <strong>비트 연산</strong>을 사용한다.</li><li>query(l,r) <strong>연산은[l, r)의 범위</strong>로 계산된다.</li></ol><br><h2 id=코드>코드<a hidden class=anchor aria-hidden=true href=#코드>#</a></h2><p>&nbsp;&nbsp;
우선, 전체 코드를 살펴보자. 구간 합에 대한 세그먼트 트리의 생성, 수정, 질의 코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 구간의 합을 구하는 세그먼트 트리</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build</span>(arr, n):
</span></span><span style=display:flex><span>    seg <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n <span style=color:#f92672>+</span> arr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> reversed(range(<span style=color:#ae81ff>1</span>, n)):
</span></span><span style=display:flex><span>        seg[i] <span style=color:#f92672>=</span> seg[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> seg[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seg
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>modify</span>(seg,n, idx, val):
</span></span><span style=display:flex><span>    idx <span style=color:#f92672>+=</span> n
</span></span><span style=display:flex><span>    seg[idx] <span style=color:#f92672>=</span> val
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> idx <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        seg[idx<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> seg[idx] <span style=color:#f92672>+</span> seg[idx<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        idx <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>query</span>(seg, n, l ,r):
</span></span><span style=display:flex><span>    l <span style=color:#f92672>+=</span> n
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> n
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> l<span style=color:#f92672>&lt;</span>r:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> l<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            result <span style=color:#f92672>+=</span> seg[l]
</span></span><span style=display:flex><span>            l <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> r<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            r <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            result <span style=color:#f92672>+=</span> seg[r]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        l <span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p>각 기능별로 쪼개서 하나씩 살펴보도록 하자.</p><br><h3 id=build>build<a hidden class=anchor aria-hidden=true href=#build>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># arr : 트리에 들어갈 원소들  ex) arr = {1,2,3,4,5}</span>
</span></span><span style=display:flex><span><span style=color:#75715e># n   : arr의 원소의 개수    ex) n = 5</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>build</span>(arr, n):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 원소들이 값이 0이고 크기가 n인 배열을 만들고, </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 거기에 arr을 이어 붙인다.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># ex) seg = {0,0,0,0,0,1,2,3,4,5}</span>
</span></span><span style=display:flex><span>    seg <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n <span style=color:#f92672>+</span> arr
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 0 이었던 n-1부터 왼쪽 자식과 오른쪽 자식의 합으로 원소를 채운다.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># ex) seg = {0, 15, 10, 5, 9, 1, 2, 3, 4, 5}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> reversed(range(<span style=color:#ae81ff>1</span>, n)):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 왼쪽 오른쪽 자식의 합을 저장.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># i&lt;&lt;1은 항상 짝수이므로 i&lt;&lt;1|1 == i&lt;&lt;1+1</span>
</span></span><span style=display:flex><span>        seg[i] <span style=color:#f92672>=</span> seg[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> seg[i<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>|</span><span style=color:#ae81ff>1</span>]    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> seg
</span></span></code></pre></div><p>&nbsp;&nbsp;
먼저, 들어오는 배열 arr의 원소의 수 만큼 트리를 위한 배열을 만들고, 배열 arr을 합쳐 총 <code>2*N</code> 크기의 배열을 생성한다. 이렇게 하면, 항상 잎들은 arr의 원소 값으로 채워지고, 나머지는 0인 트리를 생성할 수 있다.<figure><img loading=lazy src=1.png#center width=60%></figure></p><p>&nbsp;&nbsp;
그 다음, 잎이 아닌 1~n-1번 까지의 노드(0번은 사용하지 않는다.)를 역순인 n-1부터 거꾸로 돌면서 자식들의 합으로 채워 기본적인 세그먼트 트리를 완성시킨다. 인덱스 연산에서 비트 연산으로 or을 사용하는데, 이는 인덱스에 +1을 해주는 것과 같다.</p><figure><img loading=lazy src=2.png#center width=60%></figure><br><h3 id=modify>modify<a hidden class=anchor aria-hidden=true href=#modify>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># seg: 트리 배열</span>
</span></span><span style=display:flex><span><span style=color:#75715e># n : 트리를 이루는 잎의 수 (최초 입력된 노드의 수)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># idx : 수정할 노드의 위치 (arr에서의 위치)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># val : 덮어 쓸 값.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>modify</span>(seg,n, idx, val):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 1 ~ n-1은 부분합을 저장하기 때문에,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 실제 트리에 수정할 잎이 존재하는 위치를 n을 더해서 얻는다.</span>
</span></span><span style=display:flex><span>    idx <span style=color:#f92672>+=</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 값을 수정한다.</span>
</span></span><span style=display:flex><span>    seg[idx] <span style=color:#f92672>=</span> val
</span></span><span style=display:flex><span>    <span style=color:#75715e># 구간합 노드들에 수정된 값을 반영한다.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> idx <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># idx가 짝수면 idx^1은 idx+1</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># idx가 홀수이면 idx-1</span>
</span></span><span style=display:flex><span>        seg[idx<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> seg[idx] <span style=color:#f92672>+</span> seg[idx<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        idx <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>       <span style=color:#75715e># idx = idx // 2</span>
</span></span></code></pre></div><p>&nbsp;&nbsp;
수정할 요소들은 항상 잎에 있다. 그 외의 노드들은 어떤 구간의 합을 저장하는 노드들이다. 또, 잎의 시작 위치는 기존에 n 개의 0으로 초기화 했던 것을 기억하면, n번 노드부터 잎이라는 것을 알 수 있다. 따라서, 입력된 arr의 인덱스에 n을 더해 수정해야할 요소를 찾고, 값을 val로 바꾼다.<figure><img loading=lazy src=3.png#center width=90%></figure></p><p>&nbsp;&nbsp;
그 다음, root를 향해 올라가면서 변경된 값을 부분합이 저장된 중간 노드들에도 반영한다. 여기서는 <code>xor</code> 비트 연산을 사용했는데, 이는 idx가 부모 기준으로 왼쪽인지 오른쪽인지 알수 없기 때문이다. 비트 연산을 통해 어느쪽이든 상관 없게 간결하게 일관된 방법을 이용할 수 있다.</p><p>&nbsp;&nbsp;
이진 트리에 성질에 의해 왼쪽 자식은 짝수, 오른쪽 자식은 홀수(왼쪽 +1)로 정해져 있다. 여기서 idx가 홀수이면 이진수로 표현했을 때, 마지막 비트가 1인데, 1과 xor연산을 하면 나머지 비트는 그대로고, 마지막 비트가 0으로 변해 -1 한 것과 같은 효과가 있다. 반대로, idx가 짝수이면 마지막 비트가 0이고, 1과 xor 연산을 하면 나머지 비트는 그대로고, 마지막 비트가 1로 바뀌어 +1과 같은 효과가 있다.<figure><img loading=lazy src=4.png#center width=100%></figure></p><br><h3 id=query>query<a hidden class=anchor aria-hidden=true href=#query>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#75715e># seg : 트리가 저장된 배열</span>
</span></span><span style=display:flex><span><span style=color:#75715e># n : 트리의 잎 수</span>
</span></span><span style=display:flex><span><span style=color:#75715e># l : 왼쪽 범위</span>
</span></span><span style=display:flex><span><span style=color:#75715e># r : 오른쪽 범위</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>query</span>(seg, n, l ,r):
</span></span><span style=display:flex><span>    l <span style=color:#f92672>+=</span> n          <span style=color:#75715e># 왼쪽 구간의 잎의 위치</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>+=</span> n          <span style=color:#75715e># 오른쪽 구간의 잎의 위치</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>      <span style=color:#75715e># 질의의 결과</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> l<span style=color:#f92672>&lt;</span>r:
</span></span><span style=display:flex><span>        <span style=color:#75715e># L이 홀수(right)이면 자신을 더하고, 옆 칸으로 넘어간다.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> l<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            result <span style=color:#f92672>+=</span> seg[l]
</span></span><span style=display:flex><span>            l <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># R이 홀수(right)이면 자신의 형제 (같은 부모의 왼쪽 자식)을 더한다.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> r<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>:     
</span></span><span style=display:flex><span>            r <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            result <span style=color:#f92672>+=</span> seg[r]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 각각 부모로 이동</span>
</span></span><span style=display:flex><span>        l <span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        r <span style=color:#f92672>&gt;&gt;=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span></code></pre></div><p>&nbsp;&nbsp;
전혀 직관적이지 않은 코드다. 특이한 점은 매 반복마다 홀수 일 때만 어떤 액션을 취해주는데, 왼쪽에서는 인덱스가 홀수인 자기 자신을 더하고, 오른쪽 구간에서는 항상 옆에 있는 같은 부모의 왼쪽 형제를 더한다는 것이다. 각각의 구간이 홀수, 짝수일 때를 각각 따져보자.</p><p>&nbsp;&nbsp;
우선, <code>왼쪽 닫힌 구간</code>이 홀수이면 어떤 노드의 <code>오른쪽 자식</code>이라는 말이 된다. 그 말은 왼쪽 형제는 범위에 포함되지 않는다는 소리이고, 왼쪽 자식의 값이 포함된 부모 역시 범위에 포함될 수 없다. 따라서, 자기 자신을 더하고, 1을 더해 범위를 한칸 이동시킨다.(범위를 좁힌다.) 여기서 1을 더해도 문제가 없는 이유는 같은 레벨(높이)에서 오른쪽은 항상 범위에 포함되기 때문이다.</p><p>&nbsp;&nbsp;
반대로 <code>왼쪽 닫힌 구간</code>이 짝수라면, 어떤 중간 노드의 <code>왼쪽 자식</code>이 된다. 이 경우에는 양쪽 형제들이 모두 범위에 포함되고, 그 값은 부모가 가지고 있기 때문에 부모쪽에서 계산하도록 아무 행동도 하지 않는다.</p><p>&nbsp;&nbsp;
<code>오른쪽 열린 구간</code>이 홀수이면 역시 어떤 노드의 <code>오른쪽 자식</code>이고, 항상 왼쪽 형제가 존재한다. 열린 구간이기 때문에 자신은 포함되어서는 안되지만, 형제는 범위에 포함되기 때문에 -1을 해 형제로 이동하고, 형제를 결과에 더한다.</p><p>&nbsp;&nbsp;
마지막으로 <code>오른쪽 열린 구간</code>이 짝수이면, 이쪽 트리는 구간에 포함되지 않는다고 볼 수 있다. 따라서, 아무 행동도 하지 않는다.</p><br><p><strong>예시</strong></p><p>&nbsp;&nbsp;
글로만 이루어진 설명으로는 이해하기 힘들어 예제를 준비했다. 기존에 예를 들었던 배열 <code>arr=[1,2,3,4,5]</code>로 트리를 생성하고, <code>qeury(seg,5, 0, 4)</code>라는 연산을 수행한다고 하자. arr의 인덱스 0, 1, 2, 3의 부분합인 <code>1+2+3+4=10</code>이 나와야 한다. 아래 트리 사진으로 더할 구간을 눈으로 확인할 수 있다.<figure><img loading=lazy src=5.png#center width=80%></figure></p><br><p>&nbsp;&nbsp;
코드를 따라가서, 가장 먼저 두 값에 n을 더해 잎의 위치를 찾으면 <code>왼쪽 닫힌 구간(L)</code>과 <code>오른쪽 열린 구간(R)</code>은 각각 <strong>5와 9</strong>가 된다. 두 구간 다 홀수이기 때문에 if에 걸린다. 그러면 <code>seg[5]</code>와 <code>seg[8]</code>의 값이 더해지고 범위는 <strong>6과 8</strong>이 된다. 반복의 마지막 연산으로 부모로 이동하면 <strong>3과 4</strong>가 된다.<figure><img loading=lazy src=6.png#center width=80%></figure></p><br><p>&nbsp;&nbsp;
그 다음 반복에서, <strong>3과 4 중</strong> <code>왼쪽 닫힌 구간(L)</code>은 자기의 범위를 포함하기 때문에 자신을 더한 다음, <strong>4</strong>로 이동하고 부모인 <strong>2</strong>로 이동한다. <code>오른쪽 열린 구간</code>은 짝수기 때문에 바로 부모인 <strong>2</strong>로 올라간다.<figure><img loading=lazy src=7.png#center width=80%></figure></p><br><p>&nbsp;&nbsp;
두 구간의 값이 같아 졌기 때문에 더 이상의 반복을 진행하지 않는다. 3번 5번 8번 인덱스를 더함으로 원하던 [0, 4) 구간의 합 10을 구할 수 있다.</p><br><h2 id=기타>기타<a hidden class=anchor aria-hidden=true href=#기타>#</a></h2><p>&nbsp;&nbsp;
해당 자료구조의 구현이 삽입 연산, Lazy Propagation 등 역시 구현할 수 있다고 한다. 그러나, 이러한 문제를 아직 풀지 않아서, 나중에 해당 문제들을 이해하게 된다면 추가로 정리하도록 하겠다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/algorithms/>algorithms</a></li><li><a href=https://green-21.github.io/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/study/%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4%EB%A5%BC%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90/><span class=title>« 이전 페이지</span><br><span>dx11로 테트리스를 만들어보자자</span>
</a><a class=next href=https://green-21.github.io/posts/cppstdlib/title/><span class=title>다음 페이지 »</span><br><span>C++ std library 시리즈</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2024 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>