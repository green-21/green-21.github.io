<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit) | gReen</title>
<meta name=keywords content="cpp,directx,graphics"><meta name=description content="dx11로 마우스를 드래그 해서 특정 시점을 바라보면서 궤도를 이동하는 카메라 구현하기"><meta name=author content><link rel=canonical href=https://green-21.github.io/posts/study/directx-orbit-camera/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/study/directx-orbit-camera/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit)"><meta property="og:description" content="dx11로 마우스를 드래그 해서 특정 시점을 바라보면서 궤도를 이동하는 카메라 구현하기"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/study/directx-orbit-camera/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-07T19:28:31+09:00"><meta property="article:modified_time" content="2024-02-07T19:28:31+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit)"><meta name=twitter:description content="dx11로 마우스를 드래그 해서 특정 시점을 바라보면서 궤도를 이동하는 카메라 구현하기"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"study","item":"https://green-21.github.io/posts/study/"},{"@type":"ListItem","position":3,"name":"Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit)","item":"https://green-21.github.io/posts/study/directx-orbit-camera/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit)","name":"Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit)","description":"dx11로 마우스를 드래그 해서 특정 시점을 바라보면서 궤도를 이동하는 카메라 구현하기","keywords":["cpp","directx","graphics"],"articleBody":"개요 마야나 블랜더, 혹은 언리얼 같은 3d 모델과 관련된 에디터에서는 특정한 물체를 바라보고 마우스를 드래그해서 해당 물체를 바라보는 방향으로 카메라가 가상의 구 궤적으로 카메라를 이동시킨다. 이러한 이동을 궤적(orbit)이나 아크볼(arcball) 카메라라고 하는 듯하다.\n굉장히 많은 소프트웨어에서 기본적인 기능으로 들어가 있는데, 나는 이 기능의 이름을 찾는 것도 생각보다 오래걸렸고, 이에 대한 자료도 찾기 쉽지 않았다. 특히 directx의 경우는 거의 없었다. 내가 구현한 방법이 정석적인 방법이 아닐지라도 정리하고 공유하는 것이 좋겠다 싶었다.\n과정 마우스의 드래그를 구현한다. 마우스의 변화량을 구한다. 카메라를 변화시킬 변환 행렬을 구한다. 카메라를 이동시킨다. 1. 드래그 구현하기 드래그를 구현하려면 우선 마우스의 이동과 클릭에 대한 정보를 얻어와야 한다. 마우스의 이동에는 WM_MOUSEMOVE, 마우스 버튼이 눌릴 시에는 WM_LBUTTONDOWN 눌린 버튼이 떼어졌을 때에는 WM_LBUTTONUP 메시지가 발생한다. 해당 메시지가 발생할 때마다 별도의 클래스 msgHandler가 행동을 처리하도록 구현했다.\n// 윈도우 메시지를 처리하는 함수의 일부 LRESULT WindowsWindow::MsgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) { switch (msg) { case WM_MOUSEMOVE: msgHandler-\u003eOnMouseMove(LOWORD(lParam), HIWORD(lParam)); break; case WM_LBUTTONDOWN: msgHandler-\u003eOnLeftMouseDown(); break; case WM_LBUTTONUP: msgHandler-\u003eOnLeftMouseUp(); break; ... } } 이제, 사용할 수 있는 이벤트를 바탕으로 드래그를 인식하도록 해야한다. 주의해야 할 것은 WM_LBUTTONDOWN는 마우스가 눌린 시점 한 번만 발생한다는 것이다. 따라서, i 번째 프레임에서 처음 마우스가 눌렸고, i+1 번째에도 여전히 마우스가 눌려 있다면 우리는 이것을 드래그 상태라고 가정할 것이다.\n이 정보를 바탕으로 마우스가 눌린 상태를 갖는 변수 isLeftMousePress와 마우스가 눌린 최초의 상태라는 것을 표현하는 변수 isLeftMouseDragStart를 사용할 것이다. isLeftMouseDragStart가 true면 마우스가 눌리기 시작한 것이고, isLeftMouseDragStart를 false로 만들어주면서 드래그 상태에 돌입하는 것이다.\n// 사용자 입력을 처리하는 클래스의 일부 class MessageHandler { public: void OnMouseMove(int x, int y) { mouseX = x; mouseY = y; } void OnLeftMouseDown() { if (!isLeftMousePress) { isLeftMouseDragStart = true; } isLeftMousePress = true; } void OnLeftMouseUp() { isLeftMousePress = false; isLeftMouseDragStart = false; } } 클릭과 드래그를 사용하는 코드는 다음과 같이 사용하면 된다.\n// 마우스가 눌린 상태인지 확인한다. if (msgHandler-\u003eIsLeftMousePress()) { // 드래그 여부를 확인한다. true면 드래그가 아님. if (msgHandler-\u003eIsLeftMouseDragStart()) { msgHandler-\u003eOffLeftMouseDragStart(); // false로 만들어 드래그 모드에 돌입 // // 초기 설정과 관련된 코드들 // return; } // // 드래그 중인 경우 처리될 코드들 // } 2. 마우스의 변화량 구하기 마우스 좌표의 변화량은 현재 좌표와 이전 좌표를 빼서 벡터로 표현할 수 있다. 또, 이 변화량은 한 프레임마다 새로 측정할 것이다. 따라서, 이전 프레임에서의 마우스의 위치를 기억할 필요가 있다. 지금 당장은 이전 마우스의 좌표를 사용할 일이 따로 더 없어서 static을 이용해서 저장했다. 프레임 당 얼마나 많이 움직였는지, 또, 몇 프레임 동안 움직였는지를 통해서 카메라의 이동 변위를 구할 수 있다.\nvoid MainApp::cameraUpdate(float dt) { static Vector2 prevCursorPos; // 이전 마우스의 좌표를 저장하는 변수 if (msgHandler-\u003eIsLeftMousePress()) { Vector2 currentCursorPos(0.0f); // 조표를 0~1로 정규화 currentCursorPos.x = float(msgHandler-\u003eGetMousePosX()) / screenWidth; currentCursorPos.y = float(msgHandler-\u003eGetMousePosY()) / screenHeight; if (msgHandler-\u003eIsLeftMouseDragStart()) { msgHandler-\u003eOffLeftMouseDragStart(); prevCursorPos = currentCursorPos; // 드래그 시작하기 전에 마우스의 좌표를 초기화 한다. return; } // 마우스의 이동에 따른 변화량을 표현하는 벡터 Vector2 delta = (prevCursorPos - currentCursorPos); // 변화량이 일정 수준보다 작으면 카메라를 이동시키지 않는다. if (delta.Length() \u003e= 1e-5) { delta.Normalize(); camera.Move(delta, dt); // 카메라 이동 함수에 변화량 벡터를 넘겨준다. prevCursorPos = currentCursorPos; // 마우스의 이전 좌표를 현재 좌표로 최신화 한다. } } } 3. 카메라 위치 이동시키기 코드를 구현하기 위해서는 3가지를 알아야 한다. 첫 번째는 이동을 위해 변환 행렬을 사용하는데, 정확히 이 행렬은 이동행렬이 아니라 회전행렬이라는 것이다. 두 번째는 회전을 마우스 x 이동, y 이동 두 가지로 요소로 나뉘어 2개의 축이 필요하다는 것이다. 마지막은 일관된 이동을 위해서는 회전축이 카메라의 위치에 따라서 변해야 한다는 것이다.\n3-1. 회전이 이동이다. 회전 행렬은 물체를 회전축 기준으로 특정한 각도만큼 회전시키는 변환행렬이다. 그런데, 이 회전 행렬이 물체의 중심에서 벗어나면 회전 축을 기준으로 원의 궤도를 도는 것이 된다. 즉, 물체를 이동시키고 회전을 적용하면 원의 궤도의 이동이 발생하는 것이다. 그림으로 보면 조금 더 명확하다. 회전축이 중심이면 오리는 회전만 한다. 오리를 회전축에서 이동시키면, 오리는 이동한 크기 만큼의 원을 그리면서 이동한다. 구현하고자 하는 것이 가상의 구 위를 움직이는 궤도 이동이기 때문에 이 회전을 통한 이동의 원리를 이용한다.\n카메라는 항상 같은 지점(원점)을 바라본다. 카메라는 원점과의 거리의 반지름을 가진 구 위를 움직이게 된다. 따라서, 회전은 원점을 기준으로 일어나고, 카메라는 원점과의 거리를 반지름으로 하는 구 위를 움직인다.\n3-2. 2개의 회전축 마우스의 변화량은 2개의 속성으로 이루어져 있다. 바로 x변화량과 y 변화량이다. 마우스가 x 좌표로 얼만큼 이동했느냐에 따라서 화면은 좌우로 이동한다. 마우스의 y 좌표가 얼만큼 이동했느냐에 따라서 화면은 위 아래로 이동한다. 하나 처럼 보이는 움직임이 2개의 회전의 합으로 나타난다는 것이고, 이는 두번의 회전이 일어남과 2개의 회전축이 필요함을 알 수 있다. 두 회전을 별도의 회전축을 이용해 별도의 변환 행렬을 구할 것이다.\n3-3. 회전축 설정하기 회전축을 설정하기 위해서는 카메라의 이동 궤적에 대해서 조금 더 자세하게 살펴볼 필요가 있다. 우선 좌우 이동은 카메라가 어떤 고도에 위치하느냐에 따라서 궤적의 크기가 달라지지만, 달라진 궤적 모두 같은 축을 원 운동하는 것을 알 수 있다. 이것은 월드 좌표 내에서 위 방향으로 생각할 수 있고, 구체적인 값으로는 (0,1,0)으로 고정된 축을 사용한다. 다만, 한 가지 추가적으로 고려해야할 사항이 있다. 그것은 바로 상하 움직임으로 인해서 위 아래가 바뀌어 회전이 반대로 일어나는 경우이다. 회전 축을 반대인 (0, -1, 0)으로 바꿔줘야 한다.\n상하 움직임은 카메라의 위치마다 회전 축이 달라지기 때문에 좌우보다 까다롭다. 카메라가 원의 어느 각도에 위치하느냐에 따라서 축의 위치가 달라진다.\n위에서 구를 내려다 보면 위 사진과 같은데, 카메라의 오른쪽 방향과 평행한 회전축이 만들어지는 것을 직관적으로 확인할 수 있다.\n정리하면 다음과 같다.\n이동은 두 개의 회전으로 이루어져 있다. x 변화량을 이용하는 좌우 이동은 y축 방향을 회전축으로 이용한다. y 변화량을 이용하는 상하 이동은 현재 카메라의 오른쪽 방향을 회전축으로 이용한다. 이 내용을 Move함수에 적용해서 이동 구현을 완성하자.\nvoid Camera::Move(Vector2 delta, float dt) { // 위 벡터 const Vector3 yAxis{0.0f, 1.0f, 0.0f}; delta = delta * dt * orbitSpeed; // 이동 거리 계산 // 좌우 이동 반전에 대한 처리 if (yDir * up.Dot(yAxis) \u003e 0) { yDir = -yDir; } // 좌우 이동에 대한 회전 행렬 // 회전축 y(0,1,0)과 x 변화량 사용 (위 방향에 따라 x 변화량을 음수화) Matrix yawMatrix = Matrix::CreateFromQuaternion( Quaternion::CreateFromAxisAngle(yAxis, yDir * delta.x)); // 상하 이동에 대한 회전 행렬 // 회전축 오른쪽 벡터와 y 변화량 사용. Matrix pitchMatrix = Matrix::CreateFromQuaternion( Quaternion::CreateFromAxisAngle(right, -delta.y)); // 카메라 좌표에 대한 변환 적용 pos = Vector3::Transform(pos, pitchMatrix * yawMatrix); right = Vector3::Transform(right, yawMatrix); up = right.Cross(pos); up.Normalize(); } 마치며 간략하게 정리만 하고 싶었는데, 더 기초적인 부분까지 설명해서 넣는게 나중에 도움이 되지 않을까? 더 자세하게 설명하는게 좋지 않을까? 라는 생각 때문에 길어지고, 길어지니까 힘빠지고 이도저도 아닌 글이 되어버린 느낌이다. 3차원을 그림으로 표현한다고 고생했는데, 이 글이 쓸모가 있는 순간이 왔으면 좋겠다.\n구현한 내용의 일부는 직관에 의존한 구현이었기 때문에 엄밀하게 계산하기 위해서는 증명이 필요할지도 모르겠다. 다만, 현재 충분히 잘 작동하는 모습에서 충분히 만족감을 느낀다. 어디에나 있는 간단한 기능을 직접 구현하려면 생각보다 쉽지 않구나를 항상 느낀다.\n참고 자료 A Slice Of Rendering - How to implement a simple Arcball Camera honglab - 그래픽스 새싹코스 ","wordCount":"1080","inLanguage":"ko","datePublished":"2024-02-07T19:28:31+09:00","dateModified":"2024-02-07T19:28:31+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/study/directx-orbit-camera/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Maya, Blender 같은 카메라 이동 구현하기 (arcball, orbit)</h1><div class=post-meta><span title='2024-02-07 19:28:31 +0900 +0900'>2월 7, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>목차</span></summary><div class=inner><ul><li><a href=#%ea%b0%9c%ec%9a%94 aria-label=개요>개요</a></li><li><a href=#%ea%b3%bc%ec%a0%95 aria-label=과정>과정</a></li><li><a href=#1-%eb%93%9c%eb%9e%98%ea%b7%b8-%ea%b5%ac%ed%98%84%ed%95%98%ea%b8%b0 aria-label="1. 드래그 구현하기">1. 드래그 구현하기</a></li><li><a href=#2-%eb%a7%88%ec%9a%b0%ec%8a%a4%ec%9d%98-%eb%b3%80%ed%99%94%eb%9f%89-%ea%b5%ac%ed%95%98%ea%b8%b0 aria-label="2. 마우스의 변화량 구하기">2. 마우스의 변화량 구하기</a></li><li><a href=#3-%ec%b9%b4%eb%a9%94%eb%9d%bc-%ec%9c%84%ec%b9%98-%ec%9d%b4%eb%8f%99%ec%8b%9c%ed%82%a4%ea%b8%b0 aria-label="3. 카메라 위치 이동시키기">3. 카메라 위치 이동시키기</a><ul><li><a href=#3-1-%ed%9a%8c%ec%a0%84%ec%9d%b4-%ec%9d%b4%eb%8f%99%ec%9d%b4%eb%8b%a4 aria-label="3-1. 회전이 이동이다.">3-1. 회전이 이동이다.</a></li><li><a href=#3-2-2%ea%b0%9c%ec%9d%98-%ed%9a%8c%ec%a0%84%ec%b6%95 aria-label="3-2. 2개의 회전축">3-2. 2개의 회전축</a></li><li><a href=#3-3-%ed%9a%8c%ec%a0%84%ec%b6%95-%ec%84%a4%ec%a0%95%ed%95%98%ea%b8%b0 aria-label="3-3. 회전축 설정하기">3-3. 회전축 설정하기</a></li></ul></li><li><a href=#%eb%a7%88%ec%b9%98%eb%a9%b0 aria-label=마치며>마치며</a></li><li><a href=#%ec%b0%b8%ea%b3%a0-%ec%9e%90%eb%a3%8c aria-label="참고 자료">참고 자료</a></li></ul></div></details></div><div class=post-content><h2 id=개요>개요<a hidden class=anchor aria-hidden=true href=#개요>#</a></h2><p><figure><img loading=lazy src=1.gif#center width=375></figure>&nbsp;&nbsp;
마야나 블랜더, 혹은 언리얼 같은 3d 모델과 관련된 에디터에서는 <strong>특정한 물체를 바라보고 마우스를 드래그해서 해당 물체를 바라보는 방향으로 카메라가 가상의 구 궤적으로 카메라를 이동</strong>시킨다. 이러한 이동을 <code>궤적(orbit)</code>이나 <code>아크볼(arcball)</code> 카메라라고 하는 듯하다.</p><p>&nbsp;&nbsp;
굉장히 많은 소프트웨어에서 기본적인 기능으로 들어가 있는데, 나는 이 기능의 이름을 찾는 것도 생각보다 오래걸렸고, 이에 대한 자료도 찾기 쉽지 않았다. 특히 directx의 경우는 거의 없었다. 내가 구현한 방법이 정석적인 방법이 아닐지라도 정리하고 공유하는 것이 좋겠다 싶었다.</p>&nbsp;<h2 id=과정>과정<a hidden class=anchor aria-hidden=true href=#과정>#</a></h2><ol><li>마우스의 드래그를 구현한다.</li><li>마우스의 변화량을 구한다.</li><li>카메라를 변화시킬 변환 행렬을 구한다.</li><li>카메라를 이동시킨다.</li></ol>&nbsp;<h2 id=1-드래그-구현하기>1. 드래그 구현하기<a hidden class=anchor aria-hidden=true href=#1-드래그-구현하기>#</a></h2><p>&nbsp;&nbsp;
드래그를 구현하려면 우선 마우스의 이동과 클릭에 대한 정보를 얻어와야 한다. 마우스의 이동에는 <code>WM_MOUSEMOVE</code>, 마우스 버튼이 눌릴 시에는 <code>WM_LBUTTONDOWN</code> 눌린 버튼이 떼어졌을 때에는 <code>WM_LBUTTONUP</code> 메시지가 발생한다. 해당 메시지가 발생할 때마다 별도의 클래스 msgHandler가 행동을 처리하도록 구현했다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// 윈도우 메시지를 처리하는 함수의 일부
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>LRESULT WindowsWindow<span style=color:#f92672>::</span>MsgProc(HWND hWnd, UINT msg, WPARAM wParam,
</span></span><span style=display:flex><span>                               LPARAM lParam) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (msg) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> WM_MOUSEMOVE:
</span></span><span style=display:flex><span>        msgHandler<span style=color:#f92672>-&gt;</span>OnMouseMove(LOWORD(lParam), HIWORD(lParam));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> WM_LBUTTONDOWN:
</span></span><span style=display:flex><span>        msgHandler<span style=color:#f92672>-&gt;</span>OnLeftMouseDown();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> WM_LBUTTONUP:
</span></span><span style=display:flex><span>        msgHandler<span style=color:#f92672>-&gt;</span>OnLeftMouseUp();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div>&nbsp;<p>&nbsp;&nbsp;
이제, 사용할 수 있는 이벤트를 바탕으로 드래그를 인식하도록 해야한다. 주의해야 할 것은 <strong><code>WM_LBUTTONDOWN</code>는 마우스가 눌린 시점 한 번만 발생한다는 것</strong>이다. 따라서, i 번째 프레임에서 처음 마우스가 눌렸고, i+1 번째에도 여전히 마우스가 눌려 있다면 우리는 이것을 드래그 상태라고 가정할 것이다.</p><p>&nbsp;&nbsp;
이 정보를 바탕으로 마우스가 눌린 상태를 갖는 변수 <code>isLeftMousePress</code>와 마우스가 눌린 최초의 상태라는 것을 표현하는 변수 <code>isLeftMouseDragStart</code>를 사용할 것이다. isLeftMouseDragStart가 true면 마우스가 눌리기 시작한 것이고, isLeftMouseDragStart를 false로 만들어주면서 드래그 상태에 돌입하는 것이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 사용자 입력을 처리하는 클래스의 일부
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageHandler</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> OnMouseMove(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) {
</span></span><span style=display:flex><span>        mouseX <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        mouseY <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>OnLeftMouseDown</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isLeftMousePress) {
</span></span><span style=display:flex><span>            isLeftMouseDragStart <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        isLeftMousePress <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>OnLeftMouseUp</span>() {
</span></span><span style=display:flex><span>        isLeftMousePress <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        isLeftMouseDragStart <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&nbsp;&nbsp;&nbsp;
클릭과 드래그를 사용하는 코드는 다음과 같이 사용하면 된다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// 마우스가 눌린 상태인지 확인한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (msgHandler<span style=color:#f92672>-&gt;</span>IsLeftMousePress()) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 드래그 여부를 확인한다. true면 드래그가 아님.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (msgHandler<span style=color:#f92672>-&gt;</span>IsLeftMouseDragStart()) {
</span></span><span style=display:flex><span>        msgHandler<span style=color:#f92672>-&gt;</span>OffLeftMouseDragStart();  <span style=color:#75715e>// false로 만들어 드래그 모드에 돌입
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 초기 설정과 관련된 코드들
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 드래그 중인 경우 처리될 코드들
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><br>&nbsp;</p><h2 id=2-마우스의-변화량-구하기>2. 마우스의 변화량 구하기<a hidden class=anchor aria-hidden=true href=#2-마우스의-변화량-구하기>#</a></h2><p>&nbsp;&nbsp;
마우스 좌표의 변화량은 <strong>현재 좌표와 이전 좌표를 빼서 벡터로 표현할 수 있다.</strong> 또, 이 변화량은 한 프레임마다 새로 측정할 것이다. 따라서, 이전 프레임에서의 마우스의 위치를 기억할 필요가 있다. 지금 당장은 이전 마우스의 좌표를 사용할 일이 따로 더 없어서 static을 이용해서 저장했다. 프레임 당 얼마나 많이 움직였는지, 또, 몇 프레임 동안 움직였는지를 통해서 카메라의 이동 변위를 구할 수 있다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> MainApp<span style=color:#f92672>::</span>cameraUpdate(<span style=color:#66d9ef>float</span> dt) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Vector2 prevCursorPos;    <span style=color:#75715e>// 이전 마우스의 좌표를 저장하는 변수
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (msgHandler<span style=color:#f92672>-&gt;</span>IsLeftMousePress()) {
</span></span><span style=display:flex><span>        Vector2 <span style=color:#a6e22e>currentCursorPos</span>(<span style=color:#ae81ff>0.0f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 조표를 0~1로 정규화
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        currentCursorPos.x <span style=color:#f92672>=</span> <span style=color:#66d9ef>float</span>(msgHandler<span style=color:#f92672>-&gt;</span>GetMousePosX()) <span style=color:#f92672>/</span> screenWidth;
</span></span><span style=display:flex><span>        currentCursorPos.y <span style=color:#f92672>=</span> <span style=color:#66d9ef>float</span>(msgHandler<span style=color:#f92672>-&gt;</span>GetMousePosY()) <span style=color:#f92672>/</span> screenHeight;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (msgHandler<span style=color:#f92672>-&gt;</span>IsLeftMouseDragStart()) {
</span></span><span style=display:flex><span>            msgHandler<span style=color:#f92672>-&gt;</span>OffLeftMouseDragStart();
</span></span><span style=display:flex><span>            prevCursorPos <span style=color:#f92672>=</span> currentCursorPos;   <span style=color:#75715e>// 드래그 시작하기 전에 마우스의 좌표를 초기화 한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 마우스의 이동에 따른 변화량을 표현하는 벡터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Vector2 delta <span style=color:#f92672>=</span> (prevCursorPos <span style=color:#f92672>-</span> currentCursorPos);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 변화량이 일정 수준보다 작으면 카메라를 이동시키지 않는다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (delta.Length() <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1e-5</span>) {
</span></span><span style=display:flex><span>            delta.Normalize();
</span></span><span style=display:flex><span>            camera.Move(delta, dt); <span style=color:#75715e>// 카메라 이동 함수에 변화량 벡터를 넘겨준다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            prevCursorPos <span style=color:#f92672>=</span> currentCursorPos;  <span style=color:#75715e>// 마우스의 이전 좌표를 현재 좌표로 최신화 한다.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><br>&nbsp;</p><h2 id=3-카메라-위치-이동시키기>3. 카메라 위치 이동시키기<a hidden class=anchor aria-hidden=true href=#3-카메라-위치-이동시키기>#</a></h2><p>&nbsp;&nbsp;
코드를 구현하기 위해서는 3가지를 알아야 한다. 첫 번째는 이동을 위해 변환 행렬을 사용하는데, 정확히 이 행렬은 <strong>이동행렬이 아니라 회전행렬이라는 것</strong>이다. 두 번째는 회전을 마우스 x 이동, y 이동 두 가지로 요소로 나뉘어 <strong>2개의 축이 필요하다는 것</strong>이다. 마지막은 일관된 이동을 위해서는 <strong>회전축이 카메라의 위치에 따라서 변해야 한다는 것</strong>이다.</p><h3 id=3-1-회전이-이동이다>3-1. 회전이 이동이다.<a hidden class=anchor aria-hidden=true href=#3-1-회전이-이동이다>#</a></h3><p>&nbsp;&nbsp;
회전 행렬은 물체를 회전축 기준으로 특정한 각도만큼 회전시키는 변환행렬이다. 그런데, 이 회전 행렬이 물체의 중심에서 벗어나면 회전 축을 기준으로 원의 궤도를 도는 것이 된다. 즉, 물체를 이동시키고 회전을 적용하면 원의 궤도의 이동이 발생하는 것이다. 그림으로 보면 조금 더 명확하다.<figure><img loading=lazy src=2.png#center width=400px></figure>회전축이 중심이면 오리는 회전만 한다.<figure><img loading=lazy src=3.png#center></figure>오리를 회전축에서 이동시키면, 오리는 이동한 크기 만큼의 원을 그리면서 이동한다. 구현하고자 하는 것이 가상의 구 위를 움직이는 궤도 이동이기 때문에 이 회전을 통한 이동의 원리를 이용한다.</p><p>&nbsp;&nbsp;
카메라는 항상 같은 지점(원점)을 바라본다. 카메라는 원점과의 거리의 반지름을 가진 구 위를 움직이게 된다. 따라서, 회전은 원점을 기준으로 일어나고, 카메라는 원점과의 거리를 반지름으로 하는 구 위를 움직인다.</p><h3 id=3-2-2개의-회전축>3-2. 2개의 회전축<a hidden class=anchor aria-hidden=true href=#3-2-2개의-회전축>#</a></h3><p>&nbsp;&nbsp;
마우스의 변화량은 2개의 속성으로 이루어져 있다. 바로 x변화량과 y 변화량이다. 마우스가 x 좌표로 얼만큼 이동했느냐에 따라서 화면은 좌우로 이동한다. 마우스의 y 좌표가 얼만큼 이동했느냐에 따라서 화면은 위 아래로 이동한다. 하나 처럼 보이는 움직임이 2개의 회전의 합으로 나타난다는 것이고, 이는 두번의 회전이 일어남과 2개의 회전축이 필요함을 알 수 있다. 두 회전을 별도의 회전축을 이용해 별도의 변환 행렬을 구할 것이다.</p><h3 id=3-3-회전축-설정하기>3-3. 회전축 설정하기<a hidden class=anchor aria-hidden=true href=#3-3-회전축-설정하기>#</a></h3><p>&nbsp;&nbsp;
회전축을 설정하기 위해서는 카메라의 이동 궤적에 대해서 조금 더 자세하게 살펴볼 필요가 있다.<figure><img loading=lazy src=4.png#center width=375px></figure>&nbsp;&nbsp;
우선 <strong>좌우 이동</strong>은 카메라가 어떤 고도에 위치하느냐에 따라서 궤적의 크기가 달라지지만, 달라진 궤적 <strong>모두 같은 축을 원 운동</strong>하는 것을 알 수 있다. 이것은 월드 좌표 내에서 위 방향으로 생각할 수 있고, 구체적인 값으로는 <code>(0,1,0)</code>으로 고정된 축을 사용한다. 다만, 한 가지 추가적으로 고려해야할 사항이 있다.<figure><img loading=lazy src=5.png#center width=375px></figure>&nbsp;&nbsp;
그것은 바로 상하 움직임으로 인해서 <strong>위 아래가 바뀌어 회전이 반대로 일어나는 경우</strong>이다. 회전 축을 반대인 <code>(0, -1, 0)</code>으로 바꿔줘야 한다.</p>&nbsp;<p><figure><img loading=lazy src=6.png#center width=375px></figure>&nbsp;&nbsp;
상하 움직임은 카메라의 위치마다 회전 축이 달라지기 때문에 좌우보다 까다롭다. 카메라가 원의 어느 각도에 위치하느냐에 따라서 축의 위치가 달라진다.</p><p><figure><img loading=lazy src=7.png#center width=375px></figure>&nbsp;&nbsp;
위에서 구를 내려다 보면 위 사진과 같은데, 카메라의 오른쪽 방향과 평행한 회전축이 만들어지는 것을 직관적으로 확인할 수 있다.</p><p>&nbsp;&nbsp;
정리하면 다음과 같다.</p><ul><li>이동은 두 개의 회전으로 이루어져 있다.</li><li>x 변화량을 이용하는 좌우 이동은 y축 방향을 회전축으로 이용한다.</li><li>y 변화량을 이용하는 상하 이동은 현재 카메라의 오른쪽 방향을 회전축으로 이용한다.</li></ul><p>&nbsp;&nbsp;
이 내용을 Move함수에 적용해서 이동 구현을 완성하자.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>void</span> Camera<span style=color:#f92672>::</span>Move(Vector2 delta, <span style=color:#66d9ef>float</span> dt) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 위 벡터
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> Vector3 yAxis{<span style=color:#ae81ff>0.0f</span>, <span style=color:#ae81ff>1.0f</span>, <span style=color:#ae81ff>0.0f</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    delta <span style=color:#f92672>=</span> delta <span style=color:#f92672>*</span> dt <span style=color:#f92672>*</span> orbitSpeed; <span style=color:#75715e>// 이동 거리 계산
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 좌우 이동 반전에 대한 처리
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (yDir <span style=color:#f92672>*</span> up.Dot(yAxis) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        yDir <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>yDir;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 좌우 이동에 대한 회전 행렬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 회전축 y(0,1,0)과 x 변화량 사용 (위 방향에 따라 x 변화량을 음수화)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Matrix yawMatrix <span style=color:#f92672>=</span> Matrix<span style=color:#f92672>::</span>CreateFromQuaternion(
</span></span><span style=display:flex><span>        Quaternion<span style=color:#f92672>::</span>CreateFromAxisAngle(yAxis, yDir <span style=color:#f92672>*</span> delta.x));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 상하 이동에 대한 회전 행렬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 회전축 오른쪽 벡터와 y 변화량 사용.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Matrix pitchMatrix <span style=color:#f92672>=</span> Matrix<span style=color:#f92672>::</span>CreateFromQuaternion(
</span></span><span style=display:flex><span>        Quaternion<span style=color:#f92672>::</span>CreateFromAxisAngle(right, <span style=color:#f92672>-</span>delta.y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 카메라 좌표에 대한 변환 적용
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pos <span style=color:#f92672>=</span> Vector3<span style=color:#f92672>::</span>Transform(pos, pitchMatrix <span style=color:#f92672>*</span> yawMatrix);
</span></span><span style=display:flex><span>    right <span style=color:#f92672>=</span> Vector3<span style=color:#f92672>::</span>Transform(right, yawMatrix);
</span></span><span style=display:flex><span>    up <span style=color:#f92672>=</span> right.Cross(pos);
</span></span><span style=display:flex><span>    up.Normalize();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><br>&nbsp;</p><h2 id=마치며>마치며<a hidden class=anchor aria-hidden=true href=#마치며>#</a></h2><p>&nbsp;&nbsp;
간략하게 정리만 하고 싶었는데, 더 기초적인 부분까지 설명해서 넣는게 나중에 도움이 되지 않을까? 더 자세하게 설명하는게 좋지 않을까? 라는 생각 때문에 길어지고, 길어지니까 힘빠지고 이도저도 아닌 글이 되어버린 느낌이다. 3차원을 그림으로 표현한다고 고생했는데, 이 글이 쓸모가 있는 순간이 왔으면 좋겠다.</p><p>&nbsp;&nbsp;
구현한 내용의 일부는 직관에 의존한 구현이었기 때문에 엄밀하게 계산하기 위해서는 증명이 필요할지도 모르겠다. 다만, 현재 충분히 잘 작동하는 모습에서 충분히 만족감을 느낀다. 어디에나 있는 간단한 기능을 직접 구현하려면 생각보다 쉽지 않구나를 항상 느낀다.</p>&nbsp;<h2 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h2><ul><li><a href=https://asliceofrendering.com/page3/>A Slice Of Rendering - How to implement a simple Arcball Camera</a></li><li><a href=https://honglab.co.kr>honglab - 그래픽스 새싹코스</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/cpp/>cpp</a></li><li><a href=https://green-21.github.io/tags/directx/>directx</a></li><li><a href=https://green-21.github.io/tags/graphics/>graphics</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/study/ceil-divide/><span class=title>« 이전 페이지</span><br><span>어떤 나눗셈에서 쉽게 올림하기</span>
</a><a class=next href=https://green-21.github.io/posts/study/%ED%85%8C%ED%8A%B8%EB%A6%AC%EC%8A%A4%EB%A5%BC%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90/><span class=title>다음 페이지 »</span><br><span>dx11로 테트리스를 만들어보자자</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2024 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>