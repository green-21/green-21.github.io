<!doctype html><html lang=ko dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>객체지향적으로 | gReen</title>
<meta name=keywords content="java,design"><meta name=description content="조금 더 객체지향적으로 수정해보기"><meta name=author content="green-21"><link rel=canonical href=https://green-21.github.io/posts/study/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://green-21.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://green-21.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://green-21.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://green-21.github.io/apple-touch-icon.png><link rel=mask-icon href=https://green-21.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ko href=https://green-21.github.io/posts/study/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-85B2L7QDNR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-85B2L7QDNR",{anonymize_ip:!1})}</script><meta property="og:title" content="객체지향적으로"><meta property="og:description" content="조금 더 객체지향적으로 수정해보기"><meta property="og:type" content="article"><meta property="og:url" content="https://green-21.github.io/posts/study/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-29T16:07:14+09:00"><meta property="article:modified_time" content="2022-01-29T16:07:14+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="객체지향적으로"><meta name=twitter:description content="조금 더 객체지향적으로 수정해보기"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://green-21.github.io/posts/"},{"@type":"ListItem","position":2,"name":"study","item":"https://green-21.github.io/posts/study/"},{"@type":"ListItem","position":3,"name":"객체지향적으로","item":"https://green-21.github.io/posts/study/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"객체지향적으로","name":"객체지향적으로","description":"조금 더 객체지향적으로 수정해보기","keywords":["java","design"],"articleBody":"배경 과제로 제출했던 코드 중 하나를 조금 더 객체지향적으로 변경하고 이를 설명하는 것을 주제로 학교 자바 수업의 기말 발표를 한 적이 있다. 과거 엉망인 코드를 짜면서 느꼈던 불편함과 그 당시 클린코드를 읽으면서 코드의 퀄리티와 객체지향에 대한 관심이 많아졌고, 이를 실습해보고 싶어 해당 주제를 선정했다. 그 때의 내용을 간단하게 기록하고자 한다.\n문제 사용한 예제는 명품 자바 에센셜의 5장 실습문제 6번이다.\n💡 [실습문제 6번] 간단한 그래픽 편집기를 만들어보자. 본문 5.6절의 메소드 오버라이딩과 5.7절의 추상 클래스의 설명 중에 Line, Rect, Circle 클래스 코드를 활용하여, 다음 실행 결과처럼 동작하는 프로그램을 작성하라.\n삽입(1), 삭제(2), 모두보기(3), 종료(4) \u003e\u003e 1 도형 종류 LINE(1), RECT(2), CIRCLE(3) \u003e\u003e 1 삽입(1), 삭제(2), 모두보기(3), 종료(4) \u003e\u003e 1 도형 종류 LINE(1), RECT(2), CIRCLE(3) \u003e\u003e 3 삽입(1), 삭제(2), 모두보기(3), 종료(4) \u003e\u003e 3 Line Circle 삽입(1), 삭제(2), 모두보기(3), 종료(4) \u003e\u003e 2 삭제할 도형 위치 \u003e\u003e 3 삭제할 수 없습니다. 삽입(1), 삭제(2), 모두보기(3), 종료(4) \u003e\u003e 4 프로그램을 종료합니다... 사실 객체지향을 설명하는 단원의 문제여서, 문제의 요지도 다형성을 구현하는 것이었다. Draw()라는 추상함수를 갖는 추상 클래스 Shape를 Line, Rect, Circle로 구현하고, Shape 객체로 이를 업캐스팅해서 오버라딩된 함수를 호출하는 것을 구현하는 것이 문제의 정답이라고 할 수 있다.\n풀이 shape.java\nabstract class Shape { public abstract void draw(); } class Line extends Shape { @Override public void draw() { System.out.println(\"Line\"); } } class Rect extends Shape { @Override public void draw() { System.out.println(\"Rect\"); } } class Circle extends Shape { @Override public void draw() { System.out.println(\"Circle\"); } } Main.java\nimport java.util.*; public class Main { public static void main(String[] args) { var scanner = new Scanner(System.in); var shapes = new Vector\u003cShape\u003e(); int option = -1; do { System.out.println(\"삽입(1), 삭제(2), 모두보기(3), 종료(4) \u003e\u003e \"); option = scanner.nextInt(); switch(option) { case 1: System.out.println(\"도형 종류 Line(1), Rect(2), Circle(3) \u003e\u003e \"); int op2 = scanner.nextInt(); switch(op2) { case 1: shapes.add(new Line()); break; case 2: shapes.add(new Rect()); break; case 3: shapes.add(new Circle()); break; } break; case 2: System.out.println(\"삭제할 도형의 위치\u003e\u003e \"); int index = scanner.nextInt(); shapes.remove(index); break; case 3: var itor = shapes.iterator(); while(itor.hasNext()) { var obj = itor.next(); obj.draw(); } } } while(option != 4); } } 예외 처리 같은 더 신경써줘야 할 것들이 있지만 일단은 생략했다.\n더 생각해볼 문제 반복되는 동일 구조 다만, 위 코드는 불편함이 존재한다. 선택지를 구현하는 코드는 동일한 구조가 반복된다. 그러나, 이를 반복해서 작성하고 있다. 즉, DRY하지 않다! 만약 선택지가 늘어난다면 늘어내는대로 선택지를 중첩해서 추가 작성해야 한다. 아마 굉장히 꼴뵈기 힘든 코드가 만들어 질 것이다. 위의 코드도 벌써 도형을 삽입할 때, 2개의 swtich문이 반복해서 나타난다.\n절차적인 코드 main 함수에 모든 코드가 담겨 있다는 것이 문제가 될 수도 있다. 클린 코드에 따르면 함수와 클래스는 최대한 작고 하나의 책임만을 가져야 한다고 한다. 그러나 지금 main에서 모든 일을 담당하고 있다. 이를 분리할 필요가 있다.\n객체지향으로 1. Vector와 Scanner 클래스에 대한 Wrapper 클린 코드에서 외부 라이브러리를 사용하게 될 때, 외부 라이브러리의 변화가 미치는 정도를 줄이기 위해서 그 라이브러리의 클래스들을 한 번 감싸 경계를 구분해야 한다고 했다. 그래서, 앞서 사용한 Vector를 감싼 ShapeManager와 Scanner를 감싼 Prompt 클래스를 만든다.\nShapeManager\nShapeManager는 특히 일급 컬렉션이라고 하는 것 같은데, 이름이 멋있는 것 치고는 특별한 의미가 있다고 생각하지는 않는다. 다만, 뭔가 조금 더 기능 단위를 확실하게 구분하는 느낌이다. 그 외에는 어떤 데이터 객체에 특별한 이름을 붙인 것이 조금 더 특별하다면 특별하다고 할 수 있을 것 같다. import java.util.Iterator; import java.util.Vector; public class ShapeManager { Vector\u003cShape\u003e store; public void insert(Shape s) { store.add(s); } public int delete(int index) { try { store.remove(index); } catch (ArrayIndexOutOfBoundsException e) { return -1; } return 0; } public void printAll() { Iterator\u003cShape\u003e iter = store.iterator(); while(iter.hasNext()) iter.next().draw(); } } Prompt\nPrompt의 경우 더 좋은 클래스 이름이 있을 것 같지만 영어 능력의 한계로 Prompt라고 했다. import java.util.InputMismatchException; import java.util.Scanner; public class Prompt { Scanner scanner; public Prompt() { scanner = new Scanner(System.in); } public int prompt() { int n; try { n = scanner.nextInt(); } catch(InputMismatchException e) { n = -1; } return n; } public void close() { scanner.close(); } } 이렇게 하면, 변경이 존재할 때, 대응하기가 쉬워진다. 해당 클래스만 변경해주면 되니까 말이다. Prompt의 경우 만약 시스템을 cui에서 gui로 변경하거나 유사한 변경사항이 있을 때, 인터페이스만 잘 설계했다면, Prompt만 수정하고 나머지 Prompt를 사용하는 코드는 수정이 거의 필요 없을 것이다. 이를 캡슐화와 정보 은닉의 장점이라고 할 수 있다.\n2. 다형성을 이용해 구조 변경하기 한 선택지 분기마다 하나의 클래스를 작성한다. 각 클래스는 하나의 추상클래스를 상속 받는다. 이를 **State**이라고 이름 붙였고, 이를 구현하는 클래스의 이름 끝에도 State이라는 단어를 붙였다. 이것 역시 State보다 더 좋은 이름이 있을 거라고 생각하지만, 역시 역량이 부족했다.\n각 클래스가 구현해야하는 것들은 다음과 같다.\n출력 메시지 해당 분기가 입력을 요구하는지 여부 분기에서 처리해야할 메인 로직 State\npublic abstract class State { protected boolean prompt; public State(boolean prompt) { this.prompt = prompt; } public boolean isNeedPrompt() { return prompt; } public abstract void printMsg(); public abstract State process(int input, ShapeManager sm); } MainState\nclass MainState extends State { public MainState() { super(true); } @Override public void printMsg() { System.out.print(\"삽입(1), 삭제(2), 모두 보기(3), 종료(4)\"); } @Override public State process(int input, ShapeManager sm) { switch(input) { case 1: return new InsertState(); case 2: return new DeleteState(); case 3: sm.printAll(); break; case 4: return null; default : System.out.println(\"잘못된 선택지입니다. 다시 선택해주세요.\"); } return this; } } InsertState\npublic class InsertState extends State { public InsertState() { super(true); } @Override public void printMsg() { System.out.print(\"도형 종류 Line(1), Rect(2), Circle(3) \u003e\u003e\"); } @Override public State process(int input, ShapeManager sm) { switch(input) { case 1: sm.insert(new Line()); break; case 2: sm.insert(new Rect()); break; case 3: sm.insert(new Circle()); break; default : System.out.println(\"잘못된 선택지입니다. 다시선택하세요.\"); return this; } return new MainState(); } } DeleteState\npublic class DeleteState extends State { public DeleteState() { super(true); } @Override public void printMsg() { System.out.print(\"삭제할 도형의 위치 \u003e\u003e\"); } @Override public State process(int input, ShapeManager sm) { if(!sm.delete(input)) System.out.println(\"삭제할 수 없습니다.\"); return new MainState(); } } 이제 선택지가 더 필요한 경우에는 State 클래스를 하나 더 만들고, 다른 클래스와 연관시키기만 하면 된다. 다만, 개선사항이 있다면, 해당 구조는 클래스간 연관관계를 잘 살펴봐야 한다는 것이다. 그리고 본질적으로 스위치를 없애고 싶었지만 그러지 못했다.\n3. main에서 조립 GraphicEditor - Main\npublic class GraphicEditor { public static void main(String[] args) { Prompt prompt = new Prompt(); ShapeManager shapes = new ShapeManager(); State state = new MainState(); while(state != null) { int inputValue = -1; state.printMsg(); if(state.isNeedPrompt()) inputValue = prompt.prompt(); var nextState = state.process(inputValue, shapes); state = nextState; } prompt.close(); } } main에서는 작성했던 클래스들을 조립했다.\n정확하게 메인 루프에는 선택 안내 메시지 출력(printMsg()) → 선택지 입력(prompt()) → 선택지에 따른 행동(process())이라는 한가지 구조만 눈에 보인다. 다형성을 이용해서 동일한 구조에서 다른 행동을 할 수 있게 되었다.\n다른 선택지를 추가해야할 때에는 클래스를 작성하면 된다.\n4. 클래스 다이어그램 코드들을 정리해서 다이어그램으로 나타냈다. 다이어그램은 파워포인트로 작성했는데, 표현의 한계가 있을 수도 있고, 다이어그램 작성을 처음 해본 탓에 오류가 있을 수도 있다.\n더 개선할 수 있을까? switch 줄이기 사실 처음 고민 했을 때에는 switch문 자체를 줄이고 싶었다. 지금 당장 생각나는 방법은 메소드 레퍼런스를 배열로 관리하는 것이라고 생각한다.\nint input = ...; // 입력 받고, 입력값 검증하는 단계 method[input]();. // method는 State이 관리 C#에서는 delegate를 통해서 가능할 것 같다는 생각이 드는데, 자바에서는 그런게 있는가 모르겠다. 이게 함수형 프로그래밍 기법 중 일종이라고 알고 있는데, 아마 자바도 지원하지 않을까 생각한다.\n복잡해진 구조 클래스를 추가로 더 만들고, 코드를 여러 클래스로 분리하다 보니까 초기 해답보다 복잡해지고, 코드가 조금 더 길어진 감은 있다. 객체지향이 갖는 어쩔 수 없는 점이라고 생각하지만, 더 좋은 구조가 있겠다는 생각이 든다. 경험이나 지식이 좀 부족하다.\n","wordCount":"1182","inLanguage":"ko","datePublished":"2022-01-29T16:07:14+09:00","dateModified":"2022-01-29T16:07:14+09:00","author":{"@type":"Person","name":"green-21"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://green-21.github.io/posts/study/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C/"},"publisher":{"@type":"Organization","name":"gReen","logo":{"@type":"ImageObject","url":"https://green-21.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://green-21.github.io/ accesskey=h title="gReen (Alt + H)">gReen</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://green-21.github.io/en/ title=en aria-label=en>En</a></li></ul></div></div><ul id=menu><li><a href=https://green-21.github.io/archives/ title=아카이브><span>아카이브</span></a></li><li><a href=https://green-21.github.io/posts/ title=카테고리><span>카테고리</span></a></li><li><a href=https://green-21.github.io/tags/ title=태그><span>태그</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>객체지향적으로</h1><div class=post-meta><span title='2022-01-29 16:07:14 +0900 +0900'>1월 29, 2022</span>&nbsp;·&nbsp;green-21</div></header><div class=post-content><h2 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h2><p>  과제로 제출했던 코드 중 하나를 조금 더 객체지향적으로 변경하고 이를 설명하는 것을 주제로 학교 자바 수업의 기말 발표를 한 적이 있다. 과거 엉망인 코드를 짜면서 느꼈던 불편함과 그 당시 클린코드를 읽으면서 코드의 퀄리티와 객체지향에 대한 관심이 많아졌고, 이를 실습해보고 싶어 해당 주제를 선정했다. 그 때의 내용을 간단하게 기록하고자 한다.</p><p> </p><h2 id=문제>문제<a hidden class=anchor aria-hidden=true href=#문제>#</a></h2><p>사용한 예제는 <strong>명품 자바 에센셜의 5장 실습문제 6번</strong>이다.</p><blockquote><p>💡 [실습문제 6번] 간단한 그래픽 편집기를 만들어보자. 본문 5.6절의 메소드 오버라이딩과 5.7절의 추상 클래스의 설명 중에 Line, Rect, Circle 클래스 코드를 활용하여, 다음 실행 결과처럼 동작하는 프로그램을 작성하라.</p></blockquote><pre tabindex=0><code>삽입(1), 삭제(2), 모두보기(3), 종료(4) &gt;&gt; 1
도형 종류 LINE(1), RECT(2), CIRCLE(3) &gt;&gt; 1
삽입(1), 삭제(2), 모두보기(3), 종료(4) &gt;&gt; 1
도형 종류 LINE(1), RECT(2), CIRCLE(3) &gt;&gt; 3
삽입(1), 삭제(2), 모두보기(3), 종료(4) &gt;&gt; 3
Line
Circle
삽입(1), 삭제(2), 모두보기(3), 종료(4) &gt;&gt; 2
삭제할 도형 위치 &gt;&gt; 3
삭제할 수 없습니다.
삽입(1), 삭제(2), 모두보기(3), 종료(4) &gt;&gt; 4
프로그램을 종료합니다...
</code></pre><p>  사실 객체지향을 설명하는 단원의 문제여서, 문제의 요지도 다형성을 구현하는 것이었다. Draw()라는 추상함수를 갖는 추상 클래스 Shape를 Line, Rect, Circle로 구현하고, Shape 객체로 이를 업캐스팅해서 오버라딩된 함수를 호출하는 것을 구현하는 것이 문제의 정답이라고 할 수 있다.</p><p> </p><h2 id=풀이>풀이<a hidden class=anchor aria-hidden=true href=#풀이>#</a></h2><ul><li><p><strong>shape.java</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>draw</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Line</span> <span style=color:#66d9ef>extends</span> Shape {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Line&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Rect</span> <span style=color:#66d9ef>extends</span> Shape {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Rect&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Circle</span> <span style=color:#66d9ef>extends</span> Shape {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>draw</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Circle&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br></li><li><p><strong>Main.java</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> scanner <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> shapes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Vector<span style=color:#f92672>&lt;</span>Shape<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>int</span> option <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>			System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;삽입(1), 삭제(2), 모두보기(3), 종료(4) &gt;&gt; &#34;</span>);
</span></span><span style=display:flex><span>			option <span style=color:#f92672>=</span> scanner.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>switch</span>(option) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> 1:
</span></span><span style=display:flex><span>				System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;도형 종류 Line(1), Rect(2), Circle(3) &gt;&gt; &#34;</span>);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>int</span> op2 <span style=color:#f92672>=</span> scanner.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>switch</span>(op2) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> 1:
</span></span><span style=display:flex><span>					shapes.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> Line());
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> 2:
</span></span><span style=display:flex><span>					shapes.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> Rect());
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>case</span> 3:
</span></span><span style=display:flex><span>					shapes.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> Circle());
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> 2:
</span></span><span style=display:flex><span>				System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;삭제할 도형의 위치&gt;&gt; &#34;</span>);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> scanner.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>				shapes.<span style=color:#a6e22e>remove</span>(index);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> 3:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> itor <span style=color:#f92672>=</span> shapes.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>while</span>(itor.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>var</span> obj <span style=color:#f92672>=</span> itor.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>					obj.<span style=color:#a6e22e>draw</span>();
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>while</span>(option <span style=color:#f92672>!=</span> 4);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>예외 처리 같은 더 신경써줘야 할 것들이 있지만 일단은 생략했다.</p><p> </p><h2 id=더-생각해볼-문제>더 생각해볼 문제<a hidden class=anchor aria-hidden=true href=#더-생각해볼-문제>#</a></h2><h3 id=반복되는-동일-구조>반복되는 동일 구조<a hidden class=anchor aria-hidden=true href=#반복되는-동일-구조>#</a></h3><p>다만, 위 코드는 불편함이 존재한다. 선택지를 구현하는 코드는 동일한 구조가 반복된다. 그러나, 이를 반복해서 작성하고 있다. 즉, DRY하지 않다! 만약 선택지가 늘어난다면 늘어내는대로 선택지를 중첩해서 추가 작성해야 한다. 아마 굉장히 꼴뵈기 힘든 코드가 만들어 질 것이다. 위의 코드도 벌써 도형을 삽입할 때, 2개의 swtich문이 반복해서 나타난다.</p><p><img loading=lazy src=1.png alt=공통구조.png></p><h3 id=절차적인-코드>절차적인 코드<a hidden class=anchor aria-hidden=true href=#절차적인-코드>#</a></h3><p>main 함수에 모든 코드가 담겨 있다는 것이 문제가 될 수도 있다. 클린 코드에 따르면 함수와 클래스는 최대한 작고 하나의 책임만을 가져야 한다고 한다. 그러나 지금 main에서 모든 일을 담당하고 있다. 이를 분리할 필요가 있다.</p><p> </p><h2 id=객체지향으로>객체지향으로<a hidden class=anchor aria-hidden=true href=#객체지향으로>#</a></h2><h3 id=1-vector와-scanner-클래스에-대한-wrapper>1. Vector와 Scanner 클래스에 대한 Wrapper<a hidden class=anchor aria-hidden=true href=#1-vector와-scanner-클래스에-대한-wrapper>#</a></h3><p><img loading=lazy src=2.png alt="외부 코드 감싸기.png"></p><p>클린 코드에서 외부 라이브러리를 사용하게 될 때, 외부 라이브러리의 변화가 미치는 정도를 줄이기 위해서 그 라이브러리의 클래스들을 한 번 감싸 경계를 구분해야 한다고 했다. 그래서, 앞서 사용한 <code>Vector</code>를 감싼 <code>ShapeManager</code>와 <code>Scanner</code>를 감싼 <code>Prompt</code> 클래스를 만든다.</p><ul><li><p><strong>ShapeManager</strong></p><ul><li>ShapeManager는 특히 일급 컬렉션이라고 하는 것 같은데, 이름이 멋있는 것 치고는 특별한 의미가 있다고 생각하지는 않는다. 다만, 뭔가 조금 더 기능 단위를 확실하게 구분하는 느낌이다. 그 외에는 어떤 데이터 객체에 특별한 이름을 붙인 것이 조금 더 특별하다면 특별하다고 할 수 있을 것 같다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Iterator;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Vector;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShapeManager</span> {
</span></span><span style=display:flex><span>    Vector<span style=color:#f92672>&lt;</span>Shape<span style=color:#f92672>&gt;</span> store;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(Shape s) {
</span></span><span style=display:flex><span>        store.<span style=color:#a6e22e>add</span>(s);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            store.<span style=color:#a6e22e>remove</span>(index);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (ArrayIndexOutOfBoundsException e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printAll</span>() {
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;</span>Shape<span style=color:#f92672>&gt;</span> iter <span style=color:#f92672>=</span> store.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(iter.<span style=color:#a6e22e>hasNext</span>())
</span></span><span style=display:flex><span>            iter.<span style=color:#a6e22e>next</span>().<span style=color:#a6e22e>draw</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>Prompt</strong></p><ul><li>Prompt의 경우 더 좋은 클래스 이름이 있을 것 같지만 영어 능력의 한계로 Prompt라고 했다.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.InputMismatchException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Scanner;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Prompt</span> {
</span></span><span style=display:flex><span>    Scanner scanner;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Prompt</span>() {
</span></span><span style=display:flex><span>        scanner <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>prompt</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> scanner.<span style=color:#a6e22e>nextInt</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span>(InputMismatchException e) {
</span></span><span style=display:flex><span>            n <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span>() {
</span></span><span style=display:flex><span>        scanner.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>이렇게 하면, 변경이 존재할 때, 대응하기가 쉬워진다. 해당 클래스만 변경해주면 되니까 말이다. Prompt의 경우 만약 시스템을 cui에서 gui로 변경하거나 유사한 변경사항이 있을 때, 인터페이스만 잘 설계했다면, Prompt만 수정하고 나머지 Prompt를 사용하는 코드는 수정이 거의 필요 없을 것이다. 이를 캡슐화와 정보 은닉의 장점이라고 할 수 있다.</p><h3 id=2-다형성을-이용해-구조-변경하기>2. 다형성을 이용해 구조 변경하기<a hidden class=anchor aria-hidden=true href=#2-다형성을-이용해-구조-변경하기>#</a></h3><p><strong>한 선택지 분기마다 하나의 클래스를 작성한다.</strong> 각 클래스는 하나의 추상클래스를 상속 받는다. 이를 <code>**State**</code>이라고 이름 붙였고, 이를 구현하는 클래스의 이름 끝에도 State이라는 단어를 붙였다. 이것 역시 State보다 더 좋은 이름이 있을 거라고 생각하지만, 역시 역량이 부족했다.</p><p>각 클래스가 구현해야하는 것들은 다음과 같다.</p><ol><li>출력 메시지</li><li>해당 분기가 입력을 요구하는지 여부</li><li>분기에서 처리해야할 메인 로직</li></ol><ul><li><p><strong>State</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> prompt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>State</span>(<span style=color:#66d9ef>boolean</span> prompt) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>prompt</span> <span style=color:#f92672>=</span> prompt;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isNeedPrompt</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prompt;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printMsg</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> State <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>int</span> input, ShapeManager sm);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>MainState</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MainState</span> <span style=color:#66d9ef>extends</span> State {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MainState</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printMsg</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;삽입(1), 삭제(2), 모두 보기(3), 종료(4)&#34;</span>);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> State <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>int</span> input, ShapeManager sm) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span>(input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 1: <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> InsertState();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 2: <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> DeleteState();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 3:
</span></span><span style=display:flex><span>            sm.<span style=color:#a6e22e>printAll</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 4: <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span> :
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;잘못된 선택지입니다. 다시 선택해주세요.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>InsertState</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InsertState</span> <span style=color:#66d9ef>extends</span> State {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>InsertState</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printMsg</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;도형 종류 Line(1), Rect(2), Circle(3) &gt;&gt;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> State <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>int</span> input, ShapeManager sm) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span>(input) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 1:
</span></span><span style=display:flex><span>            sm.<span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>new</span> Line());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 2:
</span></span><span style=display:flex><span>            sm.<span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>new</span> Rect());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> 3:
</span></span><span style=display:flex><span>            sm.<span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>new</span> Circle());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>default</span> :
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;잘못된 선택지입니다. 다시선택하세요.&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MainState();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><strong>DeleteState</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DeleteState</span> <span style=color:#66d9ef>extends</span> State {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>DeleteState</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printMsg</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;삭제할 도형의 위치 &gt;&gt;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> State <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>int</span> input, ShapeManager sm) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>sm.<span style=color:#a6e22e>delete</span>(input))
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;삭제할 수 없습니다.&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MainState();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>이제 선택지가 더 필요한 경우에는 State 클래스를 하나 더 만들고, 다른 클래스와 연관시키기만 하면 된다. 다만, 개선사항이 있다면, 해당 구조는 클래스간 연관관계를 잘 살펴봐야 한다는 것이다. 그리고 본질적으로 스위치를 없애고 싶었지만 그러지 못했다.</p><h3 id=3-main에서-조립>3. main에서 조립<a hidden class=anchor aria-hidden=true href=#3-main에서-조립>#</a></h3><ul><li><p><strong>GraphicEditor - Main</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GraphicEditor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Prompt prompt <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Prompt();
</span></span><span style=display:flex><span>        ShapeManager shapes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ShapeManager();
</span></span><span style=display:flex><span>        State state <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MainState();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(state <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> inputValue <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1;
</span></span><span style=display:flex><span>            state.<span style=color:#a6e22e>printMsg</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(state.<span style=color:#a6e22e>isNeedPrompt</span>()) inputValue <span style=color:#f92672>=</span> prompt.<span style=color:#a6e22e>prompt</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> nextState <span style=color:#f92672>=</span> state.<span style=color:#a6e22e>process</span>(inputValue, shapes);
</span></span><span style=display:flex><span>            state <span style=color:#f92672>=</span> nextState;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        prompt.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>main에서는 작성했던 클래스들을 조립했다.</p></li><li><p>정확하게 메인 루프에는 선택 안내 메시지 출력(<code>printMsg()</code>) → 선택지 입력(<code>prompt()</code>) → 선택지에 따른 행동(<code>process()</code>)이라는 한가지 구조만 눈에 보인다. 다형성을 이용해서 동일한 구조에서 다른 행동을 할 수 있게 되었다.</p></li><li><p>다른 선택지를 추가해야할 때에는 클래스를 작성하면 된다.</p></li></ul><h3 id=4-클래스-다이어그램>4. 클래스 다이어그램<a hidden class=anchor aria-hidden=true href=#4-클래스-다이어그램>#</a></h3><p><img loading=lazy src=3.png alt=클래스다이어그램.png></p><p>코드들을 정리해서 다이어그램으로 나타냈다. 다이어그램은 파워포인트로 작성했는데, 표현의 한계가 있을 수도 있고, 다이어그램 작성을 처음 해본 탓에 오류가 있을 수도 있다.</p><h2 id=더-개선할-수-있을까>더 개선할 수 있을까?<a hidden class=anchor aria-hidden=true href=#더-개선할-수-있을까>#</a></h2><h3 id=switch-줄이기>switch 줄이기<a hidden class=anchor aria-hidden=true href=#switch-줄이기>#</a></h3><p>사실 처음 고민 했을 때에는 switch문 자체를 줄이고 싶었다. 지금 당장 생각나는 방법은 메소드 레퍼런스를 배열로 관리하는 것이라고 생각한다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> input <span style=color:#f92672>=</span> ...; <span style=color:#75715e>// 입력 받고, 입력값 검증하는 단계</span>
</span></span><span style=display:flex><span>method<span style=color:#f92672>[</span>input<span style=color:#f92672>]</span>();. <span style=color:#75715e>// method는 State이 관리</span>
</span></span></code></pre></div><p>C#에서는 delegate를 통해서 가능할 것 같다는 생각이 드는데, 자바에서는 그런게 있는가 모르겠다. 이게 함수형 프로그래밍 기법 중 일종이라고 알고 있는데, 아마 자바도 지원하지 않을까 생각한다.</p><h3 id=복잡해진-구조>복잡해진 구조<a hidden class=anchor aria-hidden=true href=#복잡해진-구조>#</a></h3><p>클래스를 추가로 더 만들고, 코드를 여러 클래스로 분리하다 보니까 초기 해답보다 복잡해지고, 코드가 조금 더 길어진 감은 있다. 객체지향이 갖는 어쩔 수 없는 점이라고 생각하지만, 더 좋은 구조가 있겠다는 생각이 든다. 경험이나 지식이 좀 부족하다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://green-21.github.io/tags/java/>java</a></li><li><a href=https://green-21.github.io/tags/design/>design</a></li></ul><nav class=paginav><a class=prev href=https://green-21.github.io/posts/study/hugo%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/><span class=title>« 이전 페이지</span><br><span>Hugo사용하기1</span></a></nav></footer></article><br><script src=https://utteranc.es/client.js repo=green-21/green-21.github.io issue-term=title theme=preferred-color-scheme crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2024 <a href=https://green-21.github.io/>gReen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>